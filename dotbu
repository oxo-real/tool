#!/bin/bash
#
##
###      _       _   _
###   __| | ___ | |_| |__  _   _
###  / _` |/ _ \| __| '_ \| | | |
### | (_| | (_) | |_| |_) | |_| |
###  \__,_|\___/ \__|_.__/ \__,_|
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### Â© 2020 - 2021 cytopyge
###
###	usage:	dotbu backup  [<bu_src> <bu_dest>]
###			dotbu restore [<rs_src> <rs_dest>]
###
### i.e.:	dotbu backup $XDG_CONFIG_HOME $HOME/.dot/files
###			dotbu restore $HOME/.dot/files $XDG_CONFIG_HOME
##
#


# dependencies

##	openssl, source/functions


# functionality

## backup
##	1.	copy directories from source to destination directory
##	2.	encrypt files or directories

## restore
##	1.	copy directories from source to destination directory
##	2.	decrypt files or directories


mode=$1				# 'backup' or 'restore'
src=$2				# source directory
dest=$3				# destination directory


sourcing()
{
	# external code sources
	source_dir="$XDG_DATA_HOME/git/code/sources/functions"
	source $source_dir/reply_functions
	source $source_dir/text_appearance
}


initialize()
{
	# initializing variables

	## not all of .config has to be uploaded to the public repository;
	## only the customized files
	## files that are not to be published
	## are mentioned in the file process list (fpcl)
	## their lines start with '# '

	## files / directories to en-/decrypt
	## their lines start with 'c '

	fpcl_file="$src/.fpcl"


	case $mode in

		backup)
			# backup_definitions
				## location_definitions
				bu_src=$src
				bu_dest=$dest
			;;

		restore)
			# restore_definitions
				## location definitions
				re_src=$src
				re_dest=$dest
			;;

		*)
			# no mode entry
			printf "enter mode as backup or restore\n"
			exit 4

	esac

	printf "\nmode:   ${INV}${BOLD} $mode ${NOC}\n"

}


validate_source()
{
	# directory validity check

	if [[ -z $src ]]; then

		# both no src and dest are given
		printf "please enter a source argument, exiting, bye!"
		exit 9

	fi


	if [[ ! -d $src ]]; then

		printf "source:		${RED}$src${NOC}\n\n"

		printf "${RED}source${NOC} does not exist\n"
		printf "exiting, bye!\n"
		exit 11

	else

		printf "source:		$src\n"

	fi
}


validate_destination()
{
	if [[ -z $dest ]]; then

		# source is given, destination is empty
		case $mode in

			backup)

				printf "${RED}no destination argument${NOC}, exiting, bye!\n"
				exit 11
				;;

			restore)

				re_dest=$(head -n 1 $src/.src)
				printf "destination:	${RED}no argument${NOC}\n"

				if [[ ! -z $re_dest ]]; then

					printf "		${YELLOW}$re_dest${NOC}\n\n"

					printf "is this okay? (y/N) "
					reply_single
					echo

				else

					printf "exiting, bye!\n"

				fi

				if printf "$reply" | grep -iq "^y"; then

					echo

				else

					printf "\nno valid destination argument, exiting, bye!\n"
					exit 12

				fi
				;;

		esac

	elif [[ ! -d $dest ]]; then

		printf "destination:	${RED}$dest${NOC}\n\n"

		printf "${RED}destination${NOC} does not exist\n\n"
		printf "create? (y/N) "
		reply_single
		echo

		if printf "$reply" | grep -iq "^y"; then

			printf "about to create ${YELLOW}$dest${NOC}\n\n"
			printf "sure? (y/N) "
			reply_single
			echo

			if printf "$reply" | grep -iq "^y"; then

				printf "creating	${GREEN}$dest${NOC}\n"
				mkdir -p $dest

			else

				printf "\nno valid destination, exiting, bye!\n"
				exit 12

			fi

		else

			printf "no valid destination, exiting, bye!\n"
			exit 13

		fi

		echo

	else

		printf "destination:	$dest\n\n"

	fi

	case $mode in

		backup)
			# req: .fpcl_file in source
			[[ ! -f $src/.fpcl ]] && printf "${RED}no .fpcl file found in $bu_src${NOC}\n" && exit 21
			;;

		restore)
			# req: .src file in source
			[[ ! -f $src/.src ]] && printf "${RED}no .src file found in $re_src${NOC}\n" && exit 22
			# req: .fpcl_file in source
			[[ ! -f $src/.fpcl ]] && printf "${RED}no .fpcl file found in $bu_src${NOC}\n" && exit 22
			;;

	esac

	# empty $dest
	if [[ ! -z $(ls -A $dest 2>/dev/null) ]]; then
		printf "${YELLOW}destination${NOC} directory is ${BOLD}NOT${NORMAL} empty${NOC}\n\n"

			printf "continue? (y/N) "
			reply_single
			echo

			if printf "$reply" | grep -iq "^y"; then

				echo
				printf "starting $mode operation\n"

			else

				printf "operation ${RED}aborted${NOC}, exiting, bye!\n"
				exit 23

			fi

	fi
}


copy()
{
	case $mode in

		backup)

			# generate rsync_exclude_list

			rsync_exclude_list="$dest/.rexl"

			while IFS= read -r fpcl_location; do


				# don 't process ###' commented lines
				if [[ "$(printf "$fpcl_location" | head -c 3)" == "###" ]]; then

					continue

				fi


				# skip empty lines
				if [[ -z "$fpcl_location" ]]; then

					continue

				fi


				# find lines starting with 'hashtag space'
				# to add to exclude list
				if [[ $(printf "$fpcl_location" | grep '^# ') ]]; then

					location_to_add="$(printf "$fpcl_location" | awk '{print $2}')"

					printf "$location_to_add\n" >> "$rsync_exclude_list"

				fi

			done < $fpcl_file


			# keep files with .aes and .hash extensions
			printf "*.aes\n" >> "$rsync_exclude_list"
			printf "*.hash\n" >> "$rsync_exclude_list"

			# copy files to destination
			rsync -aAXv --exclude-from=$rsync_exclude_list --delete $bu_src/ $bu_dest
			#rsync -aAXv --exclude-from=$rsync_exclude_list $bu_src/ $bu_dest

			# remove rsync exclude list
			rm $rsync_exclude_list

			# write .src file to destination
			printf "$bu_src\n" > "$bu_dest/.src"
			date +%Y%m%d_%H%M%S_%N_%z_%Z_%V >> "$bu_dest/.src"
			;;

		restore)

			rsync -aAXv $re_src/ $re_dest
			;;

	esac
}


modify()
{
	case $mode in

		backup)

			# remove all git databases
			find $bu_dest -type d -name .git -exec rm -rf {} \;
			;;

		esac
}


crypt()
{
	enter_password

	case $mode in


		backup)


			# encrypt locations (lines) in fpcl_file

			while IFS= read -r fpcl_location; do


				# don 't process ###' commented lines
				if [[ "$(printf "$fpcl_location" | head -c 3)" == "###" ]]; then

					continue

				fi


				# skip empty lines
				if [[ -z "$fpcl_location" ]]; then

					continue

				fi


				# find lines starting with 'c space'
				if [[ $(printf "$fpcl_location" | grep '^c ') ]]; then

					# make relative location in fpcl_file absolute to destination
					# (bu_dest), because files are already copied at this point
					# and encryption has to be done in destination, not source!

					# crypt_loc is the location (file/dir) that has to be encrypted
					crypt_loc="$bu_dest/$(printf "$fpcl_location" | awk '{print $2}')"


					# crypt_loc is a directory
					if [[ -d $crypt_loc ]]; then

						printf "$crypt_loc"

						## create a tar archive name (variable)
						tar_name="$crypt_loc.tar"

						## create directory if non-existent
						tar_name_dir=$(dirname $tar_name)
						[[ -d $tar_name_dir ]] || mkdir -p $tar_name_dir

						## create a tar archive with directory contents
						tar -czf $tar_name -C $bu_src $fpcl_location  1>&2 2>/dev/null
						printf ".tar"

						## remove crypt_loc directory
						destroy $crypt_loc

						## calculate new $tar_name hash
						tar_name_hash_new=$(openssl sha3-512 $tar_name | awk '{print $2}')

						## get existing $tar_name hash
						[[ -f "$tar_name.hash" ]] && \
							tar_name_hash_exist=$(cat "$tar_name.hash") || \
							tar_name_hash_exist=0

						## compare hash_new with hash_exist
						if [[ "$tar_name_hash_new" != "$tar_name_hash_exist" ]]; then

							printf "$tar_name_hash_new" > "$tar_name.hash"

						elif [[ "$tar_name_hash_new" == "$tar_name_hash_exist" ]]; then

							## remove the unencrypted tar archive
							destroy $tar_name

							printf ".aes unchanged\n"

							continue

						fi

						## encrypt the tar archive
						tar_crypt_name="$tar_name.aes"
						openssl enc \
							-e \
							-aes-256-cbc \
							-base64 \
							-pbkdf2 \
							-salt \
							-pass pass:$pw \
							-in $tar_name \
							-out $tar_crypt_name

						## remove the unencrypted tar archive
						destroy $tar_name

						printf ".aes\n"


					# crypt_loc is a file

					elif [[ -f $crypt_loc ]]; then

						## create encrypted file name
						file_name="$crypt_loc"
						file_crypt_name="$file_name.aes"

						## create directory if non-existent
						file_name_dir=$(dirname $file_name)
						[[ -d $file_name_dir ]] || mkdir -p $file_name_dir

						printf "$file_name"

						## calculate new $file_name hash
						file_name_hash_new=$(openssl sha3-512 $file_name | awk '{print $2}')

						## get existing $file_name hash
						[[ -f $file_name.hash ]] && \
							file_name_hash_exist=$(< $file_name.hash) || \
							file_name_hash_exist=0

						## compare hash_new with hash_exist
						if [[ "$file_name_hash_new" != "$file_name_hash_exist" ]]; then

							printf "$file_name_hash_new" > "$file_name.hash"

						elif [[ "$file_name_hash_new" == "$file_name_hash_exist" ]]; then

							## remove the unencrypted tar archive
							destroy $file_name

							printf ".aes\n"

							continue

						fi

						## encrypt the file
						openssl enc \
							-e \
							-aes-256-cbc \
							-base64 \
							-pbkdf2 \
							-salt \
							-pass pass:$pw \
							-in $file_name \
							-out $file_crypt_name

						## remove the unencrypted file
						destroy $file_name

						printf ".aes\n"

					else

						printf "${RED}$crypt_loc is not a file or directory${NOC}\n"

						continue

					fi

				fi

			done < $fpcl_file
			;;


		restore)


			# decrypt locations (lines) in fpcl_file

			while IFS= read -r fpcl_location; do


				# don 't process ###' commented lines
				if [[ "$(printf "$fpcl_location" | head -c 3)" == "###" ]]; then

					continue

				fi


				# skip empty lines
				if [[ -z "$fpcl_location" ]]; then

					continue

				fi


				# find lines starting with 'c space'
				if [[ $(printf "$fpcl_location" | grep '^c ') ]]; then

					# make relative location in fpcl_file absolute to destination
					# (re_dest), because files are already copied at this point
					# and decryption has to be done in destination, not source!
					crypt_loc="$re_dest/$(printf "$fpcl_location" | awk '{print $2}')"

					tput sc

					# crypt_loc is a tar.aes file

					if [[ -f "$crypt_loc.tar.aes" ]]; then

						# encrypted file has .tar.aes extention
						# therefore original is a directory (no file)

						printf "$crypt_loc.tar.aes"

						## create a tar archive name
						tar_name="$crypt_loc.tar"

						## decrypt the aes file
						tar_crypt_name="$crypt_loc.tar.aes"
						openssl enc \
							-d \
							-aes-256-cbc \
							-base64 \
							-pbkdf2 \
							-salt \
							-pass pass:$pw \
							-in $tar_crypt_name \
							-out $tar_name

						tput rc
						tput ed
						printf "$crypt_loc.tar"

						## remove the aes file
						destroy $tar_crypt_name

						## create directory if non-existent
						[[ -d $crypt_loc ]] || mkdir -p $crypt_loc

						## extract contents from tar archive
						tar -xzf $tar_name -C $re_dest/ $fpcl_location 1>&2 2>/dev/null
						#tar -xzf $tar_name $crypt_loc 1>&2 2>/dev/null

						tput rc
						tput ed
						printf "$crypt_loc"

						## remove crypt_loc.tar
						destroy $crypt_loc.tar

						tput cud1

					# crypt_loc is a file

					elif [[ -f "$crypt_loc.aes" ]]; then

						# encrypted file has .aes extention
						# therefore original is a file (no dir)

						## create encrypted file name
						file_name="$crypt_loc"
						file_crypt_name="$file_name.aes"

						tput rc
						tput ed
						printf "$file_crypt_name"

						## create directory if non-existent
						#file_name_dir=$(dirname $file_name)
						#[[ -d $file_name_dir ]] || mkdir -p $file_name_dir

						## decrypt the aes file
						openssl enc \
							-d \
							-aes-256-cbc \
							-pbkdf2 \
							-salt \
							-base64 \
							-pass pass:$pw \
							-in $file_crypt_name \
							-out $file_name

						## remove the encrypted file
						destroy $file_name.aes

						tput rc
						tput ed
						printf "$file_name"

						tput cud1

					else

						printf "${RED}$crypt_loc is not a file or directory${NOC}\n"

						continue

					fi

				fi

			done < $fpcl_file
			;;

	esac

	clear_password

}


verify()
{
	case $mode in

		backup)
			# all 'c' marked locations are indeed encrypted
			no_aes_files_created=$(find $bu_dest -name '*.aes' | wc -l)
			no_c_lines_fpcl=$(grep '^c ' $fpcl_file | wc -l)

			if [[ "$no_aes_files_created" == "$no_c_lines_fpcl" ]]; then

				printf "encrypted:$no_aes_files_created=$no_c_lines_fpcl"
				exit 0

			else

				echo
				printf "$no_aes_files_created locations (files/directories) encrypted in $bu_dest\n"
				printf "$no_c_lines_fpcl locations designated to be encrypted in $fpcl_file\n"
				exit 81

			fi
			;;

	esac
}

# internal calls
enter_password()
{
	#pwgn(r5r6)
	sh $XDG_DATA_HOME/git/code/tools/pwgn
	pw=$(wl-paste -n)
	echo
}

clear_password()
{
	pw=$(< /dev/random tr -d -c "[:xdigit:]" | head -c 64)
	unset pw
}

destroy(){
	chmod -R 777 $1
	find $1 -depth -type f -exec shred -n 3 --remove=wipesync {} \;
	rm -rf $1
}


sourcing
initialize
validate_source
validate_destination
copy
#modify
crypt
verify
