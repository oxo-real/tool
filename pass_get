#!/bin/bash
#
##
###                                     _
###  _ __   __ _ ___ ___      __ _  ___| |_
### | '_ \ / _` / __/ __|    / _` |/ _ \ __|
### | |_) | (_| \__ \__ \   | (_| |  __/ |_
### | .__/ \__,_|___/___/____\__, |\___|\__|
### |_|                |_____|___/
###
###  _ _|_ _   ._  _  _
### (_\/|_(_)\/|_)(_|(/_
###   /      / |   _|
###
###	(c)	2020 - 2021 cytopyge
###
### pass_get:	fzf cli wrapper for pass
###
### usage:		pass_get
###				OR
###				pass_get $object
###				OR
###				pass_get $object $element
##
#


object=$1
element=$2

source $XDG_DATA_HOME/git/code/sources/functions/text_appearance

## store_l is the symlink location (to the pass password store)
## recommended to mount an encrypted vault container
## then symlink .password-store to a container mountpoint
## default symlink:	$HOME/.password-store
## default target:	$HOME/dock/vlt/pass
store_l="$HOME/.password-store"
## store is the genuine password store location
store=$(readlink $store_l)

## objects can be searched for one or more elements
## regular elements are: url, userid, password
## elements that can be retrieved with pass_get are:
elements=(\
	"1 url" \
	"2 userid" \
	" " \
	"3 password" \
	"4 otp" \
	"5 unlock" \
	"6 peacto" \
	" " \
	"7 auto_entry" \
	" " \
	"91 obj_show" \
	"92 obj_edit" \
	"99 obj_name" \
	" " \
	"0 cancel")

## the pass help file refers to objects by naming them 'passwords'
## so insert a new password means making a new .gpg file
## pass expects the first line of the gpg file to be the password
## the gpg file can contain more than just the password though
## this script make use of that
## here an object is the way pass represent a gpg file
## (filename without .gpg extension)


check_mountpoint()
{
	mountpoint -q $store_l
	[[ $? -ne 0 ]] && printf "${MAGENTA}store is not mounted${NOC}\n" && exit 32
}


get_object()
{
	if [[ -z $object ]]; then

		object=$(find -L $store_l -type f -iname '*.gpg' | \
			# with sed we remove the leading path of $store_l
			# internal field separator is '|'
			# because the path itself contains '/'
			sed "s|$store_l/||g" | \
			# with sed we remove the trailing .gpg extension
			sed "s/.gpg//g" | \
			sort | \
			fzf --prompt='select object ')

	fi
}


get_element()
{
	if [[ -z $element ]]; then

		element=$(printf '%s\n' "${elements[@]}" | fzf --prompt='select element ' | awk '{print $2}')

	fi
}


process_object()
{
	# empty object selection
	[[ -z $object ]] && exit 0

	# otp object
	if [[ -n $(printf "$object" | grep ^otp) ]]; then

		get_otp

		exit 0

	fi
}


get_element_value()
{
	element_value=$(pass show $object | grep ^$element: | awk '{print $2}')

	check_element_value

	## '%s' prevents 'invalid format character' error
	printf '%s' "$element_value" | wl-copy -n -o
}



get_password()
{
	pass $object | head -n 1 | wl-copy -n -o
}


get_otp()
{
	# redirection to the separate otp file
	if [[ "$(printf $object | head -c 4)" != "otp_" ]]; then

		object="otp_$object"

	fi

	if [[ -f $store/$object.gpg ]]; then

		pass otp $object | wl-copy -n -o

	fi

	# reset object value for human info
	object=$(printf $object | cut -c 5-)

	#[[ -z $element_value ]] && element="$element ${MAGENTA}no element value${NOC}"
}


pass_element()
{
	# run pass natively with $element
	clear
	human_info
	pass $element $object
}


check_element_value()
{
	## no auto_entry
	if [[ -z $ae ]]; then

		if [[ -z $element ]]; then

			element="${MAGENTA}no element selected${NOC}"

		elif [[ -z $element_value ]]; then

			element="$element ${MAGENTA}no value${NOC}"

		fi
		#[[ -z $element ]] && printf "${MAGENTA}no element selected${NOC}\n" && exit 10
		#[[ -z $element_value ]] && printf "${MAGENTA}no element value${NOC}\n" && exit 10

	fi

	## auto_entry
	if [[ -n $ae ]]; then

		# [TODO] [[ -z $element_value ]] && element_value="${MAGENTA}no element value${NOC}"
		[[ -z $element_value ]] && notify-send "no element value" && exit

	fi
}


human_info()
{
	error_message

	if [[ -z $ae ]]; then

		printf "$object $element ${MAGENTA}$error${NOC}\n"

	elif [[ -n $ae ]]; then

		notify-send "$element"
		sleep $t

	fi

}


error_message()
{
	## selected empty line in element menu
	if [[ $element == " " ]]; then

		error="no valid selection"

	fi
}


auto_entry()
{
	ae=1
	## sleep time
	t=5

	element="url"
	get_element_value
	qutebrowser --target tab $element_value &
	t=$((t * 2))
	human_info
	#notify-send "$element"
	#sleep $((t * 2))

	element="userid"
	get_element_value
	t=$t
	human_info
	#notify-send "$element"
	#sleep $t

	element="password"
	get_password 1> /dev/null #no stdout
	human_info
	#notify-send "$element"
	#sleep $t

	element="otp"
	get_otp
	if [[ -z $otp ]]; then
		human_info
		#notify-send "$element"
		#sleep $t
	fi

	element="unlock"
	get_element_value
	if [[ -z $otp ]]; then
		human_info
		#notify-send "$element"
		#sleep $t
	fi
}


get_object_name()
{
	printf "$object" | wl-copy -n -o
}


process_element()
{
	case $element in

		password)
			get_password
			human_info
			;;

		otp)
			get_otp
			human_info
			;;

		auto_entry)
			auto_entry
			;;

		obj_show)
			element="show"
			pass_element
			;;

		obj_edit)
			element="edit"
			pass_element
			;;

		obj_name)
			get_object_name
			human_info
			;;

		"")
			human_info
			;;

		cancel)
			exit
			;;

		*)
			get_element_value
			human_info
			;;

	esac
}


check_mountpoint
get_object
process_object
get_element
process_element
