#!/bin/bash
#
##
### usage: enc_bu -e <source> <destination>
### usage: enc_bu -d <source> <destination>
###
###
#

args="$@"
opr=$1
src=$(realpath "$2")
dst=$(realpath "$3")
# crx	 = dst.crx file
#		!= dst openssl enc file_out

timestamp="`date "+%Y%m%d_%H%M%S"`"

cipher_list=$(\
	openssl enc -ciphers | \
	awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' \
	)

tmp_dir="$XDG_CACHE_HOME/temp/cryptrTEMP/$timestamp"
[[ ! -d $tmp_dir ]] && mkdir -p $tmp_dir

pw_dir="$PWD"


oper()
{
	# operation: encrypt or decrypt
	if [[ $opr == "-e" ]]; then

		opr="e"
		oper="encr"

	elif [[ $opr == "-d" ]]; then

		opr="d"
		oper="decr"

	fi
}


source_type()
{
	# source is file or directory
	# (only for oper = encr)
	if [[ -f $src ]]; then

		source_type='file'

	elif [[ -d $src ]]; then

		source_type='dir'

	fi
}


create_tar()
{
	# remove the first / from src to prevent // in tar_file
	tar_file=$tmp_dir/$(printf "$src" | cut -c 2-).tar
	mkdir -p $(dirname $tar_file)
	src_sub_dir=$(dirname $src)
	src_tar_get=$(basename $src)

	#[DEV]
	printf ">>> src_sub_dir	$src_sub_dir\n"
	printf ">>> src_tar_get	$src_tar_get\n"

	# create tar archive
	tar -czf $tar_file -C $src_sub_dir $src_tar_get
}


select_ciphers()
{
	# cipher pool array
	cipher_pool=($(\
		openssl enc -ciphers | \
		awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' | \
		cut -c 2- | \
		fzf -m \
		))
	cipher_pool_amount=${#cipher_pool[@]}
}


create_cipher_pool_file()
{
	#[TODO] temp file remove afterwards
	cipher_pool_file="$src.cpf"
	printf "%s\n" ${cipher_pool[@]} > "$cipher_pool_file"
}


running_rounds()
{
	round=1
	rounds=$cipher_pool_amount

	for cipher in ${cipher_pool[@]}; do

		printf "$cipher $round($rounds)\n"

		case $round in

			1)
				case $rounds in

					1)
						encrypt_once
						;;

					*)
						encrypt_first
						;;

				esac
				;;

			$rounds )
				encrypt_last
				;;

			*)
				encrypt_next
				;;

		esac

		round=$(( $round + 1 ))

	done
}


encrypt_first()
{
	# first encryption round

	case $oper in

		encr)
			## define file_in
			if [[ $source_type == "file" ]]; then

				file_in="$src"

			elif [[ $source_type == "dir" ]]; then

				file_in="$tar_file"

			fi
			;;

		decr)
			file_in=$crypt_file
			;;

	esac

	## define file_out
	file_out=$tmp_dir/$(basename $file_in).$round

	openssl_enc
	#openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in -out $file_out -pass pass:$pd
}


encrypt_next()
{
	# next encryption round

	case $oper in

		encr)
			## define file_in
			file_in="$file_out"

			## define file_out
			file_out=$tmp_dir/$(basename $file_in).$round
			;;

		decr)
			file_in=$crypt_file
			;;

	esac

	openssl_enc
	#openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in -out $file_out -pass pass:$pd
}


encrypt_last()
{
	# last encryption round
	case $oper in

		decr)
			file_in="$file_out"
			file_out="$dst"
			;;

		encr)
			## define file_out
			file_out="$src.crypt"
			;;

	esac

	openssl_enc
	#openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in -out $file_out -pass pass:$pd
}


encrypt_once()
{
	case $oper in

		encr)

			## define file_in
			case $source_type in

				file)

					file_in=$src
					;;

				dir)

					file_in=$tar_file
					;;

			esac


			## define openssl enc file_out
			file_out=$src.crypt

			;;

		decr)

			## define file_in
			file_in=$crypt_file

			## define out
			file_out=$dst

			;;

	esac

	openssl_enc
}


encrypt()
{
	# dst is location of the crx file
	[[ -z $dst ]] && dst="$pw_dir"
	[[ -d $dst ]] || printf "${RED}destination directory not found${NOC}\n"

	select_ciphers
	create_cipher_pool_file
	running_rounds
	create_crx
	cleanup
}


decrypt()
{
	if [[ ! -f $src ]]; then
		printf "${RED}cryptr error: source file not found${NOC}\n" && exit 217
	elif [[ -z $src ]]; then
		printf "${RED}cryptr error: missing src & dest file${NOC}\n" && exit 217
	fi

	if [[ -f $dst ]]; then
		printf "${RED}cryptr error: destination file already exists${NOC}\n" && exit 217
	fi
	if [[ -d $dst ]]; then
		printf "${RED}cryptr error: destination directory already exists${NOC}\n" && exit 217
	fi

	[[ -z $dst ]] && dst="$pw_dir"
	[[ -d $(dirname $dst) ]] || mkdir -p $(dirname $dst)

	check_if_crx
	open_crx
	get_crypto_data
	running_rounds
}


openssl_enc()
{
	openssl enc \
		-$opr \
		-base64 \
		-$cipher \
		-salt \
		-pbkdf2 \
		-in $file_in \
		-out $file_out \
		-pass pass:$pd
}


extract_tar()
{
	# extract tar archive
	tar -xvf $tmp_dir
}


destroy_tar()
{
	tmp_dir_del=$(printf $tmp_dir | cut -d / -f -6)
	rm -rf $tmp_dir_del
}


get_password()
{
	#[TODO] DEV
	pd="1"
}


create_crx()
{
	# create crypto box (crx)
	tar_file=$dst/$(basename $src).crx

	sub_dir=$(dirname $src)
	#sub_dir=$(dirname $file_out)

	file_out="$(basename $file_out)"
	cipher_pool_file="$(basename $cipher_pool_file)"

	# create tar archive
	tar -cf $tar_file $file_out
	#tar -cf $tar_file -C $sub_dir $file_out
	tar -rf $tar_file $cipher_pool_file
	#tar -rf $tar_file -C $sub_dir $cipher_pool_file
}


check_if_crx()
{
	if [[ -n $(printf "$src" | grep '.crx$') ]]; then

		if [[ -n $(file -b $src | grep 'tar archive') ]]; then

			# src is a tar file with crx extension
			#open_crx
			continue

		fi

	fi
}


open_crx()
{
	# extract crypto box contents (2 files)
	mkdir -p $tmp_dir
	tar -xvf $src -C $tmp_dir
}


get_crypto_data()
{
	# a crx file always contains only 2 files;
	# the crypto pool file (cpf) and
	# the encrypted (tar) file
	# so we can use the '! -name' construct

	# find encrypted (tar) file
	crypt_file=$(find $tmp_dir -type f ! -name "*.cpf")

	# find cypher pool file
	cipher_pool_file=$(find $tmp_dir -name "*.cpf")

	# get cypher pool details
	cipher_pool=($(tac $cipher_pool_file))
	cipher_pool_amount=${#cipher_pool[@]}
}


cleanup()
{
	case $oper in

		encr)
			destroy_tar
			rm -rf $file_out
			rm -rf $cipher_pool_file

			;;

		decr)
			#[TODO] destroy_opened_crx
			;;

	esac
}


main()
{
	oper
	get_password

	case $oper in

		encr)

			source_type

			case $source_type in

				file)

					encrypt
					;;

				dir)
					create_tar
					encrypt
					;;

			esac
			;;

		decr)

			decrypt
			extract_tar
			;;

	esac
}

main
