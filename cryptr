#! /usr/bin/env sh

###                        _
###   ___ _ __ _   _ _ __ | |_ _ __
###  / __| '__| | | | '_ \| __| '__|
### | (__| |  | |_| | |_) | |_| |
###  \___|_|   \__, | .__/ \__|_|
###            |___/|_|
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
cryptr
crypto with optional cipher cascade
copyright (c) 2021 - 2023  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
gpg, [openssl]
reply_functions, text_appearance

# usage

NOTICE compulsory argument order
cryptr [operation] source(s) [destination]

-e encrypt to a file
cryptr [-e] $src [$srcs] [$dst_file]

-d decrypt to a directory
cryptr [-d] $src [$dst_dir]

# examples
## encryption
cryptr plaintext

## decryption
cryptr crypttext.tarx


WARNING! risk in multi-user systems!
         writing temporary files

NOTICE	 some available (unsecure) ciphers may not be used for encryption
	 available are all versions of: AES, TWOFISH and CAMELIA

# '


set -o errexit
#set -o nounset
set -o pipefail

args="$@"

# initial definitions
## select cipher suite
cipher_suite="gnupg"
#cipher_suite="openssl"

cgc_dir="$XDG_DATA_HOME/c/git/code"
source_dir="$cgc_dir/source/function"


sourcing()
{
    ## reply functions
    source $source_dir/reply_functions

    ## text appearance
    source $source_dir/text_appearance
}


initialize()
{
    ## initialization of (static) variables
    timestamp="$(date +'%Y%m%d_%H%M%S')"

    tmp_dir="$XDG_CACHE_HOME/temp/cryptr/$timestamp"
    [[ ! -d $tmp_dir ]] && mkdir -p $tmp_dir

    pw_dir="$PWD"

    src_arr=()
}


read_args_array()
{
    ## read elements non-accociative array $args_arr
    ## [SC2206 · koalaman/shellcheck Wiki · GitHub](https://github.com/koalaman/shellcheck/wiki/SC2206)

    ## create args_arr array
    IFS=" " read -r -a args_arr <<< "$args"

    args_arr_length="${#args_arr[@]}"
    last_element_index=$(( args_arr_length - 1 ))
}


evaluate_args()
{
    ## number of arguments
    case $args_arr_length in

	0|'')
	    ## no args
	    exit 14
	    ;;

	1)
	    ## single arg
	    evaluate_single_arg
	    ;;

	*)
	    ## multiple args
	    ### first get operation, because that determines which
	    ### arguments are sources and which is destination
	    evaluate_multiple_args
	    ;;

    esac

    deduct_dst
    autocreate_filename
}


evaluate_single_arg()
{
    arg="${args_arr[0]}"

    # check if single arg is filetype tarx
    check_if_tarx "$arg"

    if [[ -n $is_tarx ]]; then

	set_oper_decr

    else

	set_oper_encr

    fi

    src="$(realpath "$arg")"
    src_arr+=("$src")
    dst="$PWD"
}


evaluate_multiple_args()
{
    # j is element index of args_arr
    for (( j=0; j<=$last_element_index; j++ )); do
    #while (( j<=$args_array_length )); do list done

	arg="${args_arr["$j"]}"

	case $j in

	    0)
		# first argument -from multiple- (j = 0)

		check_if_option "$arg"

		## no explicit option is given
		if [[ -z "$oper" ]]; then

		    arg=$(realpath "$arg")
		    #arg=$(realpath "${args_arr["$j"]}")

		    ## first argument is no option
		    evaluate_single_arg

		fi
		;;

	    $last_element_index)
		# last argument -from multiple- (j = n)

		case $oper in

		    decr)
			arg=$(realpath "$arg")
			dst="$arg"
			[[ -d "$dst" ]] || dir_to_make="$dst"
			;;

		    encr)
			arg=$(realpath "$arg")
			if [[ -f "$arg" || -d "$arg" ]]; then

			    src="$arg"
			    src_arr+=("$src")

			elif [[ ! -f "$arg" && ! -d "$arg" ]]; then

			    dst="$arg"

			fi
			;;

		esac
		;;

	    *)
		# argument(s) between first and last (0 < j <= n)

		## these are always sources
		arg=$(realpath "$arg")
		src="$arg"
		src_arr+=("$src")
		;;

	esac

    done
}

: '
		#arg=$(realpath "${args_arr["$j"]}")
		if [[ ! -d "$(realpath "${args_arr["$j"]}")" ]]; then

		    dir_to_make="$(realpath "${args_arr["$j"]}")"
		    dst="$dir_to_make"
		    #mkdir -p "$dst"

		fi

		check_if_tarx "$arg"

		if [[ -n "$is_tarx" ]]; then
		    ## add to an existing tarx file
		    [[ -z "$dst" ]] && dst="$(realpath "$arg")"

		    set_oper_add

		elif [[ -f "$arg" ]]; then

		    src="$(realpath "$arg")"
		    src_arr+=("$src")

		    set_oper_encr

		elif [[ -d "$arg" ]]; then

		    #TODO directory can be src or dst
		    dst="$(realpath "$arg")"

		elif [[ ! -d "$arg" ]]; then

		    ## arg is non exixtend
		    ## presume it is a new dst directory
		    dst="$(realpath "$arg")"
		    #DEV TODO mkdir after info screen
		    #mkdir -p "$dst"

		fi

		deduct_oper
# '

get_args_arr_index()
{
    ## get current arg $args_arr index number
    for i in "$args_arr_length"; do

	if [[ "${args_arr[$i]}" == "${arg}" ]]; then

	    arg_index="${i}"

	    ## when having current args index
	    ## then stop iteration over !args_arr[@]
	    break

	fi

    done
}


check_if_tarx()
{
    unset is_tar
    unset is_tarx
    unset contains_crypt
    unset contains_csf

    location=$(realpath "$1")

    [[ -n "$(file -b "$location" | grep 'tar archive')" ]] && is_tar=1

    if [[ -z "$is_tar" ]]; then
	## no tar file

	return

    elif [[ -n "$is_tar" ]]; then
	## a tar file

	contains_crypt="$(tar -tvf "$location" | cut -d . -f 3- | grep 'crypt')"
	contains_csf="$(tar -tvf "$location" | cut -d . -f 3- | grep 'csf')"

	[[ -n "$contains_crypt" && -n "$contains_csf" ]] && is_tarx='1'

    fi
}


set_oper_decr()
{
    oper='decr'

    case $cipher_suite in

	gnupg)
	    opr='d'
	    ;;

	openssl)
	    opr='b'
	    ;;

    esac
}


set_oper_encr()
{
    oper='encr'

    case $cipher_suite in

	gnupg)
	    opr='e'
	    ;;

	openssl)
	    opr='c'
	    ;;

    esac
}


set_oper_add()
{
    ## adding to encrypted container
    # decrypt argn to tempdest
    # add arg1 - argn-1 to tempdest/temptar
    # encrypt tempdest/temptar to argn
    # remove tempdest/temptar
    add=1

    arg='-d'
    ## run operation again, now with arg -d
    check_if_option
}


deduct_dst()
{
    if [[ -z $dst ]]; then

	case $oper in

	    decr)
		## decrypt to a directory
		if [[ ! -f ${args_arr[-1]} ]]; then

		    dst=$(realpath ${args_arr[-1]})

		elif [[ -f ${args_arr[-1]} ]]; then

		    dst="$PWD"

		fi
		;;

	    encr)
		## encrypt to a file
		if [[ ! -f ${args_arr[-1]} ]]; then

		    dst=$(realpath ${args_arr[-1]})

		fi
		;;

	esac

    elif [[ -n $dst ]]; then

	## already have a destination
	return

    fi
    ###############
: '
    [if [[ -z $dst ]]; then

	case $oper in

	    decr)
		## decrypt to a directory
		last_arg="${args_arr[-1]}"

		[[ -d "$last_arg" ]] || mkdir -p "$last_arg"
		;;

	    encr)
		## encrypt to a file

	    ;;

	esac

	if [[ ! -f ${args_arr[-1]} ]]; then

	    if [[ ! -d ${args_arr[-1]} ]]; then

		mkdir -p "$(realpath ${args_arr[-1]})"

		dst=$(realpath ${args_arr[-1]})

	    fi

	elif [[ -f ${args_arr[-1]} ]]; then

	    dst="$PWD"

	fi

    elif [[ -n $dst ]]; then

	## already have a destination
	#DEV remove this if branch
	:

    fi
     # '
}


autocreate_filename()
{
    if [[ -d "$dst" ]]; then

	if [[ $oper == 'encr' ]]; then

	    ## autocreate filename
	    auto_tarx="$(basename ${src_arr[0]}.tarx)"
	    dst="${dst}/$auto_tarx"

	fi

    fi
}


deduct_oper()
{
    if [[ -z $oper ]]; then

	check_if_tarx "$arg"

	if [[ -n "$is_tarx" ]]; then
	    ## last argument is tarx file

	    if [[ $j == 0 ]]; then
		## first argument -from multiple- is tarx file
		## j from evaluate_multiple_args()

		## example: cryptr vault.tarx $HOME
		#TODO nested tarx files
		set_oper_decr
		## NOTICE $j <= 1 (not more than 2 args)
		## second arg is optional dst
		return

	    elif [[ $j == $last_element_index ]]; then
		## last argument -from multiple- is tarx file
		## j from evaluate_multiple_args()

		## example: cryptr s1 s2 vault.tarx
		set_oper_add
		return

	    fi

	elif [[ -z "$is_tarx" ]]; then

	    ## no other option than to encrypt
	    set_oper_encr
	    return

	fi

    fi
}


check_if_option()
{
    # determine option

    case "$arg" in

	-d|--decr|decr)
	    ## explicit decrypt
	    set_oper_decr
	    ;;

	-e|--encr|encr)
	    ## explicit encrypt
	    set_oper_encr
	    ;;

	-a|--add|add)
	    ## explicit add
	    set_oper_add
	    ;;

    esac
}


src_info()
{
    #declare -p src_arr
    printf "${st_bold}source"
    [[ "${#src_arr[@]}" -gt 1 ]] && printf 's'
    printf ":${st_def}\n"
    printf "\t\t%s\n" "${src_arr[@]}"
}


oper_info()
{
    ## user feedback
    printf "\n${st_bold}operation:${st_def}	${st_rev}${st_bold} %sypt ${st_def}\n\n" "$oper"
}


dst_info()
{
    if [[ -d $dst ]] || [[ -f $dst ]]; then

	printf "${st_bold}destination:${st_def}	$dst\n"

    else

	printf "${st_bold}destination:${st_def}	${fg_amber}$dst${st_def}\n"

    fi

    echo
}


show_info()
{
    src_info
    oper_info
    dst_info
}


: '
# collect_names

## source paths are elements in source array
all source elements "${src_arr[@]}"
number of elements "${#src_arr[@]}"
first element "${src_arr[0]}"
last element "${src_arr[-1]}"

## destination
path and filename "$dst"
directory "$dst_sub_dir"
filename "$dst_tar_get"
contains "$tar_src.crypt" and "$cipher_select_file"

## temporary directory
path "$tmp_dir"

## tar with source paths
plain "$tar_src" in "$tmp_dir"
definition in tar_append() tar_src=$tmp_dir/$dst_tar_get
encrypted "$tar_src.crypt" in "$dst"

## cipher select file
plain "$cipher_select_file" in "$dst"

## encryption
file_in="$tmp_dir/$tar_src"
file_out="$tmp_dir/${dst_tar_get}.crypt"
# '


tar_append()
{
    ## temporary (source) tar file
    ## will be encrypted and wrapped in tarx
    [[ -d $tmp_dir ]] || mkdir -p $tmp_dir
    tar_src=$tmp_dir/$(basename $dst)_src.tar

    for src_elem in "${src_arr[@]}"; do

	s_el_sub_dir=$(dirname $src_elem)
	s_el_tar_get=$(basename $src_elem)

	tar --append --file $tar_src --directory $s_el_sub_dir $s_el_tar_get

    done
}


select_cipher()
{
    case $cipher_suite in

	gnupg)

	    ## gnupg cipher select array
	    cipher_pool=$(\
			  gpg --version | \
			      grep -i -A 1 cipher | \
			      cut -d " " -f 2- | \
			      xargs | \
			      sed 's/ //'g | \
			      tr ',' '\n'\
		       )

	    cipher_select=( $(\
			      printf "$cipher_pool" | \
				  fzf -m \
				      --prompt='select gnupg cipher algorithm ' \
				      --height=12\
			    ) )

	    cipher_select_amount=${#cipher_select[@]}
	    ;;

	openssl)

	    ## openssl cipher select array
	    cipher_pool=$(\
			  openssl enc -ciphers | \
			      awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' | \
			      cut -c 2-\
		       )

	    cipher_select=( $(\
			      printf "$cipher_pool" | \
				  fzf -m \
				      --prompt='select openssl cipher algorithm ' \
				      --height=12\
			    ) )

	    cipher_select_amount=${#cipher_select[@]}
	    ;;

    esac
}


cipher_select_file()
{
    ## cipher select file (csf)
    cipher_select_file="$tmp_dir/$(basename $dst).csf"
    printf "%s\n" ${cipher_select[@]} > "$cipher_select_file"

    printf 'cipher:		%s\n' "$(tr '\n' ' ' < $cipher_select_file)($cipher_select_amount)"
}


running_rounds()
{
    ## execute encryption rounds
    round=1
    rounds=$cipher_select_amount

    printf '\n%sypting      ' "$oper"

    for cipher in ${cipher_select[@]}; do

	round_pass

	printf '%s' "$cipher "
	case $round in

	    1)

		case $rounds in

		    1)
			crypt_once
			;;

		    *)
			crypt_first
			;;

		esac
		;;

	    $rounds)

		crypt_last
		;;

	    *)

		crypt_next
		;;

	esac

	round=$(( $round + 1 ))

    done

    echo
}


crypt_first()
{
    ## first round of en- or decryption
    case $oper in

	encr)

	    ## define file_in
	    file_in="$tar_src"

	    ## define file_out
	    file_out=$tmp_dir/$(basename $file_in).$round
	    ;;

	decr)

	    ## define file_in
	    file_in=$crypt_file

	    ## define file_out
	    file_out=$tmp_dir/$(basename $file_in).$round
	    ;;

    esac

    crypt_exec
}


crypt_next()
{
    ## next round of en- or decryption
    case $oper in

	encr)

	    ## define file_in
	    file_in=$file_out

	    ## define file_out
	    ### remove previous round number extension from file_in
	    ### and replace it with current round number extension
	    round_pr=$(( round - 1 ))
	    file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/$round/"))
	    ;;

	decr)

	    ## define file_in
	    file_in=$file_out

	    ## define file_out
	    ### remove previous round number extension from file_out
	    ### and replace it with current round number extension
	    round_pr=$(( round - 1 ))
	    file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/$round/"))
	    ;;

    esac

    crypt_exec
}


crypt_last()
{
    ## last round of en- or decryption
    case $oper in

	encr)

	    file_in=$file_out

	    ## define file_out
	    ### remove previous round number extension from file_in
	    ### and replace it with 'crypt' extension
	    round_pr=$(( round - 1 ))
	    file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/crypt/"))
	    ;;

	decr)

	    ## define file_in
	    file_in=$file_out

	    ## define file_out
	    file_out=$dst.plain
	    ;;

    esac

    crypt_exec
}


crypt_once()
{
    ## only one round of en- or decryption
    ## using one algorithm and no cipher cascade
    case $oper in

	encr)

	    file_in="$tar_src"
	    file_out="$tmp_dir/$(basename $dst).crypt"
	    ;;

	decr)

	    file_in=$crypt_file

	    ## tar file
	    ## goes to tmp_dir staging destination
	    ## then extracting tar to dst (tar_extract())
	    file_out="${file_in}_temp.tar"
	    ;;

    esac

    crypt_exec
}


crypt_exec()
{
    case $cipher_suite in

	gnupg)

	    [[ $opr == 'e' ]] && gnupg_oper='symmetric'
	    [[ $opr == 'd' ]] && gnupg_oper='decrypt'

		#pass $pass_object | \
	        printf "$ropa" | \
	    	gpg \
		    --quiet \
	    	    --$gnupg_oper \
	    	    --armor \
	    	    --cipher-algo $cipher \
	    	    --pinentry-mode loopback \
	    	    --passphrase-fd 0 \
	    	    --batch \
	    	    --output $file_out \
	    	    $file_in
	    ;;

	openssl)

	    openssl enc \
		    -$oper \
		    -base64 \
		    -pbkdf2 \
		    -$cipher \
		    -salt \
		    -in $file_in \
		    -out $file_out \
		    -pass pass:`printf "$ropa"`
	    #-pass pass:`pass $pass_object`
	    ;;

    esac
}


tar_extract()
{
    ## extract tar archive
    case $add in

	'')
	    ## extraction to destination directory (dst)
	    tar --extract --file $file_out --directory $dst
	    ;;

	1)
	    ## extraction to temporary directory (tmp_dir)
	    tar --extract --file $file_out --directory $tmp_dir

	    ## move updated tmp_dir to src
	    back_to_source
	    ;;

    esac
}


back_to_source()
{
    ## adding new files to temporary directory
    for src_elem in "${src_arr[@]}"; do

	## src (.tarx) is last element and included in src_arr, filter it out
	if [[ "$src_elem" != "$(realpath ${args_arr[-1]})" ]]; then

    	    rsync -aAXv $src_elem $tmp_dir

	fi

    done

    ## remove cryptr system files from temporary directory
    #rm -rf "${tmp_dir}/$(basename "${src/%.tarx/}")".csf
    #rm -rf "${tmp_dir}/$(basename "${src/%.tarx/}")".crypt
    #rm -rf "${tmp_dir}/$(basename "${src/%.tarx/}")".crypt_temp.tar
    rm -rf "${tmp_dir}"/*.crypt
    rm -rf "${tmp_dir}"/*.crypt_temp.tar
    rm -rf "${tmp_dir}"/*.csf


    ## encrypt temporary directory back to src
    ## remove add status
    add=''

    ## remove crypto source so it can be rewritten
    rm -rf $src

    ## rewrite crypto source
    cryptr -e $tmp_dir/* $src

    ## remove temporary directory
    command rm -rf $tmp_dir
}


tarx_define()
{
    ## create tar box (tarx)
    tarx_file=$dst

    file_out=$(realpath $file_out)
    sub_dir_fo=$(dirname $file_out)

    cipher_select_file=$(realpath $cipher_select_file)
    sub_dir_csf=$(dirname $cipher_select_file)
}


tarx_check()
{
    # check if tarx exists
    ## gpg fails on existence
    ## openssl overwrites without check

    [[ -f $tarx_file ]] && tarx_exist=1

    case $oper in

	encr)

	    if [[ "$tarx_exist" == "1" ]]; then

		printf "\ntarx file:	${YELLOW}%s${NOC} exists\n" "$tarx_file"
		printf '                overwrite? (y/N) '
		reply_single

		case $reply in

		    y)
			echo
			printf 'please confirm? (y/N) '
			reply_single

			case $reply in

			    y)
				echo
				;;

			    *)
				echo
				printf "${MAGENTA}encryption aborted${NOC}\n"
				exit 34
				;;

			esac
			;;

		    *)
			echo
			printf "${MAGENTA}encryption aborted${NOC}\n"
			exit 34
			;;

		esac


	    fi
	    ;;

	decr)

	    # src does exist (src_validate)
	    if [[ -n "$(file -b $src | grep 'tar archive')" ]]; then

		## src is a tar file with tarx extension
		src_file_type='tar_archive'

	    fi
	    ;;

    esac
}


tarx_create()
{
    ## create tar archive
    ## with encrypted file
    tar --create --file $tarx_file --directory $sub_dir_fo $(basename $file_out)
    ## append cipher select file
    tar --append --file $tarx_file --directory $sub_dir_csf $(basename $cipher_select_file)
}


tarx_open()
{
    ## extract tar box contents
    ## 2 files; .crypt & .src
    mkdir -p $tmp_dir
    tar --extract --file $src --directory $tmp_dir
}


get_crypto_data()
{
    ## a tarx file always contains only 2 files;
    ## the cipher select file (csf) and
    ## the encrypted (tar) file
    ## so we can use the '! -name' construct

    ## find encrypted (tar) file
    crypt_file=$(find $tmp_dir -type f ! -name "*.csf")

    ## find cypher select file
    cipher_select_file=$(find $tmp_dir -name "*.csf")

    ## get cypher select details
    cipher_select=($(tac $cipher_select_file))
    cipher_select_amount=${#cipher_select[@]}
}


round_pass()
{
    ## sha3-512 hash for every round
    ## every round has an unique round password (ropa)
    case $oper in

	encr)

	    ropa_round=$round
	    ;;

	decr)

	    ## invert round counter to match encr
	    ropa_round=$(( $rounds + 1 - $round ))
	    ;;

    esac

    ropa_string=$(printf '%s' "$ro_pass$cipher_suite$cipher$ropa_round")

    case $cipher_suite in

	gnupg)
	    ropa=$(\
		   printf '%s' "$ropa_string" | \
		       gpg --print-md sha3-512 | \
		       sed 's/ //'g | \
		       tr '[:upper:]' '[:lower:]'\
		)
	    ;;

	openssl)
	    ropa=$(\
		   printf '%s' "$ropa_string" | \
		       openssl dgst -sha3-512 | \
		       sed 's/^.*= //'\
		)
	    ;;

    esac
}


get_pass()
{
    ## enter passphrase
    read -s -p "passphr:	" ro_pass
    echo

    case $oper in

	encr)
	    # verifiy pass
	    ro_pass_sha3512=$(printf '%s' "$ro_pass" | gpg --print-md sha3-512)
	    read -s -p 'verify:		' ro_pass
	    echo

	    ro_pass_verify="$(printf '%s' "$ro_pass" | gpg --print-md sha3-512)"

	    if [[ "$ro_pass_sha3512" == "$ro_pass_verify" ]]; then

		a=0

	    else

		printf "${MAGENTA}%s${NOC}\n" 'pass verification failed'
		exit 1

	    fi
	    ;;

    esac
}


tar_destroy()
{
    # command prevnts using aliases
    command rm -rf "$(dirname "$tmp_dir")"
}


cleanup()
{
    case $oper in

	encr)

	    tar_destroy
	    ;;

	decr)

	    [[ "$add" == '1' ]] || tar_destroy
	    ;;

    esac
}


encrypt()
{
    select_cipher
    cipher_select_file
    get_pass
    running_rounds
    tarx_define
    tarx_check
    tarx_create
}


decrypt()
{
    tarx_check
    tarx_open
    get_crypto_data
    get_pass
    running_rounds
}


print_entire_array()
{
    declare -n array_name="$1"

    for k in "${!array_namep[@]}"; do

	printf "%s=%s\n" "$k" "${array_name[$k]}"

    done
}


debug_info()
{
    printf '=========================================\n'
    printf "DEBUG "
    declare -p args_arr

    printf '=========================================\n'
    printf "DEBUG "
    declare -p src_arr

    printf '=========================================\n'
    printf "DEBUG oper: $oper\n"

    printf '=========================================\n'
    printf "DEBUG dst: $dst\n"
    printf '=========================================\n'
}


main()
{
    sourcing
    initialize

    read_args_array
    evaluate_args

    show_info

    case $oper in

	encr)

	    tar_append
	    encrypt
	    cleanup
	    ;;

	decr)

	    decrypt
	    tar_extract
	    cleanup
	    ;;

    esac

    debug_info
}

main
