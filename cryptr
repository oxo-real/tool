#!/bin/bash
#
##
### usage: enc_bu -e <source> <destination>
### usage: enc_bu -d <source> <destination>
###
###
### -e creates a tar box (tarx) file
### -d decrypts a tarx file
#

#cipher_suite="gnupg"
cipher_suite="openssl"

args="$@"


initialize()
{
	timestamp="`date "+%Y%m%d_%H%M%S"`"

	tmp_dir="$XDG_CACHE_HOME/temp/cryptr/$timestamp"
	[[ ! -d $tmp_dir ]] && mkdir -p $tmp_dir

	pw_dir="$PWD"
}


arguments()
{
	opr=$(printf -- "$args" | awk '{print $1}')
	src=$(printf -- "$args" | awk '{print $2}')
	dst=$(printf -- "$args" | awk '{print $3}')

	operation
	src_validate
	dst_validate
}


operation()
{
	# encrypt or decrypt
	case $opr in

		-e)

			case $cipher_suite in

				gnupg)

					# encrypt with symmetric cipher
					opr="c"
					;;

				openssl)

					opr="e"
					;;

			esac
			oper="encr"
			;;

		-d)

			opr="d"
			oper="decr"
			;;

	esac
}


src_validate()
{
	# rewrite src full path
	src="$(realpath $src)"

	# src does not exist
	if [[ ! -f $src ]]; then

		printf "${RED}source file not found${NOC}\n"
		exit 5

	elif [[ -z $src ]]; then

		printf "${RED}missing src & dest file${NOC}\n"
		exit 5

	fi

	case $oper in

		encr)

			src_sub_dir=$(dirname $src)
			src_tar_get=$(basename $src)
			;;

		decr)

			#[DEV]
			dev_txt="src limitations here"

			;;

	esac
}


dst_validate()
{
	# dst file or directory already exists
	if [[ -f $dst ]] || [[ -d $dst ]]; then

		printf "${RED}destination file or directory already exists${NOC}\n"
		exit 4

	fi




	case $oper in

		encr)

			#[DEV]
			dev_txt="dst encr limitations here"

			# dst is empty
			if [[ -z $dst  ]]; then

				dst="$pw_dir"

			fi

			;;

		decr)

			#[DEV]
			dev_txt="dst decr limitations here"

			# dst is empty
			if [[ -z $dst  ]]; then

				dst="$pw_dir"
				#[TODO] dst must be filename!
			fi

			;;

	esac
	# rewrite dst full path
	dst="$(realpath $dst)"

}


tar_create()
{
	tar_file=$tmp_dir/$src_tar_get.tar
	#tar_file=$tmp_dir/$(printf "$src" | cut -c 2-).tar

	mkdir -p $(dirname $tar_file)

	# create tar archive
	tar -czf $tar_file -C $src_sub_dir $src_tar_get
}


cipher_select()
{
	case $cipher_suite in

		openssl)

			# openssl cipher select array
			cipher_pool=$(\
				openssl enc -ciphers | \
				awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' | \
				cut -c 2-\
			)

			cipher_select=( $(\
				printf "$cipher_pool" | \
				fzf -m\
			) )

			cipher_select_amount=${#cipher_select[@]}
			;;

		gnupg)

			# gnupg cipher select array
			cipher_pool=$(\
				gpg --version | \
				grep -i -A 1 cipher | \
				cut -d " " -f 2- | \
				xargs | \
				sed 's/ //'g | \
				tr ',' '\n'\
			)

			#cipher_select=$(printf "$cipher_pool" | fzf -m)
			cipher_select=( $(\
				printf "$cipher_pool" | \
				fzf -m\
			) )

			cipher_select_amount=${#cipher_select[@]}
			;;

	esac
}


cipher_select_file()
{
	#[TODO] temp file remove afterwards
	cipher_select_file="$src.csf"
	printf "%s\n" ${cipher_select[@]} > "$cipher_select_file"
}


running_rounds()
{
	round=1
	rounds=$cipher_select_amount

	for cipher in ${cipher_select[@]}; do

		printf "$cipher $round($rounds)\n"

		case $round in

			1)

				case $rounds in

					1)
						crypt_once
						;;

					*)
						crypt_first
						;;

				esac
				;;

			$rounds)

				crypt_last
				;;

			*)

				crypt_next
				;;

		esac

		round=$(( $round + 1 ))

	done
}


crypt_first()
{
	# first round en- or decryption

	case $oper in

		encr)

			file_in=$tar_file
			;;

		decr)

			file_in=$crypt_file
			;;

	esac

	file_out=$tmp_dir/$(basename $file_in).$round

	crypt_now
}


crypt_next()
{
	# next round en- or decryption

	case $oper in

		encr)

			file_in=$file_out

			# remove previous round extension from file_in
			round_pr=$(( round - 1 ))
			file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/$round/"))
			;;

		decr)

			file_in=$crypt_file
			;;

	esac

	crypt_now
}


crypt_last()
{
	# last round en- or decryption
	case $oper in

		decr)

			file_in="$file_out"
			file_out="$dst"
			;;

		encr)

			## define file_out
			file_out="$src.crypt"
			;;

	esac

	crypt_now
}


crypt_once()
{
	# only round en- or decryption
	case $oper in

		encr)

			file_in=$tar_file
			file_out=$src.crypt
			;;

		decr)

			file_in=$crypt_file
			file_out=$dst
			;;

	esac

	crypt_now
}


encrypt()
{
	cipher_select
	cipher_select_file
	running_rounds
	tarx_create
	cleanup
}


decrypt()
{
	tarx_check
	tarx_open
	get_crypto_data
	running_rounds
}


crypt_now()
{
	case $cipher_suite in

		openssl)

			openssl enc \
				-$opr \
				-base64 \
				-$cipher \
				-salt \
				-pbkdf2 \
				-pass pass:$pd \
				-in $file_in \
				-out $file_out
			;;

		gnupg)

			printf "$pd" | \
			gpg \
				-$opr \
				--armor \
				--cipher-algo $cipher \
				--pinentry-mode loopback \
				--passphrase-fd 0 \
				--batch \
				--output $file_out \
				$file_in
				#--sign \
			;;

	esac
}


tar_extract()
{
	# extract tar archive
	tar -xvf $tmp_dir
}


tar_destroy()
{
	tmp_dir_del=$(printf $tmp_dir | cut -d / -f -6)
	rm -rf $tmp_dir_del
}


get_password()
{
	#[TODO] DEV
	pd='123'
}


tarx_create()
{
	# create tar box (tarx)
	tar_file=$dst/$(basename $src).tarx

	sub_dir=$(dirname $src)
	#sub_dir=$(dirname $file_out)

	file_out="$(basename $file_out)"
	cipher_select_file="$(basename $cipher_select_file)"

	# create tar archive
	tar -cf $tar_file $file_out
	#tar -cf $tar_file -C $sub_dir $file_out
	tar -rf $tar_file $cipher_select_file
	#tar -rf $tar_file -C $sub_dir $cipher_select_file
}


tarx_check()
{
	if [[ -n $(printf "$src" | grep '.tarx$') ]]; then

		if [[ -n $(file -b $src | grep 'tar archive') ]]; then

			# src is a tar file with tarx extension
			#tarx_open
			continue

		fi

	fi
}


tarx_open()
{
	# extract crypto box contents (2 files)
	mkdir -p $tmp_dir
	tar -xvf $src -C $tmp_dir
}


get_crypto_data()
{
	# a tarx file always contains only 2 files;
	# the cipher select file (csf) and
	# the encrypted (tar) file
	# so we can use the '! -name' construct

	# find encrypted (tar) file
	crypt_file=$(find $tmp_dir -type f ! -name "*.csf")

	# find cypher select file
	cipher_select_file=$(find $tmp_dir -name "*.csf")

	# get cypher select details
	cipher_select=($(tac $cipher_select_file))
	cipher_select_amount=${#cipher_select[@]}
}


cleanup()
{
	case $oper in

		encr)

			tar_destroy
			rm -rf $file_out
			rm -rf $cipher_select_file

			;;

		decr)

			#[TODO] destroy_opened_tarx
			;;

	esac
}


main()
{
	initialize
	arguments
	get_password

	case $oper in

		encr)

			tar_create
			encrypt
			;;

		decr)

			decrypt
			tar_extract
			;;

	esac
}

main
