#!/bin/bash
#
##
### usage: enc_bu -e <source> <destination>
### usage: enc_bu -d <source> <destination>
###
###
#

args="$@"
opr=$1
src=$(realpath "$2")
dst=$(realpath "$3")
# box	 = dst.crx file
#		!= dst openssl enc file_out

timestamp="`date "+%Y%m%d_%H%M%S"`"

cipher_list=$(\
	openssl enc -ciphers | \
	awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' \
	)

tmp_dir="$XDG_CACHE_HOME/temp/cryptrTEMP/$timestamp"
[[ ! -d $tmp_dir ]] && mkdir -p $tmp_dir

pw_dir="$PWD"


oper()
{
	# operation: encrypt or decrypt
	if [[ $opr == "-e" ]]; then

		opr="e"
		oper="encr"

	elif [[ $opr == "-d" ]]; then

		opr="d"
		oper="decr"

	fi
}


source_type()
{
	# source is file or directory
	# (only for oper = encr)
	if [[ -f $src ]]; then

		source_type='file'

	elif [[ -d $src ]]; then

		source_type='dir'

	fi
}


create_tar()
{
	# remove the first / from src to prevent // in tar_file
	tar_file=$tmp_dir/$(printf "$src" | cut -c 2-).tar
	mkdir -p $(dirname $tar_file)
	src_sub_dir=$(dirname $src)
	src_tar_get=$(basename $src)

	#[DEV]
	printf ">>> src_sub_dir	$src_sub_dir\n"
	printf ">>> src_tar_get	$src_tar_get\n"

	# create tar archive
	tar -czf $tar_file -C $src_sub_dir $src_tar_get
}


select_ciphers()
{
	# cipher pool array
	cipher_pool=($(\
		openssl enc -ciphers | \
		awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' | \
		cut -c 2- | \
		fzf -m \
		))
	cipher_pool_amount=${#cipher_pool[@]}
}


create_cipher_pool_file()
{
	#[TODO] temp file remove afterwards
	cipher_pool_file="$src.cpf"
	printf "%s\n" ${cipher_pool[@]} > "$cipher_pool_file"
}


running_rounds()
{
	round=1
	rounds=$cipher_pool_amount

	for cipher in ${cipher_pool[@]}; do

		printf "$round($rounds) $cipher\n"

		case $round in

			1)
				case $rounds in

					1)
						encrypt_once
						;;

					*)
						encrypt_first
						;;

				esac
				;;

			$rounds )
				encrypt_last
				;;

			*)
				encrypt_next
				;;

		esac

		round=$(( $round + 1 ))

	done
}


encrypt_first()
{
	# first encryption round

	## define file_in
	if [[ $source_type == "file" ]]; then

		file_in="$src"

	elif [[ $source_type == "dir" ]]; then

		file_in="$tar_file"

	fi

	## define file_out
	file_out=$tmp_dir/$(basename $file_in).$round

	## encrypt
	openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in -out $file_out -pass pass:$pd
}


encrypt_next()
{
	# next encryption round

	## define file_in
	file_in="$file_out"

	## define file_out
	file_out=$tmp_dir/$(basename $file_in).$round

	# next ecryption round
	openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in -out $file_out -pass pass:$pd
}


encrypt_last()
{
	## define file_out
	file_out="$src.crypt"

	# last encryption round
	openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in -out $file_out -pass pass:$pd
}


encrypt_once()
{
	case $oper in

		encr)


			## define file_in
			case $source_type in

				file)

					file_in=$src
					;;

				dir)

					file_in=$tar_file
					;;

			esac


			## define openssl enc file_out
			file_out=$src.crypt

			;;

		decr)

			## define file_in
			file_in=$crypt_file

			## define out
			file_out=$dst

			;;

	esac

	openssl_enc
}


encrypt()
{
	# dst is location of the crx file
	[[ -z $dst ]] && dst="$pw_dir"
	[[ -d $dst ]] || printf "${RED}destination directory not found${NOC}\n"

	select_ciphers
	create_cipher_pool_file
	running_rounds
	create_box
	cleanup
}


decrypt()
{
	if [[ ! -f $src ]]; then
		printf "${RED}cryptr error: source file not found${NOC}\n" && exit 217
	elif [[ -z $src ]]; then
		printf "${RED}cryptr error: missing src & dest file${NOC}\n" && exit 217
	fi

	if [[ -f $dst ]]; then
		printf "${RED}cryptr error: destination file already exists${NOC}\n" && exit 217
	fi
	if [[ -d $dst ]]; then
		printf "${RED}cryptr error: destination directory already exists${NOC}\n" && exit 217
	fi

	[[ -z $dst ]] && dst="$pw_dir"
	[[ -d $(dirname $dst) ]] || mkdir -p $(dirname $dst)

	check_if_box
	open_box
	get_crypto_data
	running_rounds
}


openssl_enc()
{
	case $oper in

		encr)
			openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in \
				-out $file_out -pass pass:$pd
			;;

		decr)
			openssl enc -$opr -base64 -$cipher -salt -pbkdf2 -in $file_in \
				-pass pass:$pd
			;;

	esac

}


extract_tar()
{
	# extract tar archive
	tar -xvf $tmp_dir
}


destroy_tar()
{
	tmp_dir_del=$(printf $tmp_dir | cut -d / -f -6)
	rm -rf $tmp_dir_del
}


get_password()
{
	#[TODO] DEV
	pd="1"
}


create_box()
{
	# create crypto box (crx)
	tar_file=$dst/$(basename $src).crx

	sub_dir=$(dirname $file_out)

	# create tar archive
	tar -czf $tar_file -C $sub_dir $file_out
	tar -rzf $tar_file -C $sub_dir $cipher_pool_file
}


check_if_box()
{
	if [[ -n $(printf "$src" | grep '.box$') ]]; then

		if [[ -n $(file -b $src | grep 'tar archive') ]]; then

			# src is a tar file with box extension
			#open_box
			continue

		fi

	fi
}


open_box()
{
	# extract box contents (2 files)
	mkdir -p $tmp_dir
	tar -xvf $src -C $tmp_dir
}


get_crypto_data()
{
	# a box file always contains only 2 files;
	# the crypto pool file (cpf) and
	# the encrypted (tar) file
	# so we can use the '! -name' construct

	# find encrypted (tar) file
	crypt_file=$(find $tmp_dir -type f ! -name "*.cpf")

	# find cypher pool file
	cipher_pool_file=$(find $tmp_dir -name "*.cpf")

	# get cypher pool details
	cipher_pool=($(tac $cipher_pool_file))
	cipher_pool_amount=${#cipher_pool_file[@]}
}


cleanup()
{
	case $oper in

		encr)
			destroy_tar
			rm -rf $files
			rm -rf $tmp_dir
			;;

		decr)
			#[TODO] destroy_opened_box
			;;

	esac
}


main()
{
	oper
	get_password

	case $oper in

		encr)

			source_type

			case $source_type in

				file)

					encrypt
					;;

				dir)
					create_tar
					encrypt
					;;

			esac
			;;

		decr)

			decrypt
			extract_tar
			;;

	esac
}

main
