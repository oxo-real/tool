#!/bin/bash
#
##
###                        _
###   ___ _ __ _   _ _ __ | |_ _ __
###  / __| '__| | | | '_ \| __| '__|
### | (__| |  | |_| | |_) | |_| |
###  \___|_|   \__, | .__/ \__|_|
###            |___/|_|
###
### crypto with multiple algorythms
###
### (c) 2021 cytopyge
###
### usage:
### -e encrypt a tarx file
### cryptr -e <source> [destination]
###
### -d decrypt a tarx file
### cryptr -d <source> [destination]
###
##
#


## select cipher suite
cipher_suite="gnupg"
#cipher_suite="openssl"


args="$@"


initialize()
{
	timestamp="`date "+%Y%m%d_%H%M%S"`"

	tmp_dir="$XDG_CACHE_HOME/temp/cryptr/$timestamp"
	[[ ! -d $tmp_dir ]] && mkdir -p $tmp_dir

	pw_dir="$PWD"
}


arguments()
{
	opr=$(printf -- "$args" | awk '{print $1}')
	src=$(printf -- "$args" | awk '{print $2}')
	dst=$(printf -- "$args" | awk '{print $3}')

	operation
	src_validate
	dst_validate
}


operation()
{
	## encrypt or decrypt
	case $opr in

		-e)

			case $cipher_suite in

				gnupg)

					## encrypt with symmetric cipher
					opr="c"
					;;

				openssl)

					opr="e"
					;;

			esac
			oper="encr"
			;;

		-d)

			opr="d"
			oper="decr"
			;;

	esac
}


src_validate()
{
	## rewrite src full path
	src="$(realpath $src)"

	## src does not exist
	if [[ ! -f $src ]]; then

		printf "${RED}source file not found${NOC}\n"
		exit 5

	elif [[ -z $src ]]; then

		printf "${RED}missing src & dest file${NOC}\n"
		exit 5

	fi

	case $oper in

		encr)

			src_sub_dir=$(dirname $src)
			src_tar_get=$(basename $src)
			;;

		decr)

			src_txt="no src limitations for decr"
			;;

	esac
}


dst_validate()
{
	## dst file or directory already exists
	if [[ -f $dst ]] || [[ -d $dst ]]; then

		printf "${RED}destination file or directory already exists${NOC}\n"
		exit 4

	fi

	case $oper in

		encr)

			## dst is empty
			if [[ -z $dst  ]]; then

				dst="$pw_dir"

			fi
			;;

		decr)

			## dst is empty
			if [[ -z $dst  ]]; then

				dst="$pw_dir"

			fi

			dst_file_name=$(basename $src)
			;;

	esac

	## rewrite dst full path
	dst="$(realpath $dst)"
}


tar_create()
{
	tar_file=$tmp_dir/$src_tar_get.tar
	mkdir -p $(dirname $tar_file)

	## create tar archive
	tar -czf $tar_file -C $src_sub_dir $src_tar_get
}


cipher_select()
{
	case $cipher_suite in

		gnupg)

			## gnupg cipher select array
			cipher_pool=$(\
				gpg --version | \
				grep -i -A 1 cipher | \
				cut -d " " -f 2- | \
				xargs | \
				sed 's/ //'g | \
				tr ',' '\n'\
			)

			cipher_select=( $(\
				printf "$cipher_pool" | \
				fzf -m\
			) )

			cipher_select_amount=${#cipher_select[@]}
			;;

		openssl)

			## openssl cipher select array
			cipher_pool=$(\
				openssl enc -ciphers | \
				awk 'NR > 1 {for(i=1;i<=NF;i++){print $i}}' | \
				cut -c 2-\
			)

			cipher_select=( $(\
				printf "$cipher_pool" | \
				fzf -m\
			) )

			cipher_select_amount=${#cipher_select[@]}
			;;

	esac
}


cipher_select_file()
{
	cipher_select_file="$tmp_dir/$(basename $src).csf"
	printf "%s\n" ${cipher_select[@]} > "$cipher_select_file"
}


running_rounds()
{
	round=1
	rounds=$cipher_select_amount

	for cipher in ${cipher_select[@]}; do

		printf "$cipher $round($rounds)\n"

		case $round in

			1)

				case $rounds in

					1)
						crypt_once
						;;

					*)
						crypt_first
						;;

				esac
				;;

			$rounds)

				crypt_last
				;;

			*)

				crypt_next
				;;

		esac

		round=$(( $round + 1 ))

	done
}


crypt_first()
{
	## first round of en- or decryption
	case $oper in

		encr)

			## define file_in
			file_in=$tar_file

			## define file_out
			file_out=$tmp_dir/$(basename $file_in).$round
			;;

		decr)

			## define file_in
			file_in=$crypt_file

			## define file_out
			file_out=$tmp_dir/$(basename $file_in).$round
			;;

	esac

	crypt_now
}


crypt_next()
{
	## next round of en- or decryption
	case $oper in

		encr)

			## define file_in
			file_in=$file_out

			## define file_out
			### remove previous round number extension from file_in
			### and replace it with current round number extension
			round_pr=$(( round - 1 ))
			file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/$round/"))
			;;

		decr)

			## define file_in
			file_in=$file_out

			## define file_out
			### remove previous round number extension from file_out
			### and replace it with current round number extension
			round_pr=$(( round - 1 ))
			file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/$round/"))
			;;

	esac

	crypt_now
}


crypt_last()
{
	## last round of en- or decryption
	case $oper in

		encr)

			file_in=$file_out

			## define file_out
			### remove previous round number extension from file_in
			### and replace it with 'crypt' extension
			round_pr=$(( round - 1 ))
			file_out=$tmp_dir/$(basename $(printf $file_in | sed "s/$round_pr$/crypt/"))
			;;

		decr)

			## define file_in
			file_in=$file_out

			## define file_out
			file_out=$dst_file_name.plain
			;;

	esac

	crypt_now
}


crypt_once()
{
	## only one round of en- or decryption
	case $oper in

		encr)

			file_in=$tar_file
			file_out=$src.crypt
			;;

		decr)

			file_in=$crypt_file
			file_out=$dst_file_name.plain
			;;

	esac

	crypt_now
}


crypt_now()
{
	case $cipher_suite in

		gnupg)

			printf "$pd" | \
			gpg \
				-$opr \
				--armor \
				--cipher-algo $cipher \
				--pinentry-mode loopback \
				--passphrase-fd 0 \
				--batch \
				--output $file_out \
				$file_in
				#--sign \
			;;

		openssl)

			openssl enc \
				-$opr \
				-base64 \
				-$cipher \
				-salt \
				-pbkdf2 \
				-pass pass:$pd \
				-in $file_in \
				-out $file_out
			;;

	esac
}


tar_extract()
{
	## extract tar archive
	tar -xvf $file_out
	## remove tarx.plain
	\rm -rf $file_out
}


tar_destroy()
{
	tmp_dir_del=$(printf $tmp_dir | cut -d / -f -6)
	\rm -rf $tmp_dir_del
}


get_password()
{
	##[TODO] DEV
	pd='123'
}


tarx_create()
{
	## create tar box (tarx)
	tar_file=$dst/$(basename $src).tarx

	file_out=$(realpath $file_out)
	sub_dir_fo=$(dirname $file_out)

	cipher_select_file=$(realpath $cipher_select_file)
	sub_dir_csf=$(dirname $cipher_select_file)

	## create tar archive
	tar -cf $tar_file -C $sub_dir_fo $(basename $file_out)
	tar -rf $tar_file -C $sub_dir_csf $(basename $cipher_select_file)
}


tarx_check()
{
	if [[ -n $(printf "$src" | grep '.tarx$') ]]; then

		if [[ -n $(file -b $src | grep 'tar archive') ]]; then

			## src is a tar file with tarx extension
			dev_txt="tarx file is tar archive"

		fi

	else

		printf "${RED}no valid tar crypto box (.tarx) file found${NOC}\n"
		exit

	fi
}


tarx_open()
{
	## extract tar box contents (2 files)
	mkdir -p $tmp_dir
	tar -xvf $src -C $tmp_dir
}


get_crypto_data()
{
	## a tarx file always contains only 2 files;
	## the cipher select file (csf) and
	## the encrypted (tar) file
	## so we can use the '! -name' construct

	## find encrypted (tar) file
	crypt_file=$(find $tmp_dir -type f ! -name "*.csf")

	## find cypher select file
	cipher_select_file=$(find $tmp_dir -name "*.csf")

	## get cypher select details
	cipher_select=($(tac $cipher_select_file))
	cipher_select_amount=${#cipher_select[@]}
}


cleanup()
{
	case $oper in

		encr)

			tar_destroy
			\rm -rf $file_out
			\rm -rf $cipher_select_file
			;;

		decr)

			tar_destroy
			#\rm -rf $file_out
			\rm -rf $cipher_select_file
			;;

	esac
}


encrypt()
{
	cipher_select
	cipher_select_file
	running_rounds
	tarx_create
	cleanup
}


decrypt()
{
	tarx_check
	tarx_open
	get_crypto_data
	running_rounds
	cleanup
}


main()
{
	initialize
	arguments
	get_password

	case $oper in

		encr)

			tar_create
			encrypt
			;;

		decr)

			decrypt
			tar_extract
			;;

	esac
}

main
