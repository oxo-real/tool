#! /usr/bin/env sh

###                   _
###  _ __   _____   _(_) ___  ___
### | '_ \ / _ \ \ / / |/ _ \/ __|
### | | | | (_) \ V /| |  __/\__ \
### |_| |_|\___/ \_/ |_|\___||___/
###
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
novies
nine bits decimal grid clock
copyright (c) 2024  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
zsh (probably)

# requirements


# usage
novies [options] [value]

# examples
% novies --gray --vertical --tty
#TODO options

# '


set -o errexit
#set -o nounset
set -o pipefail

# script specific constants
## script_metadata
script_dir="$XDG_DATA_HOME/c/git/code/tool"
script_name='novies'
developer='oxo'
license='gplv3'
initial_release_year=2024


args=$@
tmp="$XDG_CACHE_HOME/temp"
novies_config_dir="$XDG_CONFIG_HOME/novies" ## #TODO config file


#grid_orientation=horizontal
grid_orientation=vertical


#pattern_method=pile-741852963  ## vertical
#pattern_method=pile-789456123  ## horizontal
#pattern_method=sym_v
#pattern_method=sym_h
pattern_method=random


row_height=22
font_size=11
shape_on='▄'
shape_off='.'
#shape_off=' '
# ◼◻ ■□ ●○
spacing_x=0
spacing_y=0
opacity=0.0
alignment=40  ## #TODO does not align
grid_rows=3
grid_columns=3
column_width=88
con_width_corr=0


declare -A grid
declare -A colored_grid
declare -A decimal_bit_pattern

## set on off colors for decimal light units
declare -A color_grid
## color_grid[decimal_no]=color_code
## off color
color_grid[0]=37
#color_grid[0]=#ff73fd
## on color
color_grid[1]=31
color_grid[2]=31
color_grid[3]=32
color_grid[4]=32
color_grid[5]=34
color_grid[6]=34

## set refresh periods for decimals
main_refresh_period=1
declare -A refresh_period_grid
## refresh_period_grid[decimal_no]=seconds
refresh_period_grid[1]=60
refresh_period_grid[2]=60
refresh_period_grid[3]=15
refresh_period_grid[4]=15
refresh_period_grid[5]=3
refresh_period_grid[6]=1

## initialize last_update_ts_grid
declare -A last_update_ts_grid
## last_update_ts_grid[decimal_no]=seconds
last_update_ts_grid[1]=0
last_update_ts_grid[2]=0
last_update_ts_grid[3]=0
last_update_ts_grid[4]=0
last_update_ts_grid[5]=0
last_update_ts_grid[6]=0


function get_args ()
{
    #TODO
    :
}


function get_timestamp ()
{
    ## in epoch
    ## out ts_epoch
    ## out ts_hms
    ## out ts_hour
    ## out ts_minute
    ## out ts_second

    ts_epoch=$(date +'%s')
    ts_hms=$(date -d @"$ts_epoch" +'%H%M%S')

    ## ts values without leading zeros
    ts_hour=$(date -d @"$ts_epoch" +'%-H')
    ts_minute=$(date -d @"$ts_epoch" +'%-M')
    ts_second=$(date -d @"$ts_epoch" +'%-S')
}


function get_time_fold ()
{
    ## in
    ## out time_fold
    ## out decimals

    #[[ -n $1 ]] && ts_hms=$1

    ## time fold places every decimal of ts_hms on a newline
    ## so we can loop through with a here string
    time_fold=$(printf '%s' "$ts_hms" | fold -w 1)

    ## number of decimals will become the number of grids
    decimals=$(printf '%s' "$ts_hms" | wc -c)
}


function grid_create ()
{
    ## in decimal_no
    ## in time_fold
    ## out grid_data
    ## out grid_to_array
    ## out grid_decorate

    ## #looping through every decimal_no to create grid_data and decorate

    ## reset decimal number
    decimal_no=0

    if [[ -n $mode ]]; then

	for (( i=1; i<=$decimals; i++ )); do

    	## next decimal
    	(( decimal_no+=1 ))

    	grid_decorate

	done

    else

	## loop through every decimal in time_fold (decimal_value)
	while IFS= read -r decimal_value; do

	    ## next decimal
	    (( decimal_no+=1 ))

	    ## get last update epoch for current grid (lueg)
	    lueg=${last_update_ts_grid[$decimal_no]}

	    ## no leading zeros in lueg values
	    lueg_hour=$(date -d @"$lueg" +'%-H')
	    lueg_minute=$(date -d @"$lueg" +'%-M')

	    ## get refresh period for current grid (rpg)
	    rpg=${refresh_period_grid[$decimal_no]}

	    ## refresh current nine bits decimal grid, only
	    ## if last update is longer ago than threshold, or
	    if [[ $(( ts_epoch - lueg )) -ge $rpg ]] || \
		   ## if ts_epoch minute differs from lueg minutes
		   [[ $ts_minute -ne $lueg_minute ]] || \
		       ## if ts_epoch hour differs from lueg hour, or
		   [[ $ts_hour -ne $lueg_hour ]]; then

		set_decimal_bit_pattern
		#grid_data
		#DELgrid_to_array
		grid_decorate

		## set last update epoch for current grid to current epoch
		last_update_ts_grid[$decimal_no]="$ts_epoch"

	    fi

	done <<< "$time_fold"

    fi
}


function set_decimal_bit_pattern ()
#function grid_data ()
{
    ## in decimal_value
    ## out decimal_bit_pattern (array)

    # create a binary string based on current decimal_value to fill grid
    case $pattern_method in

	random)
	    ## grid pattern is randomized

	    ## number of light units on and off
	    lu_on_no=$decimal_value
	    lu_off_no=$(( 9 - $decimal_value ))

	    ## synthesize 9 bit string with number of lights
	    ## on (1) off (0)
	    on_string=$(printf '%0.s1' $(seq 1 $lu_on_no))
	    off_string=$(printf '%0.s0' $(seq 1 $lu_off_no))

	    ## adjust on_off_string in case all lights are off
	    [[ $lu_on_no == 0 ]] && on_string=''
	    [[ $lu_off_no == 0 ]] && off_string=''

	    ## define on_off_string
	    on_off_string=$(printf '%s%s' "$on_string" "$off_string")

	    ## writing on_off_pattern to decimal_bit_pattern array
	    ## randomize on_off_string with shuf, creating on_off_pattern
	    decimal_bit_pattern[$decimal_no]=$(printf '%s' "$on_off_string" | fold -w 1 | shuf | tr -d '\n')
	    ;;

	*)
	    ## set pre-defined (non random) patterns
	    define_grid_fill
	    ;;

    esac
}


function grid_decorate ()
{
    ## in decimal_bit_pattern[decimal_no]
    ## out grid[decimal_no] (decorated)

    : '
    ## replace light bits with color codes

    grid[$decimal_no]=$(printf '%s' "${decimal_bit_pattern[$decimal_no]}" | fold -w 3)

    color=${color_grid[$decimal_no]}
    # workstring
    workstring=$(printf "${grid[$decimal_no]}")
    # workstring zero placeholder
    wsz=${workstring//0/Z}
    # workstirng color code on lights (1s) and adding space
    wszc1=${wsz//1/\\033[${color}m1\\033[0m }
    # workstring color code off lights (Zs) and adding space
    wszc1z=${wszc1//Z/\\033[${color_grid[0]}m0\\033[0m }

    printf "DEV$LINENO %s\n" "$wszc1z"
    printf "$wszc1z"
    #exit 255
    grid[$decimal_no]=$(printf "$wszc1z")

    # '

    #: '

    ## build current grid with color codes
    ## loop through the 9 light bits of the current decimal
    light_bit_no=0
    gdn=''


    ## decimal_bit_pattern fold, for looping through light_bits
    dbpf=$(printf '%s' "${decimal_bit_pattern[$decimal_no]}" | fold -w 1)

    #case method in

    #	random)
    #	    dbpf=$(printf '%s' "${decimal_bit_pattern[$decimal_no]}" | fold -w 1)
    #	    ;;

    #	*)
    #	    dbpf=$(printf '%s' "${decimal_bit_pattern[$decimal_value]}" | fold -w 1)
    #	    ;;

    #esac



    while IFS= read -r light_bit_value; do

	## next light_bit_no (1-9)
	(( light_bit_no+=1 ))

	## add space before every light_bit
	gdn+=' '

	## add light_bit and color
	case $light_bit_value in

	    0)
		## add off light_bit (0) and off color code
		color=${color_grid[0]/'#'/''}
		#color=$(printf '%s' $color | sed -e 's/.\{2\}/&;/g' -e 's/;$//')
		#printf "DEV$LINENO %s\n" "${color}"
		gdn+="\033[38;2;${color}m0\033[0m"
		#gdn+="\033[${color}m0\033[0m"
		#grid[$decimal_no]+="\033[${color}m0\033[0m"
		#exit 255
		;;

	    1)
		## add on light_bit (1) and on color code
		color=${color_grid[$decimal_no]}
		gdn+="\033[${color}m1\033[0m"
		#grid[$decimal_no]+="\033[${color}m1\033[0m"
		;;

	esac

	## add placeholder for space after every light_bit
	## add space after every light_bit
	#grid[$decimal_no]+=' '

	## every third light_bit add eol
	[[ $(( $light_bit_no % 3 )) -eq 0 ]] && gdn+='\n'
	#[[ $(( $light_bit_no % 3 )) -eq 0 ]] && grid[$decimal_no]+='\n'

	## replace light_bit with on off shape
	case $light_bit_value in

	    0)
		gdn="${gdn//m0/m${shape_off}}"
		#grid[$decimal_no]="$(printf '%s' "${grid[$decimal_no]}" | sed "s/m0/m${shape_off}/g")"
		;;

	    1)
		gdn="${gdn//m1/m${shape_on}}"
		#grid[$decimal_no]="$(printf '%s' "${grid[$decimal_no]}" | sed "s/m1/m${shape_on}/g")"
		;;

	esac

	grid[$decimal_no]="$gdn"

    done <<< "$dbpf"

    # '
	#print_entire_array() { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}" ; done }
	#pea () { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}"; done }
	#printf "DEV$LINENO %s\n" "${v}"
	#pea grid
	#exit 255
}


function define_grid_fill ()
{
    ## in pattern_method
    ## out decimal_bit_pattern

    ## if no random grid fill; define fill sequence here
    case $pattern_method in

	pile*)
	    ## grid fills with adding more lights on

	    ## NOTICE the variable pattern_method_pile_sequence
	    ##        must have nine unique single decimal digits

	    ## 123456789 every number is a bit_position (bit 1 (sw) first, 9 (ne) last)
	    ## decimal fill method is defined, i.e.
	    ## decimal value 3 has lights 123 on, therefore
	    ## decimal values and shapes are related and
	    ## decimals can more easily be recognized

	    ## after fold we can loop through with herestring
	    gfmpsf=$(printf '%s' "$pattern_method" | awk -F '-' '{print $2}' | fold -w 1)


	    # define onoff strings with array

	    ## initialize decimal_value 0
	    decimal_value=0
	    on_off_string='000000000'

	    ## write decimal_value 0 to array
	    decimal_bit_pattern[$decimal_value]="$on_off_string"

	    ## write decimal 1-9 to array (herestring)
	    while IFS= read -r bit_position; do

		## next decimal_value
		(( decimal_value+=1 ))

		## bit_position is the light number that comes on for current decimal_value
		on_off_string=$(printf '%s' "$on_off_string" | sed "s/./1/$bit_position")

		## write current decimal_value to array
		decimal_bit_pattern[$decimal_value]="$on_off_string"

		## loop through all nine numbers that define pattern_method
	    done <<< "$gfmpsf"
	    ;;

	sym_v)
	    ## vertically symmetric fill
	    ## decimal_bit_pattern[$decimal_value]=$on_off_pattern
	    decimal_bit_pattern[0]=000000000
	    decimal_bit_pattern[1]=000010000
	    decimal_bit_pattern[2]=010000010
	    decimal_bit_pattern[3]=010010010
	    decimal_bit_pattern[4]=101000101
	    decimal_bit_pattern[5]=101010101
	    decimal_bit_pattern[6]=101101101
	    decimal_bit_pattern[7]=101111101
	    decimal_bit_pattern[8]=111101111
	    decimal_bit_pattern[9]=111111111
	    ;;

	sym_h)
	    ## horizontally symmetric fill
	    ## sym_h[decimal_value]=decimal_bit_pattern
	    decimal_bit_pattern[0]=000000000
	    decimal_bit_pattern[1]=000010000
	    decimal_bit_pattern[2]=000101000
	    decimal_bit_pattern[3]=000111000
	    decimal_bit_pattern[4]=101000101
	    decimal_bit_pattern[5]=101010101
	    decimal_bit_pattern[6]=111000111
	    decimal_bit_pattern[7]=111010111
	    decimal_bit_pattern[8]=111101111
	    decimal_bit_pattern[9]=111111111
	    ;;

    esac
}


function grid_print ()
{
    ## in grid_orientation
    ## in grid[1-6]
    ## out grid_time (final output)

    ## save cursor position
    tput sc

    ## print entire grid
    case $grid_orientation in

	horizontal)
	    ## replace zeros with space shape_off
	    ## replace ones with space shape_on
	    ## CC functions as temporary placeholder for colorcode 033
	    ## in order to prevent replacement of its zero
#printf "DEV$LINENO \n" "${grid[1]}"
#printf "DEV$LINENO \n" "${grid[2]}"
#printf "DEV$LINENO \n" "${grid[3]}"
#printf "DEV$LINENO \n" "${grid[4]}"
#printf "DEV$LINENO \n" "${grid[5]}"
#printf "DEV$LINENO \n" "${grid[6]}"
			#paste -d '|' \
	    grid_time=$(\
			paste \
			    <(printf "${grid[1]}") \
			    <(printf "${grid[2]}") \
			    <(printf "${grid[3]}") \
			    <(printf "${grid[4]}") \
			    <(printf "${grid[5]}") \
			    <(printf "${grid[6]}")\
			    #<(printf "${grid[6]}") | \
			    #sed -e 's/\t/ \t/g' | \
			    #column -t -s$'\t'
		     )


#	    grid_time=$(\
#			printf "${grid[1]}" "${grid[2]}" "${grid[3]}" "${grid[4]}" "${grid[5]}" "${grid[6]}" | \
#			    awk '
#			        {x=ARGIND;a[x]=a[x]>(b=length($0))?a[x]:b}
#				{F[FNR,x]=$0}
#				END{
#					for(q=1;q<=FNR;q++)
#            				{
#                    				for(i=1;i<=ARGC;i++)
#                    				{
#                    				printf( "%-"a[i]"s ",F[q,i])
#						}print ""
#					}
#    				}'\
#			)
	    ;;

	vertical)
	    grid_time=$(\
			printf "${grid[1]}\n${grid[2]}\n${grid[3]}\n${grid[4]}\n${grid[5]}\n${grid[6]}\n"\
		     )

	    ## print all grids
	    ## replace zeros with space shape_off
	    ## replace ones with space shape_on
	    #printf "%${alignment}s" "$grid_time"
	    #printf "%${alignment}s" "$grid_time" | \
	    #	sed -e "s/0/${shape_off}/g" \
	    #	    -e "s/1/${shape_on}/g"
	    ;;

    esac

	    ## print all grids
	    #printf "$grid_time"
	    printf "%${alignment}s" "$grid_time"
}


function initialize ()
{
    tput civis
    alacritty msg config font.size=$font_size
    alacritty msg config font.offset.x=$spacing_x
    alacritty msg config font.offset.y=$spacing_y
    clear
    #separate_container  ## #TODO

    ## store default update period
    main_refresh_period_default=$main_refresh_period

    ## testing all lights
    main_refresh_period=0.5
    #get_time_fold 999999
    run_once 999999

    ## oxo banner
    main_refresh_period=1
    run_once oxo
    main_refresh_period=2
    run_once oxo_color

    ## lights out
    main_refresh_period=0.5
    run_once 000000

    ## reset default update period
    main_refresh_period=$main_refresh_period_default
}


function run_once ()
{
    ## in mode
    ## out grid_print

    mode=$1

    #get_timestamp
    #get_time_fold

    case $mode in

    	'')
    	    ## no specific mode
	    :
    	    ;;

    	oxo)
    	    ## execute oxo_grid_array
    	    oxo_decimal_bit_pattern
	    time_fold=999999
	    decimals=6
	    color=31
    	    ;;

    	oxo_color)
    	    ## execute oxo_grid_array
    	    oxo_decimal_bit_pattern
	    time_fold=999999
	    decimals=6

    	    ## execute grid_decorate for each decimal
    	    #decimal_no=1

    	    #for grid in "${grid[@]}"; do

    	    #	color=${color_grid[$decimal_no]}

    	    #	grid_decorate "$grid"

    	    #	(( decimal_no++ ))

    	    #done
    	    #grid_decorate
    	    ;;

    	999999)
    	    ## execute nine_grid_array
    	    nine_decimal_bit_pattern
	    time_fold=999999
	    decimals=6
    	    ;;

    	000000)
    	    ## execute null_grid_array
    	    null_decimal_bit_pattern
	    time_fold=999999
	    decimals=6
    	    ;;

    esac

    #get_timestamp  ## #TODO no time no timestamp
    #get_time_fold $mode  ## #TODO no time no timestamp
    grid_create
    grid_print
    sleep $main_refresh_period
    grid_reset
    clear_lines
    unset mode
}


function clear_lines ()
{
    ## restore cursor position
    tput rc
    ## clear to end of screen
    tput ed
    #clear
}


function reset_cursor_position ()
{
    ## restore cursor position
    tput rc
}


function grid_reset ()
{
    unset grid
}


function separate_container ()
{
    ## set floating container
    sway floating enable

    ## container opacity
    alacritty msg config window.opacity=$opacity

    ## container dimensions
    con_width=$(( decimals * column_width - con_width_corr ))
    con_height=$(( grid_rows * row_height ))
    sway resize set width $con_width
    sway resize set height $con_height

    ## clear screen
    clear
}


function oxo_decimal_bit_pattern ()
{
    decimal_bit_pattern[1]='101000000'
    [[ $grid_orientation == 'horizontal' ]] && \
	decimal_bit_pattern[1]='100000100'
    decimal_bit_pattern[2]='101000101'
    decimal_bit_pattern[3]='000000000'
    decimal_bit_pattern[4]='101010101'
    decimal_bit_pattern[5]='000000000'
    decimal_bit_pattern[6]='101000101'
}


function nine_decimal_bit_pattern ()
{
    decimal_bit_pattern[1]='111111111'
    decimal_bit_pattern[2]='111111111'
    decimal_bit_pattern[3]='111111111'
    decimal_bit_pattern[4]='111111111'
    decimal_bit_pattern[5]='111111111'
    decimal_bit_pattern[6]='111111111'
}


function null_decimal_bit_pattern ()
{
    decimal_bit_pattern[1]='000000000'
    decimal_bit_pattern[2]='000000000'
    decimal_bit_pattern[3]='000000000'
    decimal_bit_pattern[4]='000000000'
    decimal_bit_pattern[5]='000000000'
    decimal_bit_pattern[6]='000000000'
}


function finalize ()
{
    ## called by trap
    alacritty msg config font.size=11
    alacritty msg config font.offset.x=0
    alacritty msg config font.offset.y=0

    tput cnorm
}


function main ()
{
    #get_args
    #get_parameters
    initialize

    while true; do

	get_timestamp
	get_time_fold
	grid_create
	grid_print
	sleep $main_refresh_period
	#grid_reset
	reset_cursor_position
	clear_lines

    done

    finalize
}


## signal interrupt
trap "finalize; return 1" SIGINT

main
