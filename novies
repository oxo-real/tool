#! /usr/bin/env sh

###                   _
###  _ __   _____   _(_) ___  ___
### | '_ \ / _ \ \ / / |/ _ \/ __|
### | | | | (_) \ V /| |  __/\__ \
### |_| |_|\___/ \_/ |_|\___||___/
###
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
novies
nine bits decimal grid clock
copyright (c) 2024  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
zsh (probably)

# requirements


# usage
novies [options] [value]

# examples
% novies --gray --vertical --tty
#TODO options

# '


set -o errexit
#set -o nounset
set -o pipefail

# script specific constants
## script_metadata
script_dir="$XDG_DATA_HOME/c/git/code/tool"
script_name='novies'
developer='oxo'
license='gplv3'
initial_release_year=2024


args=$@
tmp="$XDG_CACHE_HOME/temp"
novies_config_dir="$XDG_CONFIG_HOME/novies" ## #TODO config file


grid_orientation=horizontal
#grid_orientation=vertical


#pattern_method=pile-741852963  ## vertical
#pattern_method=pile-789456123  ## horizontal
#pattern_method=sym_v
#pattern_method=sym_h
pattern_method=random


row_height=22
font_size=11
shape_on='▄'
#shape_on='◼'
shape_off=' '
#shape_off='◻'
# ◼◻ ■□ ●○
spacing_x=0
spacing_y=0
opacity=0.0
alignment=40  ## #TODO does not align
grid_rows=3
grid_columns=3
column_width=88
con_width_corr=0


declare -ga grid
declare -ga time_value
declare -ga decimal_bit_pattern

## set on off colors for decimal light units
declare -ga color_grid
## color_grid[decimal_no]=color_code
## off color
color_grid[0]=37
#color_grid[0]=#ff73fd
## on color
color_grid[1]=#31
color_grid[2]=31
color_grid[3]=32
color_grid[4]=32
color_grid[5]=34
color_grid[6]=34

## set refresh periods for decimals
main_refresh_period=1
declare -ga refresh_period_decimal
## refresh_period_decimal[decimal_no]=seconds
refresh_period_decimal[1]=60
refresh_period_decimal[2]=60
refresh_period_decimal[3]=15
refresh_period_decimal[4]=15
refresh_period_decimal[5]=3
refresh_period_decimal[6]=1

## initialize as global array last_update_ts_decimal
declare -ga last_update_ts_decimal
## last_update_ts_decimal[decimal_no]=seconds
#last_update_ts_decimal[1]=0
#last_update_ts_decimal[2]=0
#last_update_ts_decimal[3]=0
#last_update_ts_decimal[4]=0
#last_update_ts_decimal[5]=0
#last_update_ts_decimal[6]=0


function get_args ()
{
    #TODO
    :
}


function get_timestamp ()
{
    ## in epoch
    ## out ts_epoch
    ## out ts_hms
    ## out ts_hour
    ## out ts_minute
    ## out ts_second
    ## out decimals

    ts_epoch=$(date +'%s')
    ts_hms=$(date -d @"$ts_epoch" +'%H%M%S')

    time_value[1]=$(cut -c 1-1 <<< $ts_hms)
    time_value[2]=$(cut -c 2-2 <<< $ts_hms)
    time_value[3]=$(cut -c 3-3 <<< $ts_hms)
    time_value[4]=$(cut -c 4-4 <<< $ts_hms)
    time_value[5]=$(cut -c 5-5 <<< $ts_hms)
    time_value[6]=$(cut -c 6-6 <<< $ts_hms)

    ## ts values without leading zeros
    ts_minute=$(date -d @"$ts_epoch" +'%-M')
    ts_second=$(date -d @"$ts_epoch" +'%-S')
    ts_hour=$(date -d @"$ts_epoch" +'%-H')

    ## number of decimals will become the number of grids
    #decimals=$(wc -c <<< "$ts_hms")
    decimals=$(printf '%s' "$ts_hms" | wc -c)
}


function grid_create ()
{
    ## in decimal_no
    ## out grid_data
    ## out grid_to_array
    ## out grid_decorate

    ## #looping through every decimal_no to create grid_data and decorate

    ## set decimal bit pattern
#TODO only run once (at the start)
    set_decimal_bit_pattern

    ## loop through every decimal in time_fold (decimal_value)
    #for i in "${!time_value[@]}"; do
    for (( decimal_no=1; decimal_no<=$decimals; decimal_no++ )); do

	## get last update epoch for current decimal (lueg)
	lueg=${last_update_ts_decimal[$decimal_no]:-0}

	## get refresh period for current decimal (rpd)
	rpd=${refresh_period_decimal[$decimal_no]}

	## refresh current nine bits decimal grid, only
	## if last update is longer ago than threshold, or
	if [[ $(( ts_epoch - lueg )) -ge $rpd ]] || \
	       ## if ts_epoch minute differs from lueg minutes
	       [[ $ts_minute -ne $lueg_minute ]] || \
	       ## if ts_epoch hour differs from lueg hour, or
	       [[ $ts_hour -ne $lueg_hour ]]; then

	    ## no leading zeros in lueg values
	    lueg_hour=$(date -d @"$lueg" +'%-H')
	    lueg_minute=$(date -d @"$lueg" +'%-M')

	    case $pattern_method in

		random)

		    ## reset time decimal bit pattern (random)
		#TODO only for current decimal_no
		    set_decimal_bit_pattern
		    ;;

	    esac

	    ## set last update epoch for current grid to current epoch
	    last_update_ts_decimal[$decimal_no]="$ts_epoch"

	fi

	#printf "DEV$LINENO %s\n" "${last_update_ts_decimal[$decimal_no]}"

	grid_decorate

    done
}


function grid_decorate ()
{
    ## in time_value[decimal_no]
    ## out grid[decimal_no]

    ## create decorated (color and shope) 3 by 3 grid from time_value

    ## decimal_bit_pattern fold, for looping through light_bits
    ## one step:
    dbpf=$(fold -w 1 <<< ${decimal_bit_pattern[${time_value[$decimal_no]}]})
    ## two step:
    ## tvdn=${time_value[$decimal_no]}
    ## dbpf=$(fold -w 1 <<< ${decimal_bit_pattern[$tvdn]})

    ## build current grid with color codes
    ## loop through the 9 light bits of the current decimal
    light_bit_no=0
    gdn=''

    while IFS= read -r light_bit_value; do

	## next light_bit_no (1-9)
	(( light_bit_no+=1 ))

	## add space before every light_bit
	gdn+=' '

	## add light_bit and color
	case $light_bit_value in

	    0)
		## add off light_bit (0) with off color code
		color=${color_grid[0]/'#'/''}
		gdn+="\033[38;2;${color}m0\033[0m"
		;;

	    1)
		## add on light_bit (1) with on color code
		color=${color_grid[$decimal_no]/'#'/''}
		gdn+="\033[${color}m1\033[0m"
		;;

	esac

	## eol every third light_bit
	[[ $(( $light_bit_no % 3 )) -eq 0 ]] && gdn+='\n'

	## replace light_bit with on off shape
	case $light_bit_value in

	    0)
		gdn="${gdn//m0/m${shape_off}}"
		;;

	    1)
		gdn="${gdn//m1/m${shape_on}}"
		;;

	esac

	grid[$decimal_no]="$gdn"

    done <<< "$dbpf"
}


function set_decimal_bit_pattern ()
{
    ## in pattern_method
    ## out decimal_bit_pattern array for values 0-9

    decimal_bit_pattern[0]=000000000
    decimal_bit_pattern[9]=111111111

    ## if no random grid fill; define fill sequence here
    case $pattern_method in

	random)
	    ## create nine random patterns

	    for decimal_value in {1..8}; do
	#TODO initially set for all decimals (which it does now)
	#TODO reset for single decimal
		## in decimal_value
		## out random decimal_bit_pattern (array)

		# create a random binary string based on current decimal_value to fill grid

		## number of light units on and off
		lu_on_no=$decimal_value
		lu_off_no=$(( 9 - $decimal_value ))

		## synthesize 9 bit string with number of lights
		## on (1) off (0)
		on_string=$(printf '%0.s1' $(seq 1 $lu_on_no))
		off_string=$(printf '%0.s0' $(seq 1 $lu_off_no))

		## define on_off_string
		on_off_string=$(printf '%s%s' "$on_string" "$off_string")

		## writing on_off_pattern to decimal_bit_pattern array
		## randomize on_off_string with shuf, creating on_off_pattern
		decimal_bit_pattern[$decimal_value]=$(fold -w 1 <<< "$on_off_string" | shuf | tr -d '\n')

	    done
	    ;;

	pile*)
	    ## grid fills with adding more lights
	    ## on top of those already on

	    ## NOTICE the variable pattern_method_pile_sequence
	    ##        must have nine unique single decimal digits

	    ## 123456789 every number is a bit_position (bit 1 (sw) first, 9 (ne) last)
	    ## decimal fill method is defined, i.e.
	    ## decimal value 3 has lights 123 on, therefore
	    ## decimal values and shapes are related and
	    ## decimals can more easily be recognized

	    ## after fold we can loop through with herestring
	    gfmpsf=$(awk -F '-' '{print $2}' <<< "$pattern_method" | fold -w 1)


	    # define onoff strings with array

	    ## initialize decimal_value 0
	    decimal_value=0
	    on_off_string='000000000'

	    ## write decimal_value 0 to array
	    decimal_bit_pattern[$decimal_value]="$on_off_string"

	    ## write decimal 1-9 to array (herestring)
	    while IFS= read -r bit_position; do

		## next decimal_value
		(( decimal_value+=1 ))

		## bit_position is the light number that comes on for current decimal_value
		on_off_string=$(sed "s/./1/$bit_position" <<< "$on_off_string")

		## write current decimal_value to array
		decimal_bit_pattern[$decimal_value]="$on_off_string"

		## loop through all nine numbers that define pattern_method
	    done <<< "$gfmpsf"
	    ;;

	sym_v)
	    ## vertically symmetric fill
	    ## decimal_bit_pattern[$decimal_value]=$on_off_pattern
	    decimal_bit_pattern[1]=000010000
	    decimal_bit_pattern[2]=010000010
	    decimal_bit_pattern[3]=010010010
	    decimal_bit_pattern[4]=101000101
	    decimal_bit_pattern[5]=101010101
	    decimal_bit_pattern[6]=101101101
	    decimal_bit_pattern[7]=101111101
	    decimal_bit_pattern[8]=111101111
	    ;;

	sym_h)
	    ## horizontally symmetric fill
	    ## sym_h[decimal_value]=decimal_bit_pattern
	    decimal_bit_pattern[1]=000010000
	    decimal_bit_pattern[2]=000101000
	    decimal_bit_pattern[3]=000111000
	    decimal_bit_pattern[4]=101000101
	    decimal_bit_pattern[5]=101010101
	    decimal_bit_pattern[6]=111000111
	    decimal_bit_pattern[7]=111010111
	    decimal_bit_pattern[8]=111101111
	    ;;

    esac
}


function grid_print ()
{
    ## in grid_orientation
    ## in grid[1-6]
    ## out grid_time (final output)

    ## save cursor position
    tput sc

    ## print entire grid
    case $grid_orientation in

	horizontal)
	    grid_time=$(\
			paste \
			    <(printf "${grid[1]}") \
			    <(printf "${grid[2]}") \
			    <(printf "${grid[3]}") \
			    <(printf "${grid[4]}") \
			    <(printf "${grid[5]}") \
			    <(printf "${grid[6]}")\
		     )
	    ;;

	vertical)
	    grid_time=$(\
			printf "${grid[1]}\n${grid[2]}\n${grid[3]}\n${grid[4]}\n${grid[5]}\n${grid[6]}\n"\
		     )
	    ;;

    esac

	    ## print all grids
	    printf "%${alignment}s" "$grid_time"

    ## restore cursor position
    tput rc
}


function initialize ()
{
    tput civis
    alacritty msg config font.size=$font_size
    alacritty msg config font.offset.x=$spacing_x
    alacritty msg config font.offset.y=$spacing_y

    clear
    #separate_container  ## #TODO
}


function grid_reset ()
{
    unset grid
}


function separate_container ()
{
    ## set floating container
    sway floating enable

    ## container opacity
    alacritty msg config window.opacity=$opacity

    ## container dimensions
    con_width=$(( decimals * column_width - con_width_corr ))
    con_height=$(( grid_rows * row_height ))
    sway resize set width $con_width
    sway resize set height $con_height

    ## clear screen
    clear
}


function finalize ()
{
    ## called by trap
    alacritty msg config font.size=11
    alacritty msg config font.offset.x=0
    alacritty msg config font.offset.y=0

    tput cnorm
}


function main ()
{
    #get_args
    #get_parameters
    initialize

    while true; do

	get_timestamp
	grid_create
	grid_print
	sleep $main_refresh_period
	grid_reset

    done

    finalize
}


## signal interrupt
trap "finalize; return 1" SIGINT

main
