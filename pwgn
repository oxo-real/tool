#!/bin/sh
#
##
###  _ ____      ____ _ _ __
### | '_ \ \ /\ / / _` | '_ \
### | |_) \ V  V / (_| | | | |
### | .__/ \_/\_/ \__, |_| |_|
### |_|           |___/
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### pwgn
### generate unique hex strings
###
### (c) 2020 - 2022 cytopyge
###
### --------------------------------
### usage: pwgn
##
#


# initial definitions
## initialize hardcoded variables
script_name="pwgn"
initial_release_year="2020"
developer="cytopyge"
source_dir="$XDG_DATA_HOME/git/code/sources/functions"


read_input()
{
	: '
	read input;
	printf '%s' "$input" | \
		base64 | \
		wl-copy -n -o;
	unset input
	# '
}


sourcing()
{
	## define colors
	source $source_dir/text_appearance

	## reply functions
	source $source_dir/reply_functions

	## user authentication
	source $source_dir/get_sudo

	## progress bar
	source $source_dir/progress_bar
}


terminal_lines()
{
	# at least 34 lines for proper blocks and qr-code
	term_lines="$(tput lines)"

	if [[ "$term_lines" -le "33" ]]; then

		clear
		## save cursor position
		#tput sc

		# hide cursor
		#tput civis

		printf "${RED}insufficient terminal lines ($term_lines need 34)${NOC}\n\n"
		printf "exiting, press ${YELLOW}o${NOC} to override "

		reply_single_hidden_timer

		echo
		## clear screen and home cursor
		#tput clear
		## show cursor again
		#tput cnorm

		if printf "$reply" | grep -q "^o"; then

			continue

		else

			exit 45

		fi

	fi

}


optical_input()
{
	input=$(zbarcam --oneshot --raw)
}


keyboard_input()
{
	## give clear line for entry
	## clear screen and home cursor
	tput clear

	#read input
	read input

	##[TODO] press tab to hide keyboard entry

	## clear screen and home cursor
	tput clear
}


choose_input()
{
	# choose optical or manual input

	get_sudo

	clear
	## save cursor position
	tput sc

	printf "${YELLOW}O${NOC}ptical scan and decode from video device "

	# hide cursor
	tput civis

	reply_single_hidden_timer

	## clear screen and home cursor
	tput clear
	## show cursor again
	tput cnorm

	if printf "$reply" | grep -q "^O"; then

		optical_input

	else

		keyboard_input

	fi
}


input_validation()
{
	[[ -z $input ]] && exit 10
}


hashing()
{
## input, algorithm

	## sed removes '(stdin)= ' of openssl dgst
	printf $1 | openssl dgst -$2 | sed 's/^.*= //'
}


hmacing()
{
## sha3 hmac rfc2104
## input, algorithm, hmac

	printf $1 | openssl dgst -$2 -hmac $3 | sed 's/^.*= //'
}


hash_1_input()
{
## create sha1 hash from input

	local input=$input
	local algo="sha1"

	hash_sha1=$(hashing $input $algo)
}


hash_3_input()
{
## create sha3-512 hash from input
## keccak sha3 standard fips pub 202

	local input=$input
	local algo="sha3-512"

	hash_sha3512=$(hashing $input $algo)

	# for input='s'; hash_sha3512='723a..16fc'
}


clear_input()
{
## overwrite input variable, then clear and unset it for security

	input=$(< /dev/random tr -d -c "[:xdigit:]" | head -c 128)
	input=""
	#[TODO] when using symlink pwgn it generates error not enough arguments
	unset input
}


print_blocks()
{
## print four lines of eight; two space-separated, four-column,
## zero-filled, two-byte quantities of hexadecimal inputdata

	row1=$(printf $1 | cut -c 1-32 | sed 's/.\{4\}/&  /g')
	row2=$(printf $1 | cut -c 33-64 | sed 's/.\{4\}/&  /g')
	row3=$(printf $1 | cut -c 65-96 | sed 's/.\{4\}/&  /g')
	row4=$(printf $1 | cut -c 97-128 | sed 's/.\{4\}/&  /g')

	printf '\e[38;2;215;215;215m%s\e[m\n' "$row1"
	printf '\e[38;2;155;155;155m%s\e[m\n' "$row2"
	printf '\e[38;2;215;215;215m%s\e[m\n' "$row3"
	printf '\e[38;2;155;155;155m%s\e[m\n' "$row4"
}


round_pool()
{
## dynamic truncate hash_sha3512
## dividend is based on the sha3512 hash of the input

	local hs=$hash_sha3512
	local dgts="10"

	dividend=$(dynamic_truncate $hs $dgts)
}


round_space()
{
## dynamic truncate hash_sha1
## divisor is based on the sha1 hash of the input

	local hs=$hash_sha1
	local dgts="4"

	divisor=$(dynamic_truncate $hs $dgts)
}


rounds_number()
{
## input='s'; rounds=532

	rounds=$(( $dividend % $divisor ))
}


round_key()
{
## create hmac key for running_rounds
## input='s'; round_key='bb40..d76f'

	local input=$dividend
	local algo="sha3-512"
	local hmac=$divisor

	round_key=$(hmacing $input $algo $hmac)
}


running_rounds()
{
	## keep hash_sha3512 untouched
	input_calc=$hash_sha3512

	## hide cursor
	tput civis

	print_blocks $hash_sha3512

	## save cursor position
	tput sc

	for (( round=1; round<=$rounds; round++ ))

	do

		local input=$input_calc
		local algo="sha3-512"
		local hmac=$round_key

		output=$(hmacing $input $algo $hmac)

		## migrate output to input_calc for next round
		[[ $rounds > 1 ]] && input_calc=$output

		## every round the $input_calc from the previous round is taken in
		## $round_key stays static

		# show iterations
		## restore cursor position
		tput rc
		## clear to end of screen
		tput ed

		print_qr_codeblock
		print_blocks $output

		bar_width=38
		# progress percentage indicator
		if [[ $round -lt $rounds ]]; then

			prog_perc=$(awk "BEGIN {print ($round/$rounds*100)}" | cut -f 1 -d .)

			bar $prog_perc $bar_width

		fi

	done

	## show cursor
	tput cnorm

	# for input='s' output='b68a..027a'
}


two_fa()
{
	# two factor authentication

	## human enters 2fa code from separate source
	printf "?2fa  "
	read two_fa

	## set variables to send to genotp
	secret="$XDG_DATA_HOME/git/private/vault/totp.key"
	mode="totp"
	alg="sha512"
	digits="12"
	period="30"
	dt_str=""
	counter="0"
	from_hmac="1"

	## call genotp to get current code
	eval $(source $XDG_DATA_HOME/git/notes/crypto/2fa/genotp/genotp.sh; echo code="$code";)

	## code from genotp is 12 digits (for aesthetic purposes there)
	## first two though are always leading zeros
	code=$(printf $code | cut -c 3-)

	if [[ "$two_fa" != "$code" ]]; then

		#printf "unable to authenticate\n"
		exit 33

	fi
}


output_console()
{
	## personal iterations multiplier (pim)
	printf "$(print_blocks $output)\n"
}


output_wlcopy()
{
	printf $output | cut -c -64 | wl-copy -o -n

	## to file
	### for barebone tty usage
	### beware! potentially unsafe
	#printf "$output_64" | cut -c -64 > output.tmp

	## to variable
	#clpbrd=$(printf "$output_64" | cut -c -64)
}


print_qr_code()
{
	[[ -n $(command -v qrencode) ]] && printf $1 | qrencode -m 3 -t UTF8
}


print_qr_codeblock()
{
	print_qr_code $output
}


dynamic_truncate()
{
	## truncates a sha1 hex string (rfc4226, DynamicTruncate)
	## get last 4 bits from hash ($hex_str)
	## get the integer number (0-f > 1-10) of those bits; this is the offset
	## starting from the offset get the first 4 bytes from the hash ($hex_str)

	## this is an altered version of dynamic truncate compared to the rfc4226

	##										values for
	##				hex_str		digits		input='s'
	##
	##	dividend	sha3512			10		1402058969
	##  divisor		sha1			 4			  2593

	local hex_str="$1"
	local digits="$2"

	## 2 times decimal value of the last char of the hex string
	## so this value is between 0 (0) and 30 (F)
	## i.e. if last char is 'c' then decimal value is 12
	### $((2 * 0x${hex_str: -1})) explained:
	### ${hex_str: -1}	= get the last hex character from $hex_str	(c)
	### echo ((0xc))	= convert hex value to decimal value		(12)
	### 2 * 12			= two times decimal value					(24)

	local offset=$((2 * 0x${hex_str: -1}))

	## from the offset get next 4 bytes from hex_str (8 hexchars / 32 bits)
	## mind that first position has an offset value of 0
	## bytes are bitwise AND compared with 7fffffff
	## so the 32 bits are AND compared with the binary value of 7fffffff
	## the bitwise comparison result is put in a modulo dividend
	## the divisor is digits as a power of 10
	## effectively this returns the last <digits> digits of the dividend

	digits_ret=$(( ( (0x${hex_str:$offset:8}) & 0x7FFFFFFF ) % ( 10**$digits ) ))

	echo $digits_ret
}


debugging()
{
	printf "input:			$input\n"
	printf "hash_sha1:		$hash_sha1\n"
	printf "hash_sha3512:	$hash_sha3512\n"
	printf "dividend:		$dividend\n"
	printf "divisor:		$divisor\n"
	printf "rounds:			$rounds\n"
	printf "round_key:		$round_key\n"
}


sourcing
terminal_lines
choose_input
input_validation
hash_1_input
hash_3_input
clear_input
round_pool
round_space
rounds_number
round_key
#debugging
#two_fa
running_rounds
#output_console
output_wlcopy
exit 0
