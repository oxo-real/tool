#! /usr/bin/env sh

###
###        _         ___  ____
###   ___ | |_ _ __ / _ \| ___|
###  / _ \| __| '_ \ (_) |___ \
### | (_) | |_| |_) \__, |___) |
###  \___/ \__| .__/  /_/|____/
###           |_|
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
otp95
one-time pad cryptor
copyright (c) 2024  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
  keyfile

# usage
  ## encryption
  % otp95 [e] [key $keyfile] [out $outfile] [in $infile] [plain text]

  ## decryption
  % otp95 d [key $keyfile] [out $outfile] [in $infile] ['cipher_text']

  WARNING keyfiles must be kept secret at all times!!

  SPECIFIC NOTICE
  	   for decryption subcommand d is compulsory
  	   commandline text input (not recommended) must be quoted

  GENERAL NOTICE
  	  commandline text input, although possible, is not recommended
	  commandline text input must always be the last argument
 	  keyfile needs a minimum of 2 lines (at least 96 recommended)
	  keyfile lines should be randomly ordered
	  keyfile can be generated from $ASCII

  TECHNICAL NOTICE
	  ## > encryption: input = plain_text > code_text > cipher_text = output
	  ## > decryption: input = cipher_text > code_text > plain_text = output

# '

# cat /home/oxo/c/git/code/tool/otp95 | grep -A 1 --line-number '(encr)'
# cat /home/oxo/c/git/code/tool/otp95 | grep -A 1 --line-number '(decr)'


set -o errexit
#set -o nounset
set -o pipefail


# initial definitions

## script
script_name='otp95'
developer='oxo'
license='gplv3'
initial_release='2024'

## arguments
### static variables
#### these do not change throughout script session
args="$@"
session_key_line='1'  ## default value of the session key line
key_dir="$XDG_DATA_HOME/c/keys/otp95"
### dynamic variables
timestamp="$(date +'%Y%m%d_%H%M%S_%s')"


getargs()
{
    while true; do

	case "$1" in

	    d | -d | --decr )
		action='decrypt'
		shift
		;;

	    e | -e | --encr )
		action='encrypt'
		shift
		;;

	    key | --key | --key-file )
		shift
		key_file=$1
		shift
		;;

	    keyo | -o | --key-options )
		shift
		key_options=$1
		shift
		;;

	    'tac' )
		key_options+='tac,'
		shift
		;;

	    'rev' )
		key_options+='rev,'
		shift
		;;

	    'sort' )
		key_options+='sort,'
		shift
		;;

	    keyl | --key-line | --session-key )
		shift
		keyl=$1
		shift
		;;

	    'in' | --in | --in-file )
		shift
		in_file=$1
		shift
		;;

	    'out' | --out | --out-file )
		shift
		out_file=$1
		shift
		;;

	    -- )
		shift
		[[ -z $in_file ]] && input=$@
		return
		;;

	    * )
		input_star=$@
		return
		;;

	esac

    done
}


verify_args()
{
    ## action
    ## default action is encrypt to stdout
    [[ -z $action ]] && action='encrypt'

    ## input
    if [[ -n $input_star ]]; then

	    ## number: catch a number as session key line
	    ## NOTICE use -- if a number has to be encrypted
	    if [[ $input_star =~ ^[0-9]+$ ]]; then

		key_options+=$input_star

	    else

		input=$input_star

	    fi

    fi


    if [[ -z $input ]]; then

	if [[ -n $in_file ]]; then

	    input=$(cat $in_file)

	else

	    read_input

	fi

    fi


    ## session key line
    [[ -n $keyl ]] && run_skl


    ## keyfile
    if [[ -z $key_file ]]; then

	## use default keyfile (not recommended)
	#: '
	key_file="$key_dir/keyfile"
	# '

	## generate keyfile (recommended)
	: '
	key_file="${key_dir}/${timestamp}_keyfile"

	for i in {1..95}; do

	    printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'
	    echo

	done > $key_file

	## keyfile file mode: user rw
	chmod 600 $key_file

	printf 'NOTICE generated keyfile: %s\n' "$key_file"
	printf 'WARNING keyfiles must be kept secret at all times!!\n'
	# '

    fi
    key_file_mem=$(cat "$key_file")
    key_lines=$(wc -l "$key_file" | awk '{print $1}')  ## total number of lines in key_file


    ## keyfile modification options
    ## multiple options come in a comma separated list
    ## CAUTION DEV options are still in beta
    for option in ${key_options//,/ }; do

	case $option in

	    tac )
		run_tac
		;;

	    rev )
		run_rev
		;;

	    sort )
		run_sort
		;;

	    * )
		## integer as option will be read as a session key
		## if also keyl is given this option value will be added
		if [[ $option =~ ^[0-9]+$ ]]; then

		    keyl_option=$option

		fi

		run_skl
		;;

	esac

    done


}


run_tac()
{
    key_file_mem=$(tac <<< $key_file_mem)
}


run_rev()
{
    ## get session key data
    run_skl
    session_key=$(sed -n ${session_key_line}p "$key_file")
    rev_session_key=$(rev <<< "$session_key")

    ### encode session key data
    session_key_enc=$(base64 --wrap 0 <<< "$session_key")
    rev_session_key_enc=$(base64 --wrap 0 <<< "$rev_session_key")

    ### reverse all lines in keyfile characterwise (rev)
    key_file_mem=$(rev <<< $key_file_mem | base64 --wrap 0)
    ### replace encoded rev session key with encoded session key
    key_file_mem=${key_file_mem//"$rev_session_key_enc"/"$session_key_enc"}

    ### decode repaired reversed keyfile
    key_file_mem=$(base64 --decode <<< "$key_file_mem")
}


run_sort()
{
    key_file_mem=$(sort $key_file_mem)
}


run_skl()
{
    ## summize keyl and keyl_option
    ## make session key line modulo key_lines
    [[ -z keyl ]] && keyl_num=0
    [[ -z keyl_option ]] && keyl_option_num=0
    session_key_line=$(( keyl_num + keyl_option_num % key_lines ))
}


read_input()
{
    ## user can input multiple lines and ends with an end of transmission
    ## EOT (U+0004, ^D or C-d)
    input=$(cat)
    echo
}


input()
{
    case $action in

	encrypt )
	    ## > input (encr): input = plain_text > code_text > cipher_text = output
	    ## >               ^^^^^^^^^^^^^^^^^^
	    plain_text="$input"
	    ;;

	decrypt )
	    ## > input (decr): input = cipher_text > code_text > plain_text = output
	    ## >               ^^^^^^^^^^^^^^^^^^^
	    cipher_text="$input"
	    ;;

    esac
}


transcode()
{
    case $action in

	encrypt )
	    ## > encode (encr): input = plain_text > code_text > cipher_text = output
	    ## >                        ^^^^^^^^^^^^^^^^^^^^^^

	    code_text=$(base64 --wrap 0 <<< "$plain_text")
	    ;;

	decrypt )
	    ## > decode (decr): input = cipher_text > code_text > plain_text = output
	    ## >                                      ^^^^^^^^^^^^^^^^^^^^^^

	    plain_text=$(base64 --decode <<< "$code_text")
	    ;;

    esac
}


run_action()
{
    case $action in

	encrypt)
	    transcode
	    encrypt
	    ;;

	decrypt)
	    decrypt
	    transcode
	    ;;

    esac
}


encrypt()
{
    ## > encrypt (encr): input = plain_text > code_text > cipher_text = output
    ## >                                      ^^^^^^^^^^^^^^^^^^^^^^^

    ## get the otp session key
    session_key=$(sed -n ${session_key_line}p <<< $key_file_mem)
    ####session_key=$(sed -n ${session_key_line}p "$key_file")

    ## code text is the encoded plain text
    len_code_text=$(printf '%s' "$code_text" | wc -c)

    cipher_text=''

    for (( i=1; i<=$len_code_text; i++ )); do

	## designate key line number from key_file;
	## to encrypt every next character in the code_text
	## we use a new line from the keyfile
	## the key_line_num we need from the key_file is
	## the current character number in the code_text
	## modulo key_lines
	## key_line_num can be 0 and sed can't have 0p
	## correct with +1 for sed later on
	key_line_num=$(( ( i % key_lines ) + 1 ))

	## get code char (line,col from code_text)
	## CAUTION i=0 designates the first character in code_text
	current_code_char=${code_text:$i:1}
	####current_code_char=${code_text:$i-1:1}

	## get key column
	## by cutting the session_key in two parts using
	## the current code character and then
	## count the amount of characters in the first part
	key_col=$(printf '%s' "$session_key" | cut -d "$current_code_char" -f 1 | wc -c)
	####key_col=$(( key_col - 1 ))

	## current crypt line is key_line_num in key_file
	## CAUTION key_line_num=0 designates the first line
	## sed 0p gives error, therefore key_line_num minimum is 1
	current_crypt_line=$(sed -n ${key_line_num}p <<< "$key_file_mem")

	## get current cipher_char from key_col in current_crypt_line
	current_cipher_char=${current_crypt_line:key_col:1}

	## write current cipher_char to cipher_text
	cipher_text="${cipher_text}$current_cipher_char"

    done
}


decrypt()
{
    ## > decrypt (decr): input = cipher_text > code_text > plain_text = output
    ## >                         ^^^^^^^^^^^^^^^^^^^^^^^

    ## get the otp session key
    session_key=$(sed -n ${session_key_line}p <<< $key_file_mem)
    ####session_key=$(sed -n ${session_key_line}p "$key_file")

    ## cipher_text is the encrypted code text
    len_ciph_text=$(printf '%s' "$cipher_text" | wc -c)

    code_text=''

    for (( i=1; i<=$len_ciph_text; i++ )); do

	## designate key line number from key_file;
	## to decrypt every next character in the ciph_text
	## we use a new line from the keyfile
	## the key_line_num we need from the key_file is
	## the current character number in the code_text
	## modulo key_lines
	## key_line_num can be 0 and sed can't have 0p
	## correct with +1 for sed later on
	key_line_num=$(( ( i % key_lines ) + 1 ))

	## get decrypt_char (line,col from cipher_text)
	## CAUTION i=0 designates the first character in code_text
	current_cipher_char=${cipher_text:$i:1}
	####current_cipher_char=${cipher_text:$i-1:1}

	## current decrypt line is key_line_num in key_file
	## CAUTION key_line_num=0 designates the first line
	## sed 0p gives error, therefore key_line_num minimum is 1
	current_decrypt_line=$(sed -n ${key_line_num}p <<< "$key_file_mem")
	#current_decrypt_line=$(sed -n ${key_line_num}p $key_file_mem)

	## get key column
	## by cutting the current_decrypt_line in two parts using
	## the current cipher character and then
	## count the amount of character in the first part
	key_col=$(printf '%s' "$current_decrypt_line" | cut -d "$current_cipher_char" -f 1 | wc -c)
	####key_col=$(( key_col - 1 ))

	## get current code char from key_col in session_key
	current_code_char=${session_key:key_col:1}

	## write current code char to code_text
	code_text="${code_text}$current_code_char"

    done
}


output()
{
    ## > output (encr): input = plain_text > code_text > cipher_text = output
    ## >                                                 ^^^^^^^^^^^^^^^^^^^^

    ## > output (decr): input = cipher_text > code_text > plain_text = output
    ## >                                                  ^^^^^^^^^^^^^^^^^^^

    [[ $action == 'encrypt' ]] && output="$cipher_text"
    [[ $action == 'decrypt' ]] && output="$plain_text"

    if [[ -n "$out_file" ]]; then

	case $out_file in

	    copy | wl-copy | clipboard )
		## output to clipboard
		printf '%s\n' "$output" | wl-copy
		;;

	    * )
		## output to file
		printf '%s\n' "$output" > "$out_file"
		;;

	esac

    else

	## output to stdout
	printf '%s\n' "$output"

    fi
}


main()
{
    getargs $args
    verify_args
    input
    run_action
    output
}

main
