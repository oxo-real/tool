#! /usr/bin/env sh

###
###        _         ___  ____
###   ___ | |_ _ __ / _ \| ___|
###  / _ \| __| '_ \ (_) |___ \
### | (_) | |_| |_) \__, |___) |
###  \___/ \__| .__/  /_/|____/
###           |_|
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
otp95
one time pad cryptor
copyright (c) 2024  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
  keyfile

# usage
  ## encryption
  % otp95 [e] [key $keyfile] [out $outfile] [in $infile] [plain text]

  ## decryption
  % otp95 d [key $keyfile] [out $outfile] [in $infile] ['cipher_text']

  WARNING keyfiles must be kept secret at all times!!

  SPECIFIC NOTICE
  	   for decryption subcommand d is compulsory
  	   commandline text input (not recommended) must be quoted

  GENERAL NOTICE
  	  commandline text input, although possible, is not recommended
	  commandline text input must always be the last argument
 	  keyfile needs a minimum of 2 lines (at least 96 recommended)
	  keyfile lines should be randomly ordered
	  keyfile can be generated from $ASCII

  TECHNICAL NOTICE
	  ## > encryption: input = plain_text > code_text > cipher_text = output
	  ## > decryption: input = cipher_text > code_text > plain_text = output

# '

# cat /home/oxo/c/git/code/tool/otp95 | grep -A 1 --line-number '(encr)'
# cat /home/oxo/c/git/code/tool/otp95 | grep -A 1 --line-number '(decr)'


set -o errexit
#set -o nounset
set -o pipefail


# initial definitions

## script
script_name='otp95'
developer='oxo'
license='gplv3'
initial_release='2024'

## arguments
### static variables
#### these do not change throughout script session
args="$@"
key_dir="$XDG_DATA_HOME/c/keys/otp95"
### dynamic variables
timestamp="$(date +'%Y%m%d_%H%M%S_%s')"


getargs()
{
    while true; do

	case "$1" in

	    d | -d | --decr )
		action='decrypt'
		shift
		;;

	    e | -e | --encr )
		action='encrypt'
		shift
		;;

	    key | --key | --key-file )
		shift
		key_file=$1
		shift
		;;

	    'in' | --in | --in-file )
		shift
		in_file=$1
		shift
		;;

	    'out' | --out | --out-file )
		shift
		out_file=$1
		shift
		;;

	    -- )
		shift
		[[ -z $in_file ]] && input=$@
		#[[ -z $in_file ]] && text=$@
		break
		;;

	    * )
		## default action is encrypt to stdout
		[[ -z $action ]] && action='encrypt'
		input=$@
		#text=$@
		return
		;;

	esac

    done
}


verify_args()
{
    ## input
    if [[ -z $input ]]; then

	if [[ -n $in_file ]]; then

	    input=$(cat $in_file)

	else

	    read_input

	fi

    fi


    ## keyfile
    if [[ -z $key_file ]]; then

	## use default keyfile (not recommended)
	#: '
	key_file="$key_dir/keyfile"
	# '

	## generate keyfile (recommended)
	: '
	key_file="${key_dir}/${timestamp}_keyfile"

	for i in {1..95}; do

	    printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'
	    echo

	done > $key_file

	## keyfile file mode: user rw
	chmod 600 $key_file

	printf 'NOTICE generated keyfile: %s\n' "$key_file"
	printf 'WARNING keyfiles must be kept secret at all times!!\n'
	# '

    fi
}



read_input()
{
    ## user can input multiple lines and ends with an end of transmission
    ## EOT (U+0004, ^D or C-d)
    input=$(cat)
    echo
}


input()
{
    case $action in

	encrypt )
	    ## > input (encr): input = plain_text > code_text > cipher_text = output
	    ## >               ^^^^^^^^^^^^^^^^^^
	    plain_text="$input"
	    ;;

	decrypt )
	    ## > input (decr): input = cipher_text > code_text > plain_text = output
	    ## >               ^^^^^^^^^^^^^^^^^^^
	    cipher_text="$input"
	    ;;

    esac
}


transcode()
{
    case $action in

	encrypt )
	    ## > transcode (encr): input = plain_text > code_text > cipher_text = output
	    ## >                           ^^^^^^^^^^^^^^^^^^^^^^
	    code_text=$(printf '%s' "$plain_text" | base64)
	    ;;

	decrypt )
	    ## > transcode (decr): input = cipher_text > code_text > plain_text = output
	    ## >                                         ^^^^^^^^^^^^^^^^^^^^^^
	    plain_text=$(printf '%s' "$code_text" | base64 --decode)
	    ;;

    esac
}


run_action()
{
    case $action in

	encrypt)
	    transcode
	    encrypt
	    ;;

	decrypt)
	    decrypt
	    transcode
	    ;;

    esac
}


encrypt()
{
    ## > encrypt (encr): input = plain_text > code_text > cipher_text = output
    ## >                                      ^^^^^^^^^^^^^^^^^^^^^^^

    key_lines=$(wc -l $key_file | awk '{print $1}')
    session_key='1'
    otp_session_key=$(sed -n ${session_key}p $key_file)

    ## code text is the encoded plain text
    len_code_text=$(printf '%s' "$code_text" | wc -c)

    cipher_text=''

    for (( i=1; i<=$len_code_text; i++ )); do

	## designate key line number from key_file;
	## to encrypt every next character in the code_text
	## we use a next line from the keyfile
	## the key_line_num we need from the key_file is
	## the current character number in the code_text
	## modulo key_lines plus one
	key_line_num=$(( i % key_lines + 1 ))  ## sed can't have 0p

	## get code char (line,col from code_text)
	current_code_char=${code_text:$i-1:1}  ## threshold for ${x:0:1} form is 0

	#set -f  ## prevent globbing in substring (i.e. when char is '*')
	key_col_no_corr=$(printf '%s' "$otp_session_key" | cut -d "$current_code_char" -f 1 | wc -c)
	key_col=$(( key_col_no_corr - 1 ))

	## current crypt line is key_line_num in key_file
	current_crypt_line=$(sed -n ${key_line_num}p $key_file)

	## get crypt_char (line,col from key_file)
	current_crypt_char=${current_crypt_line:key_col:1}

	## write current crypt char to cipher_text
	cipher_text="${cipher_text}$current_crypt_char"

    done
}


decrypt()
{
    ## > decrypt (decr): input = cipher_text > code_text > plain_text = output
    ## >                         ^^^^^^^^^^^^^^^^^^^^^^^

    key_lines=$(wc -l "$key_file" | awk '{print $1}')  ## TODO DEV !! "$key_file" not in encrypt
    session_key='1'
    otp_session_key=$(sed -n ${session_key}p "$key_file")  ## TODO DEV !! "$key_file" not in encrypt

    ## cipher_text is the encrypted code text
    len_ciph_text=$(printf '%s' "$cipher_text" | wc -c)

    code_text=''

    for (( i=1; i<=$len_ciph_text; i++ )); do

	## designate key line number from key_file;
	## to decrypt every next character in the ciph_text
	## we use a next line from the keyfile
	## the key_line_num we need from the key_file is
	## the current character number in the code_text
	## modulo key_lines plus one
	key_line_num=$(( i % key_lines + 1 ))  ## sed can't have 0p

	## get decrypt_char (line,col from cipher_text)
	current_cipher_char=${cipher_text:$i-1:1}  ## threshold for ${x:0:1} form is 0

	## current decrypt line is key_line_num in key_file
	current_decrypt_line=$(sed -n ${key_line_num}p $key_file)

	## ? TODO DEV designate col in decrypt line
	#set -f  ## prevent globbing in substring (i.e. when char is '*')
	key_col_no_corr=$(printf '%s' "$current_decrypt_line" | cut -d "$current_cipher_char" -f 1 | wc -c)
	key_col=$(( key_col_no_corr - 1 ))

	## get current code char from key_col in session_key
	current_code_char=${otp_session_key:key_col:1}
	# TODO key_col=$(printf '%s' "$current_decrypt_line" | cut -d "$current_cipher_char" -f 1 | wc -c)
	# TODO current_code_char=${otp_session_key:key_col-1:1}

	## write current code char to code_text
	code_text="${code_text}$current_code_char"

    done
}


output()
{
    ## replace EOL <<< with '\n'
    #output_text=${output_text//<<</'\n'}

    if [[ -n $out_file ]]; then

	## no '%s\n' here
	printf '%s' "$output" > $out_file

    else

	case $action in

	    encrypt )
		## > output (encr): input = plain_text > code_text > cipher_text = output
		## >                                                 ^^^^^^^^^^^^^^^^^^^^
		output="$cipher_text"
		printf '%s' "$output"
		;;

	    decrypt )
		## > output (decr): input = cipher_text > code_text > plain_text = output
		## >                                                  ^^^^^^^^^^^^^^^^^^^
		output="$plain_text"
		printf '%s' "$output"
		;;

	esac

	echo

    fi
}


main()
{
    getargs $args
    verify_args
    input
    run_action
    output
}

main
