#! /usr/bin/env sh

###
###        _         ___  ____
###   ___ | |_ _ __ / _ \| ___|
###  / _ \| __| '_ \ (_) |___ \
### | (_) | |_| |_) \__, |___) |
###  \___/ \__| .__/  /_/|____/
###           |_|
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
otp95
one time pad encryptor
copyright (c) 2024  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
  keyfile

# usage
  ## encryption
  % otp95 [e] [key $keyfile] [out $outfile] [in $infile] [plain text]

  ## decryption
  % otp95 d [key $keyfile] [out $outfile] [in $infile] ['cipher_text']

  WARNING keyfiles must be kept secret at all times!!

  SPECIFIC NOTICE
  	   for decryption subcommand d is compulsory
  	   commandline text input (not recommended) must be quoted

  GENERAL NOTICE
  	  commandline text input, although possible, is not recommended
	  commandline text input must always be the last argument
 	  keyfile needs a minimum of 2 lines (at least 96 recommended)
	  keyfile lines should be randomly ordered
	  keyfile can be generated from $ASCII


# '


#set -o errexit
#set -o nounset
set -o pipefail


# initial definitions

## script
script_name='otp95'
developer='oxo'
license='gplv3'
initial_release='2024'

## arguments
### static variables
#### these do not change throughout script session
args="$@"
key_dir="$XDG_DATA_HOME/c/keys/otp95"
### dynamic variables
timestamp="$(date +'%Y%m%d_%H%M%S_%s')"


getargs()
{
    while true; do

	case "$1" in

	    d | -d | --decr )
		action='decrypt'
		shift
		;;

	    e | -e | --encr )
		action='encrypt'
		shift
		;;

	    key | --key | --key-file )
		shift
		key_file=$1
		shift
		;;

	    'in' | --in | --in-file )
		shift
		in_file=$1
		shift
		;;

	    'out' | --out | --out-file )
		shift
		out_file=$1
		shift
		;;

	    -- )
		shift
		[[ -z $in_file ]] && text=$@
		break
		;;

	    * )
		## default action is encrypt to stdout
		[[ -z $action ]] && action='encrypt'
		text=$@
		return
		;;

	esac

    done
}


verify_args()
{
    ## text
    if [[ -z $text ]]; then

	text="$in_file"

	if [[ -z $in_file ]]; then

	    read_text

	fi

    fi

    ## keyfile
    if [[ -z $key_file ]]; then

	## use default keyfile (not recommended)
	#: '
	key_file="$key_dir/keyfile"
	# '

	## generate keyfile (recommended)
	: '
	key_file="${key_dir}/${timestamp}_keyfile"

	for i in {1..95}; do

	    printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'
	    echo

	done > $key_file

	## keyfile file mode: user rw
	chmod 600 $key_file

	printf 'NOTICE generated keyfile: %s\n' "$key_file"
	printf 'WARNING keyfiles must be kept secret at all times!!\n'
	# '

    fi
}



read_text()
{
    text=$(cat)

    ## replace '\n' with <EOL>
    text=${text//$'\n'/<EOL>}

    echo
}


run_action()
{
    case $action in

	encrypt)
	    encrypt
	    ;;

	decrypt)
	    decrypt
	    ;;

    esac
}


encrypt()
{
    plain_text="$text"
    len_pt=$(printf '%s' "$plain_text" | wc -c)

    key_lines=$(wc -l $key_file | awk '{print $1}')
    session_key='1'
    otp_session_key=$(sed -n ${session_key}p $key_file)

    output_text=''

    for (( i=1; i<=$len_pt; i++ )); do

	## designate key row from key_file
	key_row=$(( i % key_lines + 1 ))  ## sed can't have 0p

	## designate encrypt col
	current_plain_char=${plain_text:$i-1:1}  ## threshold for ${x:0:1} form is 0

	set -f  ## prevent globbing in substring (i.e. when char is '*')
	key_col_no_corr=$(printf '%s' "$otp_session_key" | cut -d "$current_plain_char" -f 1 | wc -c)
	key_col=$(( key_col_no_corr - 1 ))

	## get crypt_char (row col from key_file)
	current_crypt_row=$(sed -n ${key_row}p $key_file)
	current_crypt_char=${current_crypt_row:key_col:1}

	output_text="${output_text}$current_crypt_char"

    done
}


decrypt()
{
    cipher_text="$text"
    len_ct=$(printf '%s' "$cipher_text" | wc -c)

    key_lines=$(wc -l "$key_file" | awk '{print $1}')
    session_key='1'
    otp_session_key=$(sed -n ${session_key}p "$key_file")

    output_text=''

    for (( i=1; i<=$len_ct; i++ )); do

	## designate key row from key_file
	key_row=$(( i % key_lines + 1 ))  ## sed can't have 0p

	## designate decrypt row
	current_cipher_char=${cipher_text:$i-1:1}  ## threshold for ${x:0:1} form is 0
	current_decrypt_row=$(sed -n ${key_row}p $key_file)

	## designate decrypt col
	set -f  ## prevent globbing in substring (i.e. when char is '*')
	key_col_no_corr=$(printf '%s' "$current_decrypt_row" | cut -d "$current_cipher_char" -f 1 | wc -c)
	key_col=$(( key_col_no_corr - 1 ))

	## get plain char (row col from key_file)
	current_plain_char=${otp_session_key:key_col:1}

	output_text="${output_text}$current_plain_char"

    done
}


output_to()
{
    ## replace <EOL> with '\n'
    output_text=${output_text//<EOL>/'\n'}

    if [[ -n $out_file ]]; then

	## no '%s\n' here
	printf "$output_text" > $out_file

    else

	printf "$output_text"
	echo

    fi
}


main()
{
    getargs $args
    verify_args
    run_action
    output_to
}

main
