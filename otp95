#! /usr/bin/env sh

###
###        _         ___  ____
###   ___ | |_ _ __ / _ \| ___|
###  / _ \| __| '_ \ (_) |___ \
### | (_) | |_| |_) \__, |___) |
###  \___/ \__| .__/  /_/|____/
###           |_|
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
otp95
one-time pad cryptor
copyright (c) 2024  |  oxo

GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org


# dependencies
  keyfile

# usage
  ## encryption
  % otp95 [e] [key $keyfile] [out $outfile] [in $infile] [plain text]

  ## decryption
  % otp95 d [key $keyfile] [out $outfile] [in $infile] ['cipher_text']

  WARNING keyfiles must be kept secret at all times!!

  SPECIFIC NOTICE
  	   for decryption subcommand d is compulsory
  	   commandline text input (not recommended) must be quoted

  GENERAL NOTICE
  	  commandline text input, although possible, is not recommended
	  commandline text input must always be the last argument
 	  keyfile needs a minimum of 2 lines (at least 96 recommended)
	  keyfile lines should be randomly ordered
	  keyfile can be generated from $ASCII

  TECHNICAL NOTICE
	  ## > encryption: input = plain_text > code_text > cipher_text = output
	  ## > decryption: input = cipher_text > code_text > plain_text = output

# '

# cat /home/oxo/c/git/code/tool/otp95 | grep -A 1 --line-number '(encr)'
# cat /home/oxo/c/git/code/tool/otp95 | grep -A 1 --line-number '(decr)'


set -o errexit
#set -o nounset
set -o pipefail


# initial definitions

## script
script_name='otp95'
developer='oxo'
license='gplv3'
initial_release='2024'

## arguments
### static variables
#### these do not change throughout script session
args="$@"
session_key_line='1'  ## line that contains session key
key_dir="$XDG_DATA_HOME/c/keys/otp95"
### dynamic variables
timestamp="$(date +'%Y%m%d_%H%M%S_%s')"


getargs()
{
    while true; do

	case "$1" in

	    d | -d | --decr )
		action='decrypt'
		shift
		;;

	    e | -e | --encr )
		action='encrypt'
		shift
		;;

	    key | --key | --key-file )
		shift
		key_file=$1
		shift
		;;

	    keyo | -o | --key-options )
		shift
		key_options=$1
		shift
		;;

	    keyl | --key-line | --session-key )
		shift
		session_key_line=$1
		shift
		;;

	    'in' | --in | --in-file )
		shift
		in_file=$1
		shift
		;;

	    'out' | --out | --out-file )
		shift
		out_file=$1
		shift
		;;

	    -- )
		shift
		[[ -z $in_file ]] && input=$@
		return
		;;

	    * )
		input=$@
		return
		;;

	esac

    done
}


verify_args()
{
    ## action
    ## default action is encrypt to stdout
    [[ -z $action ]] && action='encrypt'

    ## input
    if [[ -z $input ]]; then

	if [[ -n $in_file ]]; then

	    input=$(cat $in_file)

	else

	    read_input

	fi

    fi


    ## keyfile
    if [[ -z $key_file ]]; then

	## use default keyfile (not recommended)
	#: '
	key_file="$key_dir/keyfile"
	# '

	## generate keyfile (recommended)
	: '
	key_file="${key_dir}/${timestamp}_keyfile"

	for i in {1..95}; do

	    printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'
	    echo

	done > $key_file

	## keyfile file mode: user rw
	chmod 600 $key_file

	printf 'NOTICE generated keyfile: %s\n' "$key_file"
	printf 'WARNING keyfiles must be kept secret at all times!!\n'
	# '

    fi
    key_file_mem=$(cat "$key_file")


    ## make session key line modulo key_lines
    ## total number of lines in key_file
    key_lines=$(wc -l "$key_file" | awk '{print $1}')
    session_key_line=$(( session_key_line % key_lines ))


    ## keyfile modification options
    ## multiple options come in a comma separated list
    ## CAUTION DEV options are still in beta
    for option in ${key_options//,/ }; do

	case $option in

	    tac )
		## get session key data
		session_key=$(sed -n ${session_key_line}p "$key_file")

		## encode session key data
		session_key_enc=$(base64 --wrap 0 <<< "$session_key")

		## reverse all lines in keyfile (tac)
		#key_file_tac=$(tac $key_file)
		#####key_file=${key_dir}/${timestamp}_keyfile

		### the \n in printf is important for proper tac function
		#####printf '%s\n' "$key_file_tac" > $key_file

		### encode tac reversed keyfile
		### CAUTION DEV no --wrap0 here!
		#key_file_tac_enc=$(base64 <<< "$key_file_tac")

		### remove session key from tac enc
		#key_file_rem_enc=$(grep -v "$session_key_enc" <<< $key_file_tac_enc)

		### insert session key enc on session_key_line in key_file_rem_enc
		#key_file_rep_enc=$(sed "${session_key_line}i $session_key_enc" <<< $key_file_rem_enc)

		### decode repaired keyfile
		#key_file_rep=$(base64 --wrap 0 --decode <<< "$key_file_rep_enc")

		### delete last line from key_file_rep
		#key_file_rep_del=$(sed '$d' <<< $key_file_rep)

		key_file_mem=$(tac "$key_file" \
				   | base64 \
				   | grep -v "$session_key_enc" \
				   | sed "${session_key_line}i $session_key_enc" \
				   | base64 --wrap 0 --decode \
				   | sed '$d'\
			    )

		### write repaired keyfile to file
		#printf '%s\n' "$key_file_mem" > $key_file
		;;

	    rev )
		## get session key data
		session_key=$(sed -n ${session_key_line}p "$key_file")
		rev_session_key=$(printf '%s' "$session_key" | rev)

		## encode session key data
		session_key_enc=$(base64 --wrap 0 <<< "$session_key")
		rev_session_key_enc=$(base64 --wrap 0 <<< "$rev_session_key")

		## reverse all lines in keyfile characterwise (rev)
		key_file_rev=$(rev $key_file)
		####key_file=${key_dir}/${timestamp}_keyfile
		## the \n in printf is important for proper tac function
		####printf '%s\n' "$key_file_rev" > $key_file

		## encode reversed keyfile
		key_file_rev_enc=$(base64 --wrap 0 <<< "$key_file_rev")

		## replace encoded rev session key with encoded session key
		key_file_rep_enc=${key_file_rev_enc//$rev_session_key_enc/$session_key_enc}

		## decode repaired reversed keyfile
		key_file_rep=$(base64 --decode --wrap 0 <<< "$key_file_rep_enc")

		## write repaired reversed keyfile to file
		printf '%s\n' "$key_file_rep" > $key_file
		;;

	    sort )
		printf 'DEV226 sort %s\n' "$key_file"
		ls -ila $key_file
		sort "$key_file" > "${key_dir}/${timestamp}_keyfile"
		key_file="${key_dir}/${timestamp}_keyfile"
		printf 'DEV229 sort %s\n' "$key_file"
		ls -ila $key_file
		;;

	    * )
		## integer as option will be read as a session key
		## if skey is given the option value will be added
		[[ $option =~ ^[0-9]+$ ]] && \
		    session_key_line=$(( session_key_line + option ))
		;;

	esac

    done
}



read_input()
{
    ## user can input multiple lines and ends with an end of transmission
    ## EOT (U+0004, ^D or C-d)
    input=$(cat)
    echo
}


input()
{
    case $action in

	encrypt )
	    ## > input (encr): input = plain_text > code_text > cipher_text = output
	    ## >               ^^^^^^^^^^^^^^^^^^
	    plain_text="$input"
	    ;;

	decrypt )
	    ## > input (decr): input = cipher_text > code_text > plain_text = output
	    ## >               ^^^^^^^^^^^^^^^^^^^
	    cipher_text="$input"
	    ;;

    esac
}


transcode()
{
    case $action in

	encrypt )
	    ## > encode (encr): input = plain_text > code_text > cipher_text = output
	    ## >                        ^^^^^^^^^^^^^^^^^^^^^^

	    code_text=$(base64 --wrap 0 <<< "$plain_text")
	    ;;

	decrypt )
	    ## > decode (decr): input = cipher_text > code_text > plain_text = output
	    ## >                                      ^^^^^^^^^^^^^^^^^^^^^^

	    plain_text=$(base64 --decode <<< "$code_text")
	    ;;

    esac
}


run_action()
{
    case $action in

	encrypt)
	    transcode
	    encrypt
	    ;;

	decrypt)
	    decrypt
	    transcode
	    ;;

    esac
}


encrypt()
{
    ## > encrypt (encr): input = plain_text > code_text > cipher_text = output
    ## >                                      ^^^^^^^^^^^^^^^^^^^^^^^

    ## get the otp session key
    session_key=$(sed -n ${session_key_line}p <<< $key_file_mem)
    ####session_key=$(sed -n ${session_key_line}p "$key_file")

    ## code text is the encoded plain text
    len_code_text=$(printf '%s' "$code_text" | wc -c)

    cipher_text=''

    for (( i=1; i<=$len_code_text; i++ )); do

	## designate key line number from key_file;
	## to encrypt every next character in the code_text
	## we use a next line from the keyfile
	## the key_line_num we need from the key_file is
	## the current character number in the code_text
	## modulo key_lines plus one
	key_line_num_no_corr=$(( i % key_lines ))  ## sed can't have 0p
	key_line_num=$(( key_line_num_no_corr + 1 ))

	## get code char (line,col from code_text)
	current_code_char=${code_text:$i-1:1}  ## threshold for ${x:0:1} form is 0

	## get key column
	key_col_no_corr=$(printf '%s' "$session_key" | cut -d "$current_code_char" -f 1 | wc -c)
	key_col=$(( key_col_no_corr - 1 ))

	## current crypt line is key_line_num in key_file
	current_crypt_line=$(sed -n ${key_line_num}p <<< "$key_file_mem")
	#current_crypt_line=$(sed -n ${key_line_num}p $key_file)

	## get crypt_char (line,col from key_file)
	current_crypt_char=${current_crypt_line:key_col:1}

	## write current crypt char to cipher_text
	cipher_text="${cipher_text}$current_crypt_char"

    done
}


decrypt()
{
    ## > decrypt (decr): input = cipher_text > code_text > plain_text = output
    ## >                         ^^^^^^^^^^^^^^^^^^^^^^^

    ## get the otp session key
    session_key=$(sed -n ${session_key_line}p <<< $key_file_mem)
    ####session_key=$(sed -n ${session_key_line}p "$key_file")

    ## cipher_text is the encrypted code text
    len_ciph_text=$(printf '%s' "$cipher_text" | wc -c)

    code_text=''

    for (( i=1; i<=$len_ciph_text; i++ )); do

	## designate key line number from key_file;
	## to decrypt every next character in the ciph_text
	## we use a next line from the keyfile
	## the key_line_num we need from the key_file is
	## the current character number in the code_text
	## modulo key_lines plus one
	key_line_num_no_corr=$(( i % key_lines ))  ## sed can't have 0p
	key_line_num=$(( key_line_num_no_corr + 1 ))

	## get decrypt_char (line,col from cipher_text)
	current_cipher_char=${cipher_text:$i-1:1}  ## threshold for ${x:0:1} form is 0

	## current decrypt line is key_line_num in key_file
	current_decrypt_line=$(sed -n ${key_line_num}p $key_file)

	## get key column
	key_col_no_corr=$(printf '%s' "$current_decrypt_line" | cut -d "$current_cipher_char" -f 1 | wc -c)
	key_col=$(( key_col_no_corr - 1 ))

	## get current code char from key_col in session_key
	current_code_char=${session_key:key_col:1}

	## write current code char to code_text
	code_text="${code_text}$current_code_char"

    done
}


output()
{
    ## > output (encr): input = plain_text > code_text > cipher_text = output
    ## >                                                 ^^^^^^^^^^^^^^^^^^^^

    ## > output (decr): input = cipher_text > code_text > plain_text = output
    ## >                                                  ^^^^^^^^^^^^^^^^^^^

    [[ $action == 'encrypt' ]] && output="$cipher_text"
    [[ $action == 'decrypt' ]] && output="$plain_text"

    if [[ -n "$out_file" ]]; then

	case $out_file in

	    copy | wl-copy | clipboard )
		## output to clipboard
		printf '%s\n' "$output" | wl-copy
		;;

	    * )
		## output to file
		printf '%s\n' "$output" > "$out_file"
		;;

	esac

    else

	## output to stdout
	printf '%s\n' "$output"

    fi
}


main()
{
    getargs $args
    verify_args
    input
    run_action
    output
}

main
