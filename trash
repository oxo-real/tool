#!/usr/bin/env sh
#
##
###  _                 _
### | |_ _ __ __ _ ___| |__
### | __| '__/ _` / __| '_ \
### | |_| | | (_| \__ \ | | |
###  \__|_|  \__,_|___/_| |_|
###  _    _
### (_)><(_)
###
### trash
### remove files to an intermediate location
### copyright (c) 2020 - 2023  |  oxo
###
### usage:
### actions:
###             trash [-options] $filepath
###		trash rm|empty|clear
### information:
###		trash
###		trash info|status (more info; requires sudo privileges)
###		trash size (only size)
###		trash ls
###
### recommended:	alias rm="trash"
###
##
#

### known issues: trash /file_under_root
###  is being moved to /file_under_root_$epoch
###  plus: source as sudo has sudos xdg_data_home

# items to trash array
items=( "$@" )
epoch="$(date +%s)"

source $XDG_DATA_HOME/c/git/code/source/function/text_appearance


reset_sudo() {

    sudo -k
}


define_trashcan() {

    # prevent trash ending up in root
    if [[ -n "$XDG_CACHE_HOME" ]]; then

	# definition of a trashcan
	trash="$XDG_CACHE_HOME/trash"
	[[ -d $trash ]] || mkdir -p $trash
	[[ "$TRASHDIR" != "$trash" ]] && exit 44

    fi
}


process_args_array() {

    ## rm is aliased to trash
    ## if rm options are given (in $1)
    ## (i.e. -rf); then skip these
    ## and move the following items to trash

    ## if there is more than one argument given
    ## i.e. when 'rm -rf directory' is entered then
    ## argument1 = '-rf' and argument2 = 'directory'
    ## the arguments become elements in the array
    ## first argument is items[0] in the array

    ## check if first argument starts with an '-',
    ## then it's probably meant as an option for rm

    ## if there is more than one element in the array
    if [[ "${#items[@]}" -gt 1 ]]; then

	## set elem1
	## printf -- to prevent taking items[0] as printf argument
	elem1="$(printf -- "${items[0]}")"

	## elem1 starts with a dash
	if [[ "$(printf -- "$elem1" | head -c 1)" == "-" ]]; then

	    ## elem1 is no existing file
	    [[ ! -f "$elem1" ]] && \
		## elem1 is no existing directory
		[[ ! -d "$elem1" ]] && \
		    ## elem1 is no existing symlink
		[[ ! -L "$elem1" ]] && \
		    ## then: remove elem1 which is only meant as flag for rm
		rm_flag="${items[0]}"

	    #unset 'items[0]'
	    items=("${items[@]:1}")

	fi

    ## if there is one element in the array
    elif [[ "${#items[@]}" -eq 1 ]]; then

	## rm is aliased to trash
	## we cannot see which command invoked trash
	## because $0 gives back 'trash' also when rm was used
	## so if 'trash empty' is invoked we trigger
	## on the element with value 'empty':
	if [[ "${items[0]}" == "empty" ]] || \
	       [[ "${items[0]}" == "clear" ]] || \
	       [[ "${items[0]}" == "rm" ]]; then

	    trash_empty

	elif [[ "${items[0]}" == "size" ]]; then

	    ## no sudo privileges needed
	    trash_size
	    report_size
	    exit 0

	elif [[ "${items[0]}" == "info" ]] || \
	       [[ "${items[0]}" == "status" ]]; then

	    trash_size
	    report_size
	    ## sudo privileges needed
	    trash_info
	    report_info
	    exit 0

	elif [[ "${items[0]}" == "ls" ]]; then

	    trash_size
	    report_size
	    trash_ls
	    exit 0

	fi

    else

	# no arguments given
	trash_size
	report_size

    fi
}


correct_real_dest() {

    # navigated outside of trash directory

    char=0
    chars=$(printf "$real_dest" | wc -c)

    # get chars from real_dest
    for (( i=1; i<=$chars; i++ )); do

	real_dest_char=$(echo ${real_dest:$i:1})
	trash_char=$(echo ${trash:$i:1})

	# from the char that real_dest and trash differ:
	if [[ $real_dest_char != $trash_char ]]; then

	    # correct real_dest
	    real_dest_corr=$(echo ${trash}/${real_dest:$i})

	    real_dest=$real_dest_corr

	    break

	fi

    done
}


process_arguments() {

    for item in "${items[@]}"; do

	cannot_remove_myself

	# skip non existent items
	[[ ! -f $item ]] && [[ ! -d $item ]] && \
	    printf "$item not found\n" && \
	    continue

	# define dest
	dest=$(printf "$trash/$item")

	# remove possible // from dest
	dest=$(printf "$dest" | sed 's/\/\//\//')

	# remove whitespaces
	# cannot be done in this script, because separator is space
	# see catalog under the find command to recursively replace
	# file whitespaces with underscores

	# make temp_dest for realpath to work
	# TODO: this is not so nice...
	if [[ -n $(echo $item | grep '/') ]]; then

	    temp_dest=$dest
	    [[ ! -d $temp_dest ]] && [[ ! -f $temp_dest ]] && \
		mkdir -p $temp_dest && \
		temp_dest_exists=1

	fi

	# define real_dest
	real_dest=$(realpath $dest)

	if [[ $real_dest != $trash* ]]; then

	    correct_real_dest

	fi

	# redefine dest
	dest=$real_dest

	# remove temp_dest if it exists
	[[ -n $temp_dest_exists ]] && rmdir $temp_dest

	# check if item is already file or directory in $trash
	if [[ -f "$dest" ]] || [[ -d "$dest" ]]; then

	    # dest + epoch
	    dest="${dest}_$epoch"

	fi

	trash_now

    done
}


cannot_remove_myself() {

    # error if:
    # $item is a directory and
    # $PWD is inside or under the to be removed directory $item
    rp_item=$(realpath $item)
    rp_pwd=$(realpath $PWD)

    [[ -d $item ]] && \

	case $rp_pwd/ in

	    $rp_item/*)
		printf "${MAGENTA}%s${NOC} is a parent directory" "$item"
		exit 52
		;;

	    *)
		continue
		;;

	esac
}

trash_info() {

    dirs=$(sudo fd . -t d -u $trash | wc -l)
    #dirs=$(sudo find $XDG_CACHE_HOME/trash -type d | wc -l)
    files=$(sudo fd . -t f -u $trash | wc -l)
    size=$(sudo du -sh $trash | awk '{print $1}')
}

report_info() {

    printf "%s; %s dirs %s files ${BLUE}%s${NOC}\n" $trash $dirs $files $size
}

trash_size() {

    size=$(du -sh $trash 2>/dev/null | awk '{print $1}')
}

report_size() {

    printf "%s ${BLUE}%s${NOC}\n" $trash $size
}

trash_ls() {

    ls -ila $trash
}

trash_empty() {

    ## empty trashcan
    trash_size
    \rm -rf $trash/{*,.*} && \
	printf "trash cleared; %s dirs %s files ${BLUE}%s${NOC}\n" $trash $dirs $files $size && \
	exit 0
}


trash_now() {

    mv -f -- "$item" $dest
}


main() {

    reset_sudo
    define_trashcan
    process_args_array
    process_arguments
}

main
