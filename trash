#!/bin/sh
#
##
###  _                 _
### | |_ _ __ __ _ ___| |__
### | __| '__/ _` / __| '_ \
### | |_| | | (_| \__ \ | | |
###  \__|_|  \__,_|___/_| |_|
###  _    _
### (_)><(_)
###
### trash
### remove files to an intermediate location
### copyright (c) 2020 - 2023  |  oxo
###
### recommendation:	alias rm="trash"
###
### usage:	rm [-options] <location>
###		trash empty
###		trash size
###		trash
##
#


# items to trash array
items=( "$@" )
epoch="$(date +%s)"


reset_sudo() {

    sudo -k
}


define_trashcan() {

    # prevent trash ending up in root
    if [[ -n "$XDG_CACHE_HOME" ]]; then

	# definition of a trashcan
	trash="$XDG_CACHE_HOME/trash"
	[[ -d $trash ]] || mkdir -p $trash

    fi
}


process_args_array() {

    ## rm is aliased to trash
    ## if rm options are given (in $1)
    ## (i.e. -rf); then skip these
    ## and move the following items to trash

    ## if there is more than one argument given
    ## i.e. when 'rm -rf directory' is entered then
    ## argument1 = '-rf' and argument2 = 'directory'
    ## the arguments become elements in the array
    ## first argument is items[0] in the array

    ## check if first argument starts with an '-',
    ## then it's probably meant as an option for rm

    ## if there is more than one element in the array
    if [[ "${#items[@]}" -gt 1 ]]; then

	## set elem1
	## printf -- to prevent taking items[0] as printf argument
	elem1="$(printf -- "${items[0]}")"

	## elem1 starts with a dash
	if [[ "$(printf -- "$elem1" | head -c 1)" == "-" ]]; then

	    ## elem1 is no existing file
	    [[ ! -f "$elem1" ]] && \
		## elem1 is no existing directory
		[[ ! -d "$elem1" ]] && \
		    ## elem1 is no existing symlink
		[[ ! -L "$elem1" ]] && \
		    ## then: remove elem1 which is only meant as flag for rm
		rm_flag="${items[0]}"

	    #unset 'items[0]'
	    items=("${items[@]:1}")

	fi

    ## if there is one element in the array
    elif [[ "${#items[@]}" -eq 1 ]]; then

	## rm is aliased to trash
	## we cannot see which command invoked trash
	## because $0 gives back 'trash' also when rm was used
	## so if 'trash empty' is invoked we trigger
	## on the element with value 'empty':
	if [[ "${items[0]}" == "empty" ]] || \
	       [[ "${items[0]}" == "clear" ]]; then

	    trash_empty

	elif [[ "${items[0]}" == "size" ]]; then

	    trash_size
	    printf "trash; $dirs dirs, $files files, $size\n"
	    exit 0

	fi

    else

	# no arguments given
	size=$(du -sh $XDG_CACHE_HOME/trash 2>/dev/null | awk '{print $1}')
	printf "$trash $size\n"

    fi
}


correct_real_dest() {

    # navigated outside of trash directory

    char=0
    chars=$(printf "$real_dest" | wc -c)

    # get chars from real_dest
    for (( i=1; i<=$chars; i++ )); do

	real_dest_char=$(echo ${real_dest:$i:1})
	trash_char=$(echo ${trash:$i:1})

	# from the char that real_dest and trash differ:
	if [[ $real_dest_char != $trash_char ]]; then

	    # correct real_dest
	    real_dest_corr=$(echo ${trash}/${real_dest:$i})

	    real_dest=$real_dest_corr

	    break

	fi

    done
}


process_arguments() {

    for item in "${items[@]}"; do

	# skip non existent items
	[[ ! -f $item ]] && [[ ! -d $item ]] && \
	    printf "$item not found\n" && \
	    continue

	# define dest
	dest=$(printf "$trash/$item")

	# remove possible // from dest
	dest=$(printf "$dest" | sed 's/\/\//\//')

	# remove whitespaces
	# cannot be done in this script, because separator is space
	# see catalog under the find command to recursively replace
	# file whitespaces with underscores

	# make temp_dest for realpath to work
	# TODO: this is not so nice...
	if [[ -n $(echo $item | grep '/') ]]; then

	    temp_dest=$dest
	    [[ ! -d $temp_dest ]] && [[ ! -f $temp_dest ]] && \
		mkdir -p $temp_dest && \
		temp_dest_exists=1

	fi

	# define real_dest
	real_dest=$(realpath $dest)

	if [[ $real_dest != $trash* ]]; then

	    correct_real_dest

	fi

	# redefine dest
	dest=$real_dest

	# remove temp_dest if it exists
	[[ -n $temp_dest_exists ]] && rmdir $temp_dest

	# check if item is already file or directory in $trash
	if [[ -f "$dest" ]] || [[ -d "$dest" ]]; then

	    # dest + epoch
	    dest="${dest}_$epoch"

	fi

	trash_now

    done
}


trash_size() {

    dirs=$(sudo fd -t d -u $XDG_CACHE_HOME/trash | wc -l)
    #dirs=$(sudo find $XDG_CACHE_HOME/trash -type d | wc -l)
    files=$(sudo fd -t f -u $XDG_CACHE_HOME/trash | wc -l)
    size=$(sudo du -sh $XDG_CACHE_HOME/trash | awk '{print $1}')
}


trash_empty() {

    ## empty trashcan
    trash_size
    \rm -rf $trash/* && \
	printf "trash cleared; $dirs dirs, $files files, $size\n" && \
	exit 0
}


trash_now() {

    mv -f -- "$item" $dest
}


main() {

    reset_sudo
    define_trashcan
    process_args_array
    process_arguments
}

main
