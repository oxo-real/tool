#! /usr/bin/env sh

## input: key (bin)
## output: expanded keys (bin)

## usage: key-expansion.sh key.bin
## or: echo $key | key-expansion.sh

# words_arr=()
# declare -A words_arr
# typeset -A words_arr
## TODO DEV why does this not work?
## LEARN always initalize array in global scope (main body)
## (not inside functions)

working_dir=/home/oxo/.local/share/c/git/code/tool/dev/aes
source "$working_dir"/rcon.sh
source "$working_dir"/sbox.sh
typeset -A word_arr

args="$@"
getargs ()
{
    while :; do

	case "$1" in

	    '' )
		break
		;;

	    --hex-key )
		key_format=hex
		shift
		:
		;;

	    --asc-key )
		key_format=asc
		shift
		:
		;;

	    --bin-key )
		key_format=bin
		shift
		:
		;;

	    * )
		## default key_format if not specified
		[[ -n "key_format" ]] || key_format=bin

		## NOTICE arg can be a file
		if [[ -f "$1" ]]; then

		    ## file content is read
		    input_arg=$(cat "$1")
		    shift

		else

		    ## argument is read
		    input_arg="$1"
		    shift

		fi
		;;

	esac

    done
}


getstdin ()
{
    if [[ -p /dev/stdin ]]; then

	input_stdin=$(cat)

    fi
}


synth_input ()
{
    ## stdin and arg are synthesized
    # key_input=$(tr -d '\n' <<< "${input_stdin}${input_arg}")
    key_input=${input_stdin}${input_arg}
}


key_analysis ()
{
    ## key format
    ## make hexadecimal or ascii keys binary
    case "$key_format" in

	asc )
	    key_bin=$(printf '%s' "$key_input" | sh c-asc-bin.sh)
	    ;;

	hex )
	    key_bin=$(printf '%s' "$key_input" | sh c-hex-bin.sh)
	    ;;

	* )
	    key_bin="$key_input"

    esac

    # key binary length
    key_bin_l=${#key_bin}

    case $key_bin_l in

	128 )
	    key_bytes=16
	    cols=4
	    col_l=8
	    rounds=11
	    rows=4
	    ;;

	192 )
	    key_bytes=24
	    cols=6
	    col_l=8
	    rounds=13
	    rows=4
	    ;;

	256 )
	    key_bytes=32
	    cols=8
	    col_l=8
	    rounds=15
	    rows=4
	    ;;

	* )
	    exit 136
	    ;;

    esac

    ## round 0
    ## copy 4 words from key_bin and adds them to word_arr
    ## word_arr[0,0] to word_arr[3,15]
    add_to_word_arr 0 $key_bin
}


create_state_array ()
{
    index=0

    ## array fills first columns then rows
    for (( col=0; col<"${cols}"; col++ )); do

	for (( row=0; row<"${rows}"; row++ )); do

            state_in_bin_arr[$row,$col]="${state_in:$(( index * $col_l )):$col_l}"

	    ((index++))

	done

    done
}


convert_bin_cells_to_hex ()
{
    for cell in "${!state_in_bin_arr[@]}"; do
	## for every cell (key) in the associative array

	## get the binary value
	cell_value_bin=${state_in_bin_arr[$cell]}

	## convert bin to hex value
	cell_value_hex=$(echo "obase=16; ibase=2; $cell_value_bin" | bc)

	## populate state_in_arr_hex
	state_in_hex_arr[$cell]=0x$cell_value_hex

    done
}


add_to_word_arr ()
{
    ## input
    round=$1
    key_value=$2

    ## output adds 32 bit words to a word_array [word_id]=word_value

    ## a (sub-)key consists of 128/192/256 bits (16/24/32 bytes)
    ## a (sub-)key holds 4 32 bit long words (w0, w1, ...)
    words=$(( rounds * 4 ))

    ## first four words: w0, w1, w2, w3 (same as key_bin)
    for (( word_id=0; word_id<"${words}"; word_id++ )); do

	## Calculate the starting index for the byte
	bit_start=$((word_id * 32))
	# Extract the byte (8 bits)
	word_value=${key_bin:bit_start:32}

	## store the word in the associative array
	if [[ -n "$word_value" ]]; then

	    word_arr[$word_id]="$word_value"

	else

	    break

	fi

    done

    #DEV
    printf "DEV$LINENO %s\n" "${round}"
    pea word_arr | sort --numeric-sort
}


pea () { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}"; done } #DEV


g_function ()
{
    ## input: first and last word of previous round
    ## output: first word of current round
    rotate_bits=8
    word_value=$1

    ## left rotate last word
    left_rotate $rotate_bits $word_value
printf "DEV$LINENO %s\n" "${word_rotated}"

    ## substitute word
    substitute $word_rotated
printf "DEV$LINENO %s\n" "${word_substituted}"

    ## round constant
#TODO
}


left_rotate ()
{
    local rotate_bits=$1
    local word_value=$2

    ## perform left rotation
    word_rotated=${word_value:$rotate_bits}${word_value:0:$rotate_bits}
}


substitute ()
{
    ## take eight bits (byte) from input, substitute
    local word_rotated=$1
    local word_rotated_l=${#word_rotated}
    local byte=8

    for (( i=0; i<word_rotated_l; i+=byte )); do

	## get binary byte
        local substr_bin=${word_rotated:i:byte}

	## convert to hex
	local substr_hex=$(printf "%02x" "$(( 2#$substr_bin ))")

	## sbox lookup
	converted_hex=${s_box[$substr_hex]}
	converted_bin=$(echo "obase=02; ibase=16; $(echo $converted_hex | tr a-z A-Z)" | bc)
	local converted_bin=$(printf "%08d" "$converted_bin")

	word_substituted+=${converted_bin}

    done

}


key_expansion ()
{
    ## round > 0
    for (( round=1; round<"${rounds}"; round++ )); do

	## identify words of previous round (input for g-function)
	prev_round=$(( round - 1 ))
	first_word_pr=$(( prev_round * 4 ))
	last_word_pr=$(( prev_round * 4 + 3 ))

	## getting word values
	first_word_pr_value=${word_arr[$first_word_pr]}
	last_word_pr_value=${word_arr[$last_word_pr]}

	g_function ${first_word_pr_value} ${last_word_pr_value}

    done
}


output_matrix ()
{
    ## print all the subkey keys
    printf 'key %s\n' "$subkey"

    for (( row=0; row<"${rows}"; row++ )); do

	for (( col=0; col<"${cols}"; col++ )); do

            printf '%s ' "${words_arr[$row,$col]}"

	done

	echo

    done
}


main ()
{
    getstdin
    getargs $args
    synth_input
    key_analysis
    key_expansion
    output_matrix
}

main
