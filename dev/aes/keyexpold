#! /usr/bin/env sh

## input: key (bin)
## output: expanded keys (bin)

## usage: key-expansion.sh key.bin
## or: echo $key | key-expansion.sh

# words_arr=()
# declare -A words_arr
# typeset -A words_arr
## TODO DEV why does this not work?
## LEARN always initalize array in global scope (main body)
## (not inside functions)

source /home/oxo/.local/share/c/git/code/tool/dev/aes/rcon.sh
typeset -A word_arr

args="$@"
getargs ()
{
    while :; do

	case "$1" in

	    '' )
		break
		;;

	    --hex-key )
		key_format=hex
		shift
		:
		;;

	    --asc-key )
		key_format=asc
		shift
		:
		;;

	    --bin-key )
		key_format=bin
		shift
		:
		;;

	    * )
		## default key_format if not specified
		[[ -n "key_format" ]] || key_format=bin

		## NOTICE arg can be a file
		if [[ -f "$1" ]]; then

		    ## file content is read
		    input_arg=$(cat "$1")
		    shift

		else

		    ## argument is read
		    input_arg="$1"
		    shift

		fi
		;;

	esac

    done
}


getstdin ()
{
    if [[ -p /dev/stdin ]]; then

	input_stdin=$(cat)

    fi
}


synth_input ()
{
    ## stdin and arg are synthesized
    # key_input=$(tr -d '\n' <<< "${input_stdin}${input_arg}")
    key_input=${input_stdin}${input_arg}
}


key_analysis ()
{
    ## key format
    ## make hexadecimal or ascii keys binary
    case "$key_format" in

	asc )
	    key_bin=$(printf '%s' "$key_input" | sh c-asc-bin.sh)
	    ;;

	hex )
	    key_bin=$(printf '%s' "$key_input" | sh c-hex-bin.sh)
	    ;;

	* )
	    key_bin="$key_input"

    esac

    # key binary length
    key_bin_l=${#key_bin}

    case $key_bin_l in

	128 )
	    key_bytes=16
	    cols=4
	    col_l=8
	    rounds=11
	    rows=4
	    ;;

	192 )
	    key_bytes=24
	    cols=6
	    col_l=8
	    rounds=13
	    rows=4
	    ;;

	256 )
	    key_bytes=32
	    cols=8
	    col_l=8
	    rounds=15
	    rows=4
	    ;;

	* )
	    exit 136
	    ;;

    esac

    ## round 0
    ## copy 4 words from key_bin and adds them to word_arr
    ## word_arr[0,0] to word_arr[3,15]
    add_to_word_arr 0 $key_bin
}


add_to_word_arr ()
{
    ## input
    round=$1
    key_value=$2

    ## output adds words to a word_rray [word_id,byte_index]=word_value

    ## a (sub-)key consists of 128/192/256 bits (16/24/32 bytes)
    ## a (sub-)key holds 4 32 bit long words (w0, w1, ...)
    ## a word holds 4 1 byte (8 bit) long (b0, b1, ...)
    ## words are named word_arr[word#,byte#]

    ## first four words: w0, w1, w2, w3 (same as key_bin)
    # for (( byte_number=0; byte_number<"${key_bytes}"; byte_number++ )); do
    for (( word_number=0; word_number<"${key_bytes}"; byte_number++ )); do

	## Calculate the starting index for the byte
	bit_start=$((byte_number * 8))
	# Extract the byte (8 bits)
	word_value=${key_bin:bit_start:8}

	## determine the word and byte id for the associative array
	## NOTICE byte_number of for loop is not byte_id of array
	word_id=$(( round * 4 + byte_number / 4 ))
	byte_id=$(( byte_number % 4 + (word_id * 4) ))

	# Store the byte in the associative array
	word_arr[$word_id,$byte_id]="$word_value"

    done

    printf "DEV$LINENO %s\n" "${round}"
    pea word_arr | sort --numeric-sort
    # exit 255
}


pea () { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}"; done } #DEV


g_function ()
{
printf "DEV$LINENO %s\n" "${1}"
printf "DEV$LINENO %s\n" "${2}"
printf "DEV$LINENO %s\n" "${prev_word_3}"
printf "DEV$LINENO %s\n" "${curr_word_0}"
    ## rotate word

    ## substitute word
    ## round constant
}


key_expansion ()
{
    ## subkey_id 0,1,2,3 is original secret key (key_bin)
    ## subkey_id >3 is an expanded key
    ## subkey_id n = total number of rounds
    for (( round=1; round<"${rounds}"; round++ )); do

	## last word of previous round (input for g-function)
	prev_round=$(( round - 1 ))
	last_word_pr=$(( prev_round * 4 + 3 ))
	last_byte_pr=$(( prev_round * 16 + 15 ))
	prev_word_3=${word_arr[${last_word_pr},${prst_byte_pr}]}

	## first word of previous round (input for g-function)
	prev_round_fw_id=$(( prev_round * 4 ))
	prev_round_fb_id=$(( prev_round * 16 ))
	prev_word_3=${word_arr[${prev_round_fw_id},${prev_round_fb_id}]}
	# prev_round_byte_id=15
	# curr_word_byte_id=0
	# curr_word_0=${word_arr[${round},${curr_word_byte_id}]}

	g_function ${prev_word_3} ${curr_word_0}
exit 255
    done
}


output_matrix ()
{
    ## print all the subkey keys
    printf 'key %s\n' "$subkey"

    for (( row=0; row<"${rows}"; row++ )); do

	for (( col=0; col<"${cols}"; col++ )); do

            printf '%s ' "${words_arr[$row,$col]}"

	done

	echo

    done
}


main ()
{
    getstdin
    getargs $args
    synth_input
    key_analysis
    key_expansion
    output_matrix
}

main
