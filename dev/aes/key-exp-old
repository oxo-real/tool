#! /usr/bin/env sh

## input: key (bin)
## output: expanded keys (bin)

## usage: key-expansion.sh key.bin
## or: echo $key | key-expansion.sh

# words_arr=()
# declare -A words_arr
# typeset -A words_arr
## TODO DEV why does this not work?
## LEARN always initalize array in global scope (main body)
## (not inside functions)

source /home/oxo/.local/share/c/git/code/tool/dev/aes/rcon.sh
typeset -A word_arr

args="$@"
getargs ()
{
    while :; do

	case "$1" in

	    '' )
		break
		;;

	    --hex-key )
		key_format=hex
		shift
		:
		;;

	    --asc-key )
		key_format=asc
		shift
		:
		;;

	    --bin-key )
		key_format=bin
		shift
		:
		;;

	    * )
		## default key_format if not specified
		[[ -n "key_format" ]] || key_format=bin

		## NOTICE arg can be a file
		if [[ -f "$1" ]]; then

		    ## file content is read
		    input_arg=$(cat "$1")
		    shift

		else

		    ## argument is read
		    input_arg="$1"
		    shift

		fi
		;;

	esac

    done
}


getstdin ()
{
    if [[ -p /dev/stdin ]]; then

	input_stdin=$(cat)

    fi
}


synth_input ()
{
    ## stdin and arg are synthesized
    key_input=$(tr -d '\n' <<< "${input_stdin}${input_arg}")
}


key_analysis ()
{
    ## key format
    ## make hexadecimal or ascii keys binary
    case "$key_format" in

	asc )
	    key_bin=$(printf '%s' "$key_input" | sh c-asc-bin.sh)
	    ;;

	hex )
	    key_bin=$(printf '%s' "$key_input" | sh c-hex-bin.sh)
	    ;;

	* )
	    key_bin="$key_input"

    esac

    # key length
    key_bin_l=${#key_bin}

    case $key_bin_l in

	128 )
	    rows=4
	    cols=4
	    col_l=8
	    rounds=11
	    ;;

	192 )
	    rows=4
	    cols=6
	    col_l=8
	    rounds=13
	    ;;

	256 )
	    rows=4
	    cols=8
	    col_l=8
	    rounds=15
	    ;;

	* )
	    exit 136
	    ;;

    esac

    ## adding key_bin as subkey0 to word_arr
    add_to_word_arr 0 $key_bin
}


add_to_word_arr ()
{
    subkey_id=$1
    key_value=$2

    ## output adds to array [word_id,byte_index]=word
    ## a (sub-)key consists of 128 bits
    ## a key holds 4 32 bit long words (w0, w1, ...)
    ## a word holds 4 byte (8 bit) long (b0, b1, ...)
    ## words are named words_arr[word#,byte#]

    ## first four words (same as key_bin)
    for byte_number in {0..15}; do

	# Calculate the starting index for the byte
	start_index=$((byte_number * 8))
	# Extract the byte (8 bits)
	byte_value=${key_bin:start_index:8}

	# Determine the word number and byte index for the associative array
	word_id=$(( subkey_id * 4 + byte_number / 4 ))
	byte_index=$(( byte_number % 4 + (word_id * 4) ))

	# Store the byte in the associative array
	word_arr[$word_id,$byte_index]="$byte_value"

    done

    printf "DEV$LINENO %s\n" "${subkey_id}"
    pea word_arr | sort --numeric-sort
    exit 255
}
pea () { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}"; done }


generate_subkeys ()
{
    # subkey=$(( $word / 4 + 1 ))
    subkey_id="$1"
    index=0

    ## array fills first columns then rows
    for (( col=0; col<"${cols}"; col++ )); do

	for (( row=0; row<"${rows}"; row++ )); do

            words_arr[$subkey_id,$row,$col]="${key_bin:$(( index * $col_l )):$col_l}"

	    ((index++))

	done

    done
}


key_expansion ()
{
    ## subkey_id 0 is secret key
    ## subkey_id 1-n are expanded keys
    ## subkey_id n = number of rounds
    for (( subkey_id=0; subkey_id<"${rounds}"; subkey_id++ )); do

	## for every first word of a round > 0 apply
	## the g-function on the last word of the previous round

	add_to_word_arr $subkey_id $key_value

	## g-function on w0 and w3
	# Loop through the keys of the associative array
	# for key in "${!my_array[@]}"; do
	current_word=$subley_id,
	for key in "${(@k)word_arr[@]}"; do

	    if [[ $key == $current_word* ]]; then

		echo "Key: $key, Value: ${my_array[$key]}"

	    fi

	done
	w0=word_arr[0,0]
	w3=word_arr[0,3]

    done
}


output_matrix ()
{
    ## print all the subkey keys
    printf 'key %s\n' "$subkey"

    for (( row=0; row<"${rows}"; row++ )); do

	for (( col=0; col<"${cols}"; col++ )); do

            printf '%s ' "${words_arr[$subkey,$row,$col]}"

	done

	echo

    done
}


main ()
{
    getstdin
    getargs $args
    synth_input
    key_analysis
    key_expansion
    output_matrix
}

main
