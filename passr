#! /usr/bin/env sh

###
###  _ __   __ _ ___ ___ _ __
### | '_ \ / _` / __/ __| '__|
### | |_) | (_| \__ \__ \ |
### | .__/ \__,_|___/___/_|
### |_|
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
passr
fzf cli wrapper for pass
copyright (c) 2020 - 2024  |  oxo
----------------------------------------------------------------------
GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org
======================================================================
#TODO C-c exit, also in passr p

# dependencies
  pass, gpg, cryptsetup, fzf
  pwgn, vault, source functions

# usage
  passr [action|object] [element|object|other_arguments]

# examples

NOTICE to run without pwgn set: export PWGN_OFF=1

## status management

% passr open
% passr o

% passr login
% passr i

% passr status
% passr s

% passr logout
% passr u

% passr close
% passr c

% passr persist
% passr p

## data extraction

### object menu
% passr

### element menu
# passr $object
% passr email_john

### direct w/o menu
# passr $object $element
% passr email_john password

### search objects
% passr search [$string]
% passr z [$string]

### grep object data
% passr grep [$string]
% passr g [$string]

### otp_list
% passr otp_list

## data manipulation

### add object
% passr [$object_non_existing]
or
% passr create [$object]
% passr new [$object]
% passr n [$object]

### edit object data
% passr edit [$object]
% passr e [$object]

# '


#set -o errexit
#set -o nounset
set -o pipefail

# initial definitions

## script
script_name='passr'
developer='oxo'
license='gplv3'
initial_release='2020'
script_dir="$XDG_DATA_HOME/c/git/code/tool"

## arguments
### static variables
#### these do not change throughout script session
args=$@
arg_object=$1
arg_element=$2
tool_dir="$script_dir"
pwgn="$tool_dir/pwgn"
### dynamic variables
object="$arg_object"
element="$arg_element"
hold_status=0

## .password-store

## $crypto-source is the vault in which $store is saved
crypto_source="$XDG_DATA_HOME/c/keys/pass/vlt_pass"

## $store_l is the symlink location to the pass password store
## recommended is to mount an encrypted vault container
## then symlink .password-store to a container mountpoint
## default symlink:	$HOME/.password-store
## default target:	$HOME/dock/vlt/pass
## ln -s $HOME/dock/vlt/pass $HOME/.password-store
## use option -f to replace an existing link
store_l="$HOME/.password-store"

## $store is the pass password store location
## the symlinks target
store=$(readlink $store_l)

## source functions
source_dir="$XDG_DATA_HOME/c/git/code/source/function"
source $source_dir/text_appearance
source $source_dir/reply_functions
source $source_dir/get_sudo


element_menu=(\
	"1 url" \
	"2 userid" \
	"" \
	"3 password" \
	"4 otp" \
	"5 unlock" \
	"6 peacto" \
	"" \
	"A autoentry" \
	"O other" \
	"" \
	"S show" \
	"C copy" \
	"" \
	"E edit" \
	"" \
	"ESC cancel")

: '
$object definition
^^^^^^^^^^^^^^^^^^
an object refers to a gpg encrypted file (*.gpg)

the pass man page refers to objects by naming them 'passwords'
so insert a new password means actually making a new .gpg file
a gpg file can contain anything, also passwords

pass expects the first line of the gpg file to be the password
this script makes extensive use of that

pass names gpg files from the password_store_root without extension
example:
$password_store_root/subdir/object.gpg <=> subdir/object

$object contains in this script the value: 'subdir/object'
$element contains the value of an element in the $object
i.e. this can be a password, url or userid (among more)

$element definition
^^^^^^^^^^^^^^^^^^^
1. an element can be retrieved from an object
	regular elements are i.e.: url, userid, password

2. an element can be an action applied to an object

retrievals are numbered and actions are lettered in the element menu

gpg file contents
^^^^^^^^^^^^^^^^^
example gpg file (mail_john.gpg) for passr to work properly:

123456
userid: john
url: https://login.mail.com
unlock: password
peacto: iloveyou
comments: important

otp-strings can be stored i.e.: otp_mail_john.gpg
'


#--------------------------------


check_sum()
{
    ## check file integrity
    if [[ -z $checked ]]; then

    	checked=1
    	check-sum $(realpath $script_dir/$script_name)
	[[ $? -ne 0 ]] && exit 88

    fi

}


get_object()
{
    # passr $object $element

    case $object in

	create | new | n)
	    object='new'
	    pass_new
	    ;;

	edit | e)
	    object='edit'
	    pass_edit
	    ;;

	open | o)
	    object='open'
	    vault_open
	    ;;

	login | i)
	    object='login'
	    log_in
	    ;;

	status | s | info)
	    object='status'
	    show_status
	    exit 0
	    ;;

	logout | u)
	    object='logout'
	    log_out
	    ;;

	close | c)
	    object='close'
	    log_out
	    close
	    ;;

	persist | p)
	    mode='persist'
	    object=''
	    #hold_status=0
	    change_menu
	    ;;

	grep | g)
	    object='grep'
	    pass_grep
	    ;;

	search | z)
	    object='search'
	    pass_search
	    ;;

	otp_list)
	    object='otp_list'
	    list_otps
	    ;;


	# specific element given as object

	## case: the user reverses the primarily intended order
	## which is: $object and then $element
	## with this i.e. 'passr url $object' also works
	## as a result below are forbidden object names
	## which are checked when creating new objects
	url | \
	userid | \
	password | \
	pw | \
	otp | \
	unlock | \
	peacto | \
	autoentry | \
	other | \
	show | \
	copy)
	    element_as_object
	    ;;

	*)
	    get_mountpoint_status

	    case $mp_status in

		0)
		    ## pass_vlt not mounted
		    object='login'
		    pass_mount
		    ;;

		$store)
		    ## pass_vlt already mounted
		    get_cache_status

		    case $cache_status in

			0)
			    ## no gpg_agent cache; need to login
			    log_in

			    [[ -n $object ]] && get_object
			    ;;

			1)
			    ## have gpg_agent cache; no need to login
			    case $object in

				'')
				    ## no object arg given; fzf prompts for it
				    object=$(find -L $store_l -type f -iname '*.gpg' | \
			   	         ## remove $store_l leading path
			   	         ## internal field separator is '|'
			   	         ## because the path itself contains '/'
			   	         sed "s|$store_l/||g" | \
					 ## filter unwanted items
					 sed '/credentials/d' | \
			   	         ## remove file .gpg extension
			   	         sed 's|.gpg||g' | \
			   	         sort | \
			   	         fzf --height=20% --prompt='object ')
				    ;;

				*)
				    ## we have an $object
				    case $hold_status in

					1)
					    ## holding object
					    object="$object_to_hold"
					    ;;

				    esac
				    ;;

			    esac
		   	    ;;

	    	    esac
		    ;;

	    esac
	    ;;

    esac
}


element_as_object()
{
    arg_element_tmp="$arg_object"

    arg_object="$arg_element"
    arg_element="$arg_element_tmp"

    [[ $arg_element == 'pw' ]] && arg_element='password'

    get_object
}


check_new_obj_names()
{
    declare -a prohibited_object_names=( \
	url \
	userid \
	password \
	pw \
	otp \
	unlock \
	peacto \
	other \
	autoentry \
	show \
	copy \
	hold \
	quit \
	)

    for prohibited_name in "${prohibited_object_names[@]}"; do

	if [[ $object == $prohibited_name ]];then

	    printf "${MAGENTA}$object${NOC} object name prohibited\n"
	    exit 55

	fi

    done
}


pass_new()
{
    ## prevent 'passr non_existent_object' from being emptied out
    case $object in

	create | new | n)
	    ## coming from 'passr new'
	    object=$arg_element

	    ## test for empty object
	    [[ -z "$object" ]] && printf '%s\n' 'empty object' && exit 26

	    process_object
	    ;;

    esac

    align=11

    ## get object
    case $object in
	'')
	    printf "%"$align"s %s" "object: "
	    read -r -e object
	    ;;

	*)
	    printf "%"$align"s %s" "object: "
	    printf "$object\n"
	    ;;

    esac

    ## get creation time
    c_time=$(date +'%Y%m%d_%H%M%S_%s_%z_%Z_%V')

    ## get url
    printf "%"$align"s %s" "url: "
    read -r -e url

    ## get userid
    printf "%"$align"s %s" "userid: "
    read -r -e userid

    ## get comments
    printf "%"$align"s %s" "comments: "
    read -r -e comments

    ## get password
    gen_sel_pw

    ## synthesize string
    printf "%s\n%s\n%s\n%s\n%s\n%s\n" \
	"$password" \
	"userid: $userid" \
	"url: $url" \
	"created: $c_time" \
	"comments:" "$comments" | \
	wl-copy -o

    ## create new object gpg file
    pass edit $object

    exit 0
}


pass_edit() {
    object=$arg_element
    process_object

    pass edit $object

    exit 0
}


pass_grep()
{
    ## search object data
    grep_string="$(printf "$args" | cut -d ' ' -f 2-)"

    pass grep $grep_string
    exit 0
}


pass_search()
{
    ## search objects
    search_string="$element"

    pass search $search_string
    exit 0
}


gen_sel_pw()
{
    password=$(\
	tr -d -c "[:alnum:]"'~!@#$%^&*()-=[];\,./_+{}:|<>?' < /dev/urandom | \
	fold -w 32 | head -n 16 | cat -b | \
	fzf --height=17 --prompt=' passstring: ' | awk '{print $2}')

}


vault_open()
{
    pass_mount
}


log_in()
{
    get_mountpoint_status

    case $mp_status in

   	$store)
	    from_log_in=1
	    element='login'
	    gpg_decrypt
	    pass_element
	    ;;

   	*)
	    vault_open
	    log_in
	    ;;

   esac
}


pass_quit()
{
    exit 0
}


log_out()
{
    gpg-connect-agent -q reloadagent /bye >/dev/null

    pass_element

    [[ "$object" == 'close' ]] || exit 0
}


close()
{
    sh vault close $store
    exit 0
}


show_status()
{
    get_mountpoint_status
    get_cache_status
    printf "$mp_status $cache_status\n"
}


copy_text()
{
    ## # 20230826
    ## # --paste-once does not work in $browser
    ## # but does work in terminal (alacritty)
    ## # mimetype is not the issue
    wl-copy
    #wl-copy --paste-once
    #wl-copy --type text/plain
    #wl-copy --type text/plain --paste-once
    #wl-copy --trim-newline --paste-once --type text/plain
    #wl-copy --trim-newline --paste-once --type text/plain;charset=utf-8

}


get_mountpoint_status()
{
    mountpoint -q $store_l && mp_status=$store || mp_status=0
}


get_cache_status()
{
    ## 1 | 0 (no cache)
    cache_status=$(gpg-connect-agent 'keyinfo --list' /bye 2>/dev/null | \
	awk 'BEGIN{CACHED=0} /^S/ {if($7==1){CACHED=1}} END\
	{if($0!=""){print CACHED} else {print "none"}}')
}


pass_mount()
{
    ## pass crypto source location

    ## pass mount destination
    ## via $LS_COLORS symlink color $HOME/.password-store:
    ## red (or=40;31;01) orphaned symlink => vlt_pass not mounted
    ## cyan (ln=01;36) valid symlink => vlt_pass mounted
    pass_mount_pt="$HOME/dock/vlt/pass"
    [[ -d $pass_mount_pt ]] || mkdir -p $pass_mount_pt

    get_sudo

    ## pass crypto source luksuuid
    luksuuid=$(sudo cryptsetup luksUUID $crypto_source)
    printf "$luksuuid" | copy_text

    ## check for mountpoint
    lsblk_rpaf=$(lsblk -rpaf --noheadings)
    loopdevice=$(printf $lsblk_rpaf | grep $luksuuid | awk '{print $1}')
    mapper_data=$(lsblk -rpaf --noheadings $loopdevice)
    mountpoint=$(printf $mapper_data | awk '{print $8}')

    if [[ -z "$mountpoint" ]]; then

	vault open $crypto_source $pass_mount_pt

    elif [[ -n "$mountpoint" ]]; then

	wl-copy --clear

    fi

    case $object in

	open)
	    ## only mount vault, no login
	    exit 0
	    ;;

    esac
}


gpg_decrypt()
{
    ## always reset cached gpg password
    gpg-connect-agent -q reloadagent /bye >/dev/null

    ## for aesthetic reasons: first sudo then O--,
    get_sudo

    erase_line
    printf "\n${fg_yellow}%s${st_def}" 'OpenPGP  O--,'

    echo
    generate_pw
    echo
    ## pwgn has at this point generated its hex string
}


erase_line()
{
    printf "\r"
    tput el
}


process_reply()
{
    action_reply='^a'
    answer=$(printf "$1" | grep -iq "$action_reply")

    case $reply in

	$1)
	    continue
	    ;;

	*)
	    generate_pw
	    #sh $pwgn
	    ;;

    esac
}


generate_pw()
{
    ## permanently run without pwgn set environment variable PWGN_OFF
    if [[ -z "$PWGN_OFF" ]]; then

	echo

	printf "starting pwgn... ${fg_black}${bg_yellow}A${st_def}bort "

	reply_read_single_hidden_timer

	# erase line
	erase_line

	if printf "$reply" | grep -iq "^a"; then

	    # enter password w/o pwgn

	    tput cuu1
	    erase_line

	else

	    # run pwgn
            sh "$pwgn"

	fi

    fi
}


get_element()
{
    if [[ -z $element ]]; then

    	element=$(printf '%s\n' "${element_menu[@]}" | \
	    fzf --height=19 --prompt="$object element " | \
	    awk '{print $2}')

    fi
}


check_obj_exist()
{
   [[ -f "${store}/${object}.gpg" ]] && obj_exist=1
}


object_is_quit()
{
    case $object in

	quit)
	    element='quit'
	    human_info
	    pass_quit
	    ;;

    esac
}


process_object()
{
    object_is_quit
    check_obj_exist

    if [[ $obj_exist -eq 1 ]]; then

	## object does exist
	case $object in

	    new | n)
		## prevent creating existing object
		printf "object ${MAGENTA}$object${NOC} exists\n"; exit 47
		;;

	    *)
		continue
		;;

	esac

    else

	## object does not exist
	if [[ "$mode" == "persist" ]]; then

	    case $hold_status in

		1)
		    ## hold same object
		    object=$object_to_hold
		    #get_object
		    ;;

		*)
		    ## get next object
		    get_object
		    object_is_quit
		    ;;

	    esac

	else

	    case $object in

		new | n)
		    check_new_obj_names
		    continue
		    ;;

		'')
		    exit 0
		    ;;

		*)
		    ## non-existent object
        	    printf "${MAGENTA}$object${NOC} not found\n"

		    ## prompt create object
		    printf "create [Y/n]? "
		    reply_read_single
		    echo

		    case $reply in

			n | N)
			    exit 0
			    ;;

		    esac

		    check_new_obj_names
		    pass_new
		    ;;

	    esac

	fi

    fi

    ## otp object
    if [[ -n $(printf "$object" | grep ^otp) ]]; then

    	get_otp
    	exit 0

    fi

    get_cache_status
    case $cache_status in

    	0)
	    log_in
	    ;;

    esac
}


get_element_value()
{
    element_value=$(pass show $object | grep ^$element: | awk '{print $2}')

    check_element_value

    ## '%s' prevents 'invalid format character' error
    printf '%s' "$element_value" | copy_text
    #printf '%s' "$element_value" | wl-copy --type=text/plain -n -o
}


get_password()
{
    pass $object | head -n 1 | copy_text
}


get_otp()
{
    ## redirection to the separate otp file
    if [[ "$(printf $object | head -c 4)" != "otp_" ]]; then

    	object="otp_$object"

    fi

    ## check_obj_exist && pass otp $object | wl-copy -n -o
    if [[ -f $store/$object.gpg ]]; then

    	pass otp $object | copy_text
	## alternative: sh $XDG_DATA_HOME/c/git/note/crypto/2fa/2fa_sha1_totp.sh $otp_secret

    fi

    ## reset object value for human info
    object=$(printf $object | cut -c 5-)
}


pass_element()
{
    ## run pass natively with $element
    case $from_log_in in

	1)
	    ## silent (when logging in)
	    ## this triggers the gpg passphrase question
	    ## to unlock the openpgp secret key
	    pass $element
	    ;;

	*)
	    ## normal (not silent)
	    human_info

	    case $object in

		logout|close)
		    :
		    ;;

		*)
		    pass $element $object
		    ;;

	    esac
	    ;;

    esac
}


check_element_value()
{
    ## no autoentry
    if [[ -z $ae ]]; then

    	if [[ -z $element ]]; then

    	    element="${MAGENTA}element${NOC} no selection"

    	elif [[ -z $element_value ]]; then

    	    element="${MAGENTA}$element${NOC} no value"

    	fi

    fi

    ## autoentry
    if [[ -n $ae ]]; then

    	[[ -z $element_value ]] && notify-send "$element no value" && exit 0

    fi
}


error_message()
{
    ## selected empty line in element menu
    if [[ -z $element ]]; then

    	error='no element'

    else

	error=''

    fi
}


human_info()
{
    ## get error message if applicable
    error_message

    if [[ -z $ae ]]; then

	## not in autoentry modus
    	if [[ "$object" == 'login' ]] || \
	       [[ "$object" == 'logout' ]] || \
	       [[ "$object" == 'close' ]]; then

	    if [[ -n $error ]]; then

		## print error message
		printf "$(date +%H%M%S) ${MAGENTA}$object${NOC} $error\n"

	    else

		## print common info (we have no error)
	    	printf "$(date +%H%M%S) $object\n"

	    fi

    	else

	    ## all $object cases except login, -out and close
	    if [[ -n $error ]]; then

		## print error message
		printf "$(date +%H%M%S) ${MAGENTA}$object${NOC} $error\n"

	    else

	    	printf "$(date +%H%M%S) ${BLUE}$object${NOC} $element\n"

	    fi

    	fi

    elif [[ -n $ae ]]; then

	## in autoentry modus
    	notify-send "$element"
    	sleep $t

    fi
}


autoentry()
{
    ae=1
    ## sleep time
    t=5

    element="url"
    get_element_value
    qutebrowser --target tab $element_value &
    t=$((t * 2))
    human_info
    notify-send "$element"
    sleep $((t * 2))

    element="userid"
    get_element_value
    t=$t
    human_info
    notify-send "$element"
    sleep $t

    element="password"
    get_password 1> /dev/null #no stdout
    human_info
    notify-send "$element"
    sleep $t

    element="otp"
    get_otp
    if [[ -z $otp ]]; then

    	human_info
    	notify-send "$element"
    	sleep $t

    fi

    element="unlock"
    get_element_value
    if [[ -z $otp ]]; then

    	human_info
    	notify-send "$element"
    	sleep $t

    fi
}


show_other_element()
{
    #TODO
    :
}


get_other_element()
{
    #DEV
    # other non-default element field name i.e.: 'email'

    printf "%s" "other element: "
    read -r -e other_element

    element=$other_element
    get_element_value
}


get_object_name()
{
    printf "$object" | copy_text
    #printf "$object" | wl-copy -n -o
}


process_element()
{
    case $element in

    	password)
	    get_password
	    human_info
	    ;;

    	otp)
	    get_otp
	    human_info
	    ;;

    	autoentry)
	    autoentry
	    ;;

    	other)
	    get_other_element
	    ;;

    	show)
	    element='show'
	    pass_element
	    ;;

    	copy)
	    get_object_name
	    human_info
	    ;;

    	edit)
	    element='edit'
	    pass_element
	    ;;

    	new)
	    element='new'
	    pass_new
	    ;;

	quit)
	    element='quit'
	    human_info
	    pass_quit
	    ;;

    	log_out)
	    log_out
	    ;;

    	"")
	    human_info
	    ;;

	hold_on | hold_off)
	    ## toggle object hold status
	    case $hold_status in

		1)
		    ## toggle hold_off
		    hold_status=0
		    object="$object_to_hold"
		    element='hold_off'

		    human_info
		    unset object_to_hold
		    get_object
		    ;;

		*)
		    ## toggle hold_on
		    hold_status=1
		    element='hold_on'

		    human_info
		    object_to_hold="$object"
		    get_object
		    ;;

	    esac
	    ;;

    	*)
	    get_element_value
	    human_info
	    ;;

    esac
}


check_mode()
{
    ## persist mode
    ## reopen the menu
    case $mode in

	persist)
	    ## reset object and element
	    object="$arg_object"
	    element=''

	    main
	    ;;

    esac
}


change_menu()
{
    ## passr started in persistent mode

    ## change element menu item 'cancel' to 'quit'
    for i in "${!element_menu[@]}"; do

	if [[ ${element_menu[$i]} == "ESC cancel" ]]; then

	    element_menu[$i]="Q quit"

	fi

    done

    ## define hold menu item
    case $hold_status in

	1)
	    ## hold=1
	    hold_menu_item='H hold_off'
	    ;;

	*)
	    ## hold=0
	    hold_menu_item='H hold_on'
	    ;;

    esac

    ## tweak the last menu item
    last_menu_item="${element_menu[-1]}"

    case $last_menu_item in

	'Q quit')
	    ## add hold menu item
	    element_menu+=("$hold_menu_item")
	    ;;

	*)
	    ## we need to change hold menu item
	    ## delete last menu item
	    unset 'element_menu[${#element_menu[@]}-1]'
	    ## append other hold menu item
	    element_menu+=("$hold_menu_item")
	    ;;

    esac
}


list_otps()
{
    otp_files=$(fd '^otp_*' $HOME/.password-store | sort)

    printf "calculating otp codes ...\r"

    ## loop through lines with otp_file.gpg
    while IFS= read -r -u 4 line; do

	## extract object name
	object=$(printf "$line" | sed "s|$store_l\/||" | sed 's|.gpg||')

	current_otp=$(pass otp $object | sed 's/.\{3\}/& /')

	current_list_line=$(printf "%40s  %s\n" "$object" "$current_otp")

	otp_list="$otp_list$current_list_line\n"

    done 4<<< "$otp_files"

    otp_selected=$(timeout --foreground -k 12 10 fzf <<< $(printf "$otp_list"))

    if [[ $? -eq 124 ]]; then

    	## timeout occurred
    	otp_list='' && unset otp_list
    	list_otps

    else

	printf "$otp_selected" | awk -F ' ' '{print $(NF-1)$NF}' | copy_text
	#printf "$otp_selected" | awk -F ' ' '{print $(NF-1)$NF}' | wl-copy -n -o
    	otp_list='' && unset otp_list
    	otp_selected='' && unset otp_selected
    	exit 0

    fi
}


main()
{
    check_sum
    get_object
    process_object
    get_element
    process_element
    check_mode
}

main
