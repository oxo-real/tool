#! /usr/bin/env sh


# usage: build-repo -p src/pkg.list -r ofcl_dst [[--no-aur]|[--no-ofcl]] [-n alt_db_name] [-d alt_db_dst]

# NOTICE generate full system native package list with: pacman -Qq > package.list


args="$@"
getargs ()
{
    while :; do

	case "$1" in

	    --package-list|--pkg-lst|--pl|-p )
		## package source file location
		shift

		arg_pkg_lst="$1"
		shift
		;;

	    --repo-destination|--repo-dest|--repo-dst|--repo|-r )
		## offline repository destination location
		shift

		arg_repo_dst="$1"
		shift
		;;

	    --database-destination|--db-dest|--db-dst|--db|-d )
		## offline repository database destination location
		shift

		arg_repo_ofcl_db="$1"
		shift
		;;

	    --database-name|--db-name|--name|-n )
		## offline repository database name
		shift

		arg_repo_ofcl_db_name="$1"
		shift
		;;

	    --aur-destination|--aur-dest|--aur-dst|--aur|-a )
		## offline repository destination location
		shift

		arg_repo_aur="$1"
		shift
		;;

	    --no-ofcl|--aur-only )
		## only search for aur packages no native
		shift

		no_ofcl_pkgs=1
		;;

	    --no-aur|--ofcl-only )
		## only search for official packages no aur
		shift

		no_aur_pkgs=1
		;;

	    - )
		shift

		arg_pkg_lst="$1"
		break
		;;

            * )
		break
		;;

	esac

    done
}


process_args ()
{
    ## create working realpath parameters
    # [[ -n $arg_pkg_lst ]] && pkg_lst="$(realpath $arg_pkg_lst)"
    # [[ -n $arg_repo_dst ]] && repo_dst="$(realpath $arg_repo_dst)"
    # [[ -n $arg_db_name ]] && db_name="$(realpath $arg_db_name)"
    # [[ -n $arg_db_dst ]] && db_dst="$(realpath $arg_db_dst)"

    ## compulsory user arguments
    pkg_lst="$arg_pkg_lst"
    repo_dst="$arg_repo_dst"

    [[ -f "$pkg_lst" ]] || ( printf 'error: package list %s not found\n' "$pkg_lst" && exit 76 )
    [[ -n "$repo_dst" ]] || ( printf 'error: no destination\n' && exit 77 )
    [[ -d "$repo_dst" ]] || mkdir -p "$repo_dst"

    ## set default values
    repo_ofcl="$repo_dst"/ofcl
    repo_ofcl_pkgs="$repo_ofcl"/pkgs
    repo_ofcl_db="$repo_ofcl"/db
    repo_ofcl_db_name=offline
    repo_aur="$repo_dst"/aur

    ## specific user arguments
    [[ -n "$arg_repo_ofcl_db" ]] && repo_ofcl_db="$arg_repo_ofcl_db"
    [[ -n "$arg_repo_ofcl_db_name" ]] && repo_ofcl_db_name="$arg_repo_ofcl_db_name"
    [[ -n "$arg_repo_aur" ]] && repo_aur="$arg_repo_aur"
    [[ -n "$arg_repo_aur" ]] && [[ -d "$repo_aur" ]] || mkdir -p "$repo_aur"
}


definitions ()
{
    ## arch linux official repositories (native packages)
    ### paths
    pkg_src=/var/cache/pacman/pkg
    ### directories
    [[ -d "$repo_ofcl_db" ]] || mkdir -p "$repo_ofcl_db"
    [[ -d "$repo_ofcl_pkgs" ]] || mkdir -p "$repo_ofcl_pkgs"

    ## sync database directory
    sync_db_src=/var/lib/pacman/sync
    sync_db_dst="$repo_dst"/sync

    ## arch user repository (foreign packages)
    src_aur="$XDG_CACHE_HOME/yay"

    ## define temporary files
    pkgs_dump_list="$XDG_CACHE_HOME/test/pkgs_dump"
    ## sorted and unificied dump_list
    pkgs_2_copy="$XDG_CACHE_HOME/test/pkgs_2_copy"
}


delete_old_stuff ()
{
    ## remove existing temporary files
    rm -rf "$pkgs_dump_list" "$pkgs_2_copy"
}


build_dump_list ()
{
    ## create package dump list with names of
    ## all main native packages and their dependencies
    # pacman -Qqn | while read -r pkg_name; do
    while read -r pkg_name; do

	if [[ -z "$no_ofcl_pkgs" ]]; then
	    ## do search official packages

	    if pacman -Qqn "$pkg_name"; then

		#TODO DEV no_ofcl to skip official packages

		## first line of pactree is queried (main) package
		## other lines are main package dependencies
		pactree --linear --unique "$pkg_name" >> "$pkgs_dump_list"

	    fi

	elif [[ -z "$no_aur_pkgs" ]]; then
	    ## do search aur packages

	    if pacman -Qqm "$pkg_name"; then

		#TODO DEV no_aur to skip aur packages

		## add to package dump list the names of
		## all aur packages and their dependencies
		pactree --linear --unique "$pkg_name" >> "$pkgs_dump_list"

		## add dependencies to dump list
		#rg --no-line-number ^depends "$src_aur"/"$pkg_name"/PKGBUILD \
		    grep ^depends "$src_aur"/"$pkg_name"/PKGBUILD \
			| awk -F '[()]' '{print $2}' \
			| sed "s/'//g" \
			| sed 's/"//g' \
			| tr ' ' '\n' \
			     >> "$pkgs_dump_list"

		    ## add make dependencies to dump list
		    #rg --no-line-number ^makedepends "$src_aur"/"$pkg_name"/PKGBUILD \
			grep ^makedepends "$src_aur"/"$pkg_name"/PKGBUILD \
			    | awk -F '[()]' '{print $2}' \
			    | sed "s/'//g" \
			    | sed 's/"//g' \
			    | tr ' ' '\n' \
				 >> "$pkgs_dump_list"

	    fi

	fi

    done < "$pkg_lst"
}


optimize_dump_list ()
{
    ## 3 sed operations separated by ;
    ## remove greater than and equal to (>=) version from dump list
    ## convert to all lower case
    ## remove .so suffixes
    sed -i 's/[>=].*//; s/.*/\L&/; s/\.so//' "$pkgs_dump_list"

    ## create pkgs_2_copy; dump_list with duplicate lines removed
    sort < "$pkgs_dump_list" | uniq > "$pkgs_2_copy"
}


copy_pkg_files ()
{
    for pkg_name in $(cat "$pkgs_2_copy"); do

	if pacman -Qqn "$pkg_name"; then

	    #TODO DEV no_ofcl to skip official packages

	    ## native package latest zst (and sig) file to repo
	    #latest_pkg=$(fd --extension zst --base-directory "$pkg_src" "$pkg_name" \
	    latest_pkg=$(find "$pkg_src" "${pkg_name}*.zst" \
			     | sort --version-sort \
			     | tail -n 1 \
		      )

	    if [[ -n "$latest_pkg" ]]; then

		latest_pkg_realpath="$(realpath $pkg_src/$latest_pkg)"

		if [[ -f "$latest_pkg_realpath" ]]; then

		    ## copy latest zst
		    cp "$latest_pkg_realpath" "$repo_ofcl_pkgs"

		    if [[ -f "$latest_pkg_realpath".sig ]]; then

			## copy signature file
			cp "$latest_pkg_realpath".sig "$repo_ofcl_pkgs"

		    fi

		fi

	    fi

	elif pacman -Qqm "$pkg_name"; then

	    #TODO DEV no_aur to skip aur packages

	    ## aur package
	    copy_yay_source "$pkg_name"

	fi

    done
}


copy_yay_source ()
{
    pkg_name="$1"
    ## copy source files including PKGBUILD
    ## sudo because .git has often root owner
    sudo cp -r "$src_aur"/"$pkg_name" "$repo_aur"
    sudo chown -R $USER:$GROUP "$repo_aur"/"$pkg_name"
}


create_database ()
{
    repo-add --new --include-sigs "$repo_ofcl_db"/"$repo_ofcl_db_name".db.tar.zst "$repo_ofcl_pkgs"/*[^.sig]
}


copy_sync_db ()
{
    [[ -d "$sync_db_dst" ]] || mkdir -p "$sync_db_dst"
    cp "$sync_db_src" "$sync_db_dst"
    echo '/var/lib/pacman/sync' > "$sync_db_dst"/org_loc
}


main ()
{
    getargs $args
    process_args
    definitions
    delete_old_stuff
    build_dump_list
    optimize_dump_list
    copy_pkg_files
    create_database
    copy_sync_db
}

main
