#!/usr/bin/env sh
#
##
###                                 _
###  _ __   __ _ ___ ___  __ _  ___| |_
### | '_ \ / _` / __/ __|/ _` |/ _ \ __|
### | |_) | (_| \__ \__ \ (_| |  __/ |_
### | .__/ \__,_|___/___/\__, |\___|\__|
### |_|                  |___/
###  _ _|_ _   ._  _  _
### (_\/|_(_)\/|_)(_|(/_
###   /      / |   _|
###
### passget
### fzf cli wrapper for pass
### copyright (c) 2020 - 2022  |  cytopyge
###
### GNU GPLv3 GENERAL PUBLIC LICENSE
### This program is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### (at your option) any later version.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this program.  If not, see <https://www.gnu.org/licenses/>.
### https://www.gnu.org/licenses/gpl-3.0.txt
###
### y3l0b3b5z2u=:matrix.org @cytopyge@mastodon.social
###
##
#

## dependencies
#	pass, cryptsetup, fzf

## usage
#	passget
#	passget $object
#	passget $object $element
#
#	passget open
#	passget login
#	passget status
#	passget logout
#	passget close

## examples
#	passget
#	passget codeberg_cytopyge
#	passget codeberg_cytopyge password


# initial definitions

## script
script_name='passget'
developer='cytopyge'
license='gplv3'
initial_release='2020'

## hardcoded variables

## store_l is the symlink location to the pass password store
## recommended is to mount an encrypted vault container
## then symlink .password-store to a container mountpoint
## default symlink:	$HOME/.password-store
## default target:	$HOME/dock/vlt/pass
store_l="$HOME/.password-store"

crypto_source="$XDG_DATA_HOME/c/keys/pass/vlt_pass"
source_dir="$XDG_DATA_HOME/c/git/code/source/function"

#--------------------------------


object=$1
element=$2

## store is the genuine password store location
store=$(readlink $store_l)

source $source_dir/text_appearance
source $source_dir/reply_functions
source $source_dir/get_sudo

## objects can be searched for one or more elements
## regular elements are: url, userid, password
## elements that can be retrieved with passget are:
elements=(\
	"1 url" \
	"2 userid" \
	" " \
	"3 password" \
	"4 otp" \
	"5 unlock" \
	"6 peacto" \
	" " \
	"A autoentry" \
	" " \
	"E edit" \
	"S show" \
	"C copy" \
	" " \
	"ESC cancel")

## the pass help file refers to objects by naming them 'passwords'
## so insert a new password means making a new .gpg file
## pass expects the first line of the gpg file to be the password
## the gpg file can contain more than just the password though
## this script makes use of that
## here an object is the way pass represents a gpg file
## (filename without .gpg extension)


get_object()
{
    case $object in

	login)
	    log_in
	    ;;

	logout)
	    log_out
	    ;;

	open)
	    vault_open
	    ;;

	close)
	    log_out
	    close
	    ;;

	status)
	    show_status
	    exit 0
	    ;;

	'')
	    get_mountpoint_status
	    case $mp_status in

		0)
		    object='login'
		    pass_mount
		    ;;

		$store)
		    object=$(find -L $store_l -type f -iname '*.gpg' | \
			# with sed we remove the leading path of $store_l
			# internal field separator is '|'
			# because the path itself contains '/'
			sed "s|$store_l/||g" | \
			# with sed we remove the trailing .gpg extension
			sed "s/.gpg//g" | \
			sort | \
			fzf --prompt='select object ')
		    ;;

	    esac

    esac
}


vault_open()
{
    pass_mount
}


log_in()
{
    get_mountpoint_status

    case $mp_status in

   	$store)
	    element='show'
	    gpg_decrypt
	    pass_element
	    ;;

   	*)
	    show_status
	    #printf "${MAGENTA}no_mp${NOC}\n"
	    vault_open
	    log_in
	    ;;

   esac
}


log_out()
{
    gpg-connect-agent -q reloadagent /bye >/dev/null
    printf "${BLUE}logged out, bye!${NOC}\n"

    [[ "$object" == 'close' ]] || exit 0
}


close()
{
    sh vault close $store
    exit 0
}


show_status()
{
    get_mountpoint_status
    get_cache_status
    printf "$mp_status $cache_status\n"
}


get_mountpoint_status()
{
	mountpoint -q $store_l && mp_status=$store || mp_status=0
	#[[ $? -ne 0 ]] && \
	#	printf "${MAGENTA}password-store not mounted${NOC}\n"
}


get_cache_status()
{
    # 1 | 0 (no cache)
    cache_status=$(gpg-connect-agent 'keyinfo --list' /bye 2>/dev/null | \
	awk 'BEGIN{CACHED=0} /^S/ {if($7==1){CACHED=1}} END\
	{if($0!=""){print CACHED} else {print "none"}}')
}


pass_mount()
{
    # pass crypto source location

    # pass mount destination
    ## vlt_pass mounted => $HOME/.password-store becomes pale
    pass_mount="$HOME/dock/vlt/pass"
    [[ -d $pass_mount ]] || mkdir -p $pass_mount

    get_sudo

    # pass luksuuid
    luksuuid=$(sudo cryptsetup luksUUID $crypto_source)
    printf "$luksuuid" | wl-copy -n -o

    ## check for mountpoint
    lsblk_rpaf=$(lsblk -rpaf --noheadings)
    loopdevice=$(printf $lsblk_rpaf | grep $luksuuid | awk '{print $1}')
    mapper_data=$(lsblk -rpaf --noheadings $loopdevice)
    mountpoint=$(printf $mapper_data | awk '{print $8}')

    if [[ -z "$mountpoint" ]]; then

	vault open $crypto_source $pass_mount

    elif [[ -n "$mountpoint" ]]; then

	wl-copy --clear

    fi

    case $object in

	open)
	    # only mount vault, no login
	    exit 0
	    ;;

    esac
}


gpg_decrypt()
{
    # always reset cached gpg password
    gpg-connect-agent -q reloadagent /bye >/dev/null

    ## for aesthetic reasons: first sudo then O--,
    get_sudo

    tput cuu1
    erase_line

    printf "${YELLOW}${BOLD} O--, ${NORMAL}${NOC}"
    tput civis
    sleep 2
    tput cnorm
    erase_line

    echo
    generate_pw
    echo
}


erase_line()
{
    printf "\r"
    tput el
}


generate_pw()
{
    printf "starting pwgn... press 'n' to abort "

    reply_read_single_hidden_timer

    erase_line

    if printf "$reply" | grep -iq "^n"; then

    	continue

    else

    	pwgn

    fi
}


get_element()
{
    if [[ -z $element ]]; then

    	element=$(printf '%s\n' "${elements[@]}" | \
	    fzf --prompt='select element ' | \
	    awk '{print $2}')

    fi
}


process_object()
{
    # empty object selection
    [[ -z $object ]] && exit 0

    # existing object
    check_obj_exist
    if [[ $obj_exist == 1 ]]; then

    	:

    else

    	printf "${MAGENTA}no object${NOC}\n" && exit 70

    fi

    # otp object
    if [[ -n $(printf "$object" | grep ^otp) ]]; then

    	get_otp
    	exit 0

    fi

    # TODO if only passget is entered when status is 0 0
    get_cache_status
    case $cache_status in

    	0)
	    log_in
	    ;;

    esac
}


get_element_value()
{
    element_value=$(pass show $object | grep ^$element: | awk '{print $2}')

    check_element_value

    ## '%s' prevents 'invalid format character' error
    printf '%s' "$element_value" | wl-copy -n -o
}



get_password()
{
    pass $object | head -n 1 | wl-copy -n -o
}


check_obj_exist()
{
    [[ -f "$store/$object.gpg" ]] && obj_exist=1
}


get_otp()
{
    # redirection to the separate otp file
    if [[ "$(printf $object | head -c 4)" != "otp_" ]]; then

    	object="otp_$object"

    fi

    #TODO
    #check_obj_exist && pass otp $object | wl-copy -n -o
    if [[ -f $store/$object.gpg ]]; then

    	pass otp $object | wl-copy -n -o

    fi

    # reset object value for human info
    object=$(printf $object | cut -c 5-)

    #[[ -z $element_value ]] && element="$element ${MAGENTA}no element value${NOC}"
}


pass_element()
{
    # run pass natively with $element
    #clear
    human_info
    pass $element $object
}


check_element_value()
{
    ## no autoentry
    if [[ -z $ae ]]; then

    	if [[ -z $element ]]; then

    	    element="${MAGENTA}no element selected${NOC}"

    	elif [[ -z $element_value ]]; then

    	    element="$element ${MAGENTA}no value${NOC}"

    	fi

    fi

    ## autoentry
    if [[ -n $ae ]]; then

    	# [TODO] [[ -z $element_value ]] && element_value="${MAGENTA}no element value${NOC}"
    	[[ -z $element_value ]] && notify-send "no element value" && exit

    fi
}


human_info()
{
    error_message

    if [[ -z $ae ]]; then

    	if [[ "$object" == 'login' ]]; then

	   printf "$object ${MAGENTA}$error${NOC}\n"

    	else

	   printf "$object $element ${MAGENTA}$error${NOC}\n"

    	fi

    elif [[ -n $ae ]]; then

    	notify-send "$element"
    	sleep $t

    fi

}


error_message()
{
    ## selected empty line in element menu
    if [[ $element == " " ]]; then

    	error="no valid selection"

    fi
}


autoentry()
{
    ae=1
    ## sleep time
    t=5

    element="url"
    get_element_value
    qutebrowser --target tab $element_value &
    t=$((t * 2))
    human_info
    #notify-send "$element"
    #sleep $((t * 2))

    element="userid"
    get_element_value
    t=$t
    human_info
    #notify-send "$element"
    #sleep $t

    element="password"
    get_password 1> /dev/null #no stdout
    human_info
    #notify-send "$element"
    #sleep $t

    element="otp"
    get_otp
    if [[ -z $otp ]]; then
    	human_info
    	#notify-send "$element"
    	#sleep $t
    fi

    element="unlock"
    get_element_value
    if [[ -z $otp ]]; then
    	human_info
    	#notify-send "$element"
    	#sleep $t
    fi
}


get_object_name()
{
    printf "$object" | wl-copy -n -o
}


process_element()
{
    case $element in

    	password)
	    get_password
	    human_info
	    ;;

    	otp)
	    get_otp
	    human_info
	    ;;

    	autoentry)
	    autoentry
	    ;;

    	show)
	    element='show'
	    pass_element
	    ;;

    	edit)
	    element='edit'
	    pass_element
	    ;;

    	copy)
	    get_object_name
	    human_info
	    ;;

    	log_out)
	    log_out
	    ;;

    	"")
	    human_info
	    ;;

    	*)
	    get_element_value
	    human_info
	    ;;

    esac
}


main()
{
    get_object
    process_object
    get_element
    process_element
}

main
