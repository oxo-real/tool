#!/bin/bash
#
##
###                                 _
###  _ __   __ _ ___ ___  __ _  ___| |_
### | '_ \ / _` / __/ __|/ _` |/ _ \ __|
### | |_) | (_| \__ \__ \ (_| |  __/ |_
### | .__/ \__,_|___/___/\__, |\___|\__|
### |_|                  |___/
###
###  _ _|_ _   ._  _  _
### (_\/|_(_)\/|_)(_|(/_
###   /      / |   _|
###
### passget: fzf cli wrapper for pass
###
### usage:	passget
###			OR
###			passget $object
###			OR
###			passget $object $element
##
#


source $XDG_DATA_HOME/git/code/sources/functions/text_appearance

object=$1
element=$2

## store_l is the symlink location (to the pass password store)
## recommended to mount an encrypted vault container
## then symlink .password-store to a container mountpoint
## default symlink:	$HOME/.password-store
## default target:	$HOME/dock/vlt/pass
store_l="$HOME/.password-store"
## store is the genuine password store location
store=$(readlink $store_l)

## objects can be searched for one or more elements
## regular elements are: url, userid, password
## elements that can be retrieved with passget are:
elements=("1 url" "2 userid" "3 password" "4 otp" "5 unlock" "6 peacto" "7 auto_entry" \
	"------------" \
	"91 show" "92 edit")

## the pass help file refers to objects by naming them 'passwords'
## so insert a new password means making a new .gpg file
## pass expects the first line of the gpg file to be the password
## the gpg file can contain more than just the password though
## this script make use of that
## here an object is the way pass represent a gpg file
## (filename without .gpg extension)


check_mountpoint()
{
	mountpoint -q $store_l
	[[ $? -ne 0 ]] && printf "store is not mounted\n" && exit 32
}


get_object()
{
	if [[ -z $object ]]; then

		object=$(find -L $store_l -type f -iname '*.gpg' | \
			# with sed we remove the leading path of $store_l
			# internal field separator is '|'
			# because the path itself contains '/'
			sed "s|$store_l/||g" | \
			# with sed we remove the trailing .gpg extension
			sed "s/.gpg//g" | \
			sort | \
			fzf)

	fi
}


get_element_type()
{
	if [[ -z $element ]]; then

		element=$(printf '%s\n' "${elements[@]}" | fzf | awk '{print $2}')

	fi
}


process_object()
{
	# otp object
	if [[ -n $(printf "$object" | grep ^otp) ]]; then

		get_otp

		exit 0

	fi
}


get_element_value()
{
	element_value=$(pass show $object | grep ^$element: | awk '{print $2}')

	[[ -z $element_value ]] && printf "${RED}no element value${NOC}\n" && exit 10

	printf "$element_value" | wl-copy -n -o
}



get_password()
{
	pass $object | head -n 1 | wl-copy -n -o
}


get_otp()
{
	# redirection to the separate otp file
	if [[ "$(printf $object | head -c 4)" != "otp_" ]]; then

		object="otp_$object"

	fi

	if [[ -f $store/$object.gpg ]]; then

		pass otp $object | wl-copy -n -o

	else

		otp=0

	fi


	exit
}


pass_element()
{
	pass $element $object
}


auto_entry()
{
	## sleep time
	t=5

	element="url"
	get_element
	qutebrowser $url &
	notify-send "$element"
	sleep $((t * 2))

	element="userid"
	get_element
	notify-send "$element"
	sleep $t

	element="password"
	get_password 1> /dev/null #no stdout
	notify-send "$element"
	sleep $t

	element="otp"
	get_otp
	if [[ -z $otp ]]; then
		notify-send "$element"
		sleep $t
	fi

	element="unlock"
	get_element
	notify-send "$element"
}


process_element()
{
	case $element in

		password)
			get_password
			;;

		otp)
			get_otp
			;;

		auto_entry)
			auto_entry
			;;

		show)
			printf "$object\n"
			pass_element
			;;

		edit)
			pass_element
			;;

		---------)
			exit 99
			;;

		*)
			get_element_value
			;;

	esac
}


check_mountpoint
get_object
process_object
get_element_type
process_element
