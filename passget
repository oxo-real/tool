#!/usr/bin/env sh
#
##
###                                 _
###  _ __   __ _ ___ ___  __ _  ___| |_
### | '_ \ / _` / __/ __|/ _` |/ _ \ __|
### | |_) | (_| \__ \__ \ (_| |  __/ |_
### | .__/ \__,_|___/___/\__, |\___|\__|
### |_|                  |___/
###  _ _|_ _   ._  _  _
### (_\/|_(_)\/|_)(_|(/_
###   /      / |   _|
###
###	2020 - 2022  |  cytopyge
###
### passget:	fzf cli wrapper for pass
###
### usage:		passget
###				passget $object
###				passget $object $element
###
###				passget open
###				passget login
###				passget status
###				passget logout
###				passget close
##
#


object=$1
element=$2

## store_l is the symlink location (to the pass password store)
## recommended to mount an encrypted vault container
## then symlink .password-store to a container mountpoint
## default symlink:	$HOME/.password-store
## default target:	$HOME/dock/vlt/pass
store_l="$HOME/.password-store"

## store is the genuine password store location
store=$(readlink $store_l)

crypto_source="$XDG_DATA_HOME/c/keys/pass/vlt_pass"

source $XDG_DATA_HOME/c/git/code/sources/functions/text_appearance
source $XDG_DATA_HOME/c/git/code/sources/functions/get_sudo

## objects can be searched for one or more elements
## regular elements are: url, userid, password
## elements that can be retrieved with passget are:
elements=(\
	"1 url" \
	"2 userid" \
	" " \
	"3 password" \
	"4 otp" \
	"5 unlock" \
	"6 peacto" \
	" " \
	"A autoentry" \
	" " \
	"E edit" \
	"S show" \
	"C copy" \
	" " \
	"ESC cancel")

## the pass help file refers to objects by naming them 'passwords'
## so insert a new password means making a new .gpg file
## pass expects the first line of the gpg file to be the password
## the gpg file can contain more than just the password though
## this script makes use of that
## here an object is the way pass represents a gpg file
## (filename without .gpg extension)


get_object()
{
	case $object in

		login)
			log_in
			;;

		logout)
			log_out
			;;

		open)
			vault_open
			;;

		close)
			log_out
			close
			;;

		status)
			show_status
			;;

		'')
			get_mountpoint_status
			case $mp_status in

				0)
					object='login'
					pass_mount
					;;

				$store)
					object=$(find -L $store_l -type f -iname '*.gpg' | \
						# with sed we remove the leading path of $store_l
						# internal field separator is '|'
						# because the path itself contains '/'
						sed "s|$store_l/||g" | \
						# with sed we remove the trailing .gpg extension
						sed "s/.gpg//g" | \
						sort | \
						fzf --prompt='select object ')
					;;
			esac
	esac
}


vault_open()
{
	pass_mount
}


log_in()
{
	get_mountpoint_status

	case $mp_status in

		$store)
			element='show'
			gpg_decrypt
			pass_element
			;;

		*)
			printf "${MAGENTA}no_mp${NOC}\n"
			exit 11
			;;

	esac
}


log_out()
{
	gpg-connect-agent -q reloadagent /bye >/dev/null
	printf "${BLUE}logged out, bye!${NOC}\n"
	[[ "$object" == 'close' ]] || exit 0
}


close()
{
	sh vault close $store
	exit 0
}


show_status()
{
	get_mountpoint_status
	get_cache_status
	printf "$mp_status $cache_status\n"
	exit 0
}


get_mountpoint_status()
{
	mountpoint -q $store_l && mp_status=$store || mp_status=0
	#[[ $? -ne 0 ]] && \
	#	printf "${MAGENTA}password-store not mounted${NOC}\n"
}


get_cache_status()
{
	# 1 | 0 (no cache)
	cache_status=$(gpg-connect-agent 'keyinfo --list' /bye 2>/dev/null | \
		awk 'BEGIN{CACHED=0} /^S/ {if($7==1){CACHED=1}} END\
		{if($0!=""){print CACHED} else {print "none"}}')
}


pass_mount()
{
	# pass crypto source location

	# pass mount destination
	## vlt_pass mounted => $HOME/.password-store becomes pale
	pass_mount="$HOME/dock/vlt/pass"
	[[ -d $pass_mount ]] || mkdir -p $pass_mount

	get_sudo

	# pass luksuuid
	luksuuid=$(sudo cryptsetup luksUUID $crypto_source)
	printf "$luksuuid" | wl-copy -n -o

	## check for mountpoint
	lsblk_rpaf=$(lsblk -rpaf --noheadings)
	loopdevice=$(printf $lsblk_rpaf | grep $luksuuid | awk '{print $1}')
	mapper_data=$(lsblk -rpaf --noheadings $loopdevice)
	mountpoint=$(printf $mapper_data | awk '{print $8}')

	if [[ -z "$mountpoint" ]]; then

		vault open $crypto_source $pass_mount

	elif [[ -n "$mountpoint" ]]; then

		wl-copy --clear

	fi

	case $object in

		open)
			# only mount vault, no login
			exit 0
			;;

	esac
}


gpg_decrypt()
{
	# always reset cached gpg password
	gpg-connect-agent -q reloadagent /bye >/dev/null

	printf "\n${YELLOW}${BOLD} O--, ${NORMAL}${NOC}\n"
	tput civis
	sleep 2
	tput cnorm
	pwgn
	echo
}


get_element()
{
	if [[ -z $element ]]; then

		element=$(printf '%s\n' "${elements[@]}" | fzf --prompt='select element ' | awk '{print $2}')

	fi
}


process_object()
{
	# empty object selection
	[[ -z $object ]] && exit 0

	# existing object
	check_obj_exist
	if [[ $obj_exist == 1 ]]; then

		:

	else

		printf "${MAGENTA}no object${NOC}\n" && exit 70

	fi

	# otp object
	if [[ -n $(printf "$object" | grep ^otp) ]]; then

		get_otp
		exit 0

	fi

	# TODO if only passget is entered when status is 0 0
	get_cache_status
	case $cache_status in

		0)
			log_in
			;;

	esac
}


get_element_value()
{
	element_value=$(pass show $object | grep ^$element: | awk '{print $2}')

	check_element_value

	## '%s' prevents 'invalid format character' error
	printf '%s' "$element_value" | wl-copy -n -o
}



get_password()
{
	pass $object | head -n 1 | wl-copy -n -o
}


check_obj_exist()
{
	[[ -f "$store/$object.gpg" ]] && obj_exist=1
}


get_otp()
{
	# redirection to the separate otp file
	if [[ "$(printf $object | head -c 4)" != "otp_" ]]; then

		object="otp_$object"

	fi

	#TODO
	#check_obj_exist && pass otp $object | wl-copy -n -o
	if [[ -f $store/$object.gpg ]]; then

		pass otp $object | wl-copy -n -o

	fi

	# reset object value for human info
	object=$(printf $object | cut -c 5-)

	#[[ -z $element_value ]] && element="$element ${MAGENTA}no element value${NOC}"
}


pass_element()
{
	# run pass natively with $element
	clear
	human_info
	pass $element $object
}


check_element_value()
{
	## no autoentry
	if [[ -z $ae ]]; then

		if [[ -z $element ]]; then

			element="${MAGENTA}no element selected${NOC}"

		elif [[ -z $element_value ]]; then

			element="$element ${MAGENTA}no value${NOC}"

		fi
		#[[ -z $element ]] && printf "${MAGENTA}no element selected${NOC}\n" && exit 10
		#[[ -z $element_value ]] && printf "${MAGENTA}no element value${NOC}\n" && exit 10

	fi

	## autoentry
	if [[ -n $ae ]]; then

		# [TODO] [[ -z $element_value ]] && element_value="${MAGENTA}no element value${NOC}"
		[[ -z $element_value ]] && notify-send "no element value" && exit

	fi
}


human_info()
{
	error_message

	if [[ -z $ae ]]; then

		if [[ "$object" == 'login' ]]; then
			printf "$object ${MAGENTA}$error${NOC}\n"

		else

			printf "$object $element ${MAGENTA}$error${NOC}\n"

		fi

	elif [[ -n $ae ]]; then

		notify-send "$element"
		sleep $t

	fi

}


error_message()
{
	## selected empty line in element menu
	if [[ $element == " " ]]; then

		error="no valid selection"

	fi
}


autoentry()
{
	ae=1
	## sleep time
	t=5

	element="url"
	get_element_value
	qutebrowser --target tab $element_value &
	t=$((t * 2))
	human_info
	#notify-send "$element"
	#sleep $((t * 2))

	element="userid"
	get_element_value
	t=$t
	human_info
	#notify-send "$element"
	#sleep $t

	element="password"
	get_password 1> /dev/null #no stdout
	human_info
	#notify-send "$element"
	#sleep $t

	element="otp"
	get_otp
	if [[ -z $otp ]]; then
		human_info
		#notify-send "$element"
		#sleep $t
	fi

	element="unlock"
	get_element_value
	if [[ -z $otp ]]; then
		human_info
		#notify-send "$element"
		#sleep $t
	fi
}


get_object_name()
{
	printf "$object" | wl-copy -n -o
}


process_element()
{
	case $element in

		password)
			get_password
			human_info
			;;

		otp)
			get_otp
			human_info
			;;

		autoentry)
			autoentry
			;;

		show)
			element='show'
			pass_element
			;;

		edit)
			element='edit'
			pass_element
			;;

		copy)
			get_object_name
			human_info
			;;

		log_out)
			log_out
			;;

		"")
			human_info
			;;

		*)
			get_element_value
			human_info
			;;

	esac
}


get_object
process_object
get_element
process_element
