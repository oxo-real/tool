#! /usr/bin/env sh

###                 _
###  _ __ ___   ___| |_ __ _ _ __
### | '_ ` _ \ / _ \ __/ _` | '__|
### | | | | | |  __/ || (_| | |
### |_| |_| |_|\___|\__\__,_|_|
###
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
metar
get metar (optionally taf, notam, pirep, airsigmet, nbm and gfsmav)
copyright (c) 2020 - 2025  |  oxo
----------------------------------------------------------------------
GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org
======================================================================

# usage:
# metar [taf] $ident_1 [$ident_n]
# metar [taf] [near] $lat $lon | $ident_1

## examples
## meatar KLAX
## metar near KLAX
## metar taf near 34 -118

# '

args="$@"


# variable initialization
script_name=metar
developer=oxo
initial_release=2020

avwx_domain=https://avwx.rest/api
source $XDG_DATA_HOME/c/keys/api/avwx

## declare globally
show_taf=0
near=0

args_fetch ()
{
    while [[ "$1" ]]; do

	case "$1" in

	    taf )
		## include taf
		show_taf=1
		shift
		;;

	    near )
		## fetch nearby stations
		near=1
		shift
		## one decimal coordinate pair; i.e. 50.0 -10
		lat="$1"

		if [[ ! "$lat" =~ [a-zA-Z] ]]; then

		    ## arg is lat
		    shift
		    lon="$1"

		else

		    ## presume arg (lat) is station
		    ident="$lat"

		    station_data_retrieval

		    ## get stations' lat lon
		    lat=$(printf '%s' "$station_raw" | jq '.latitude')
		    lon=$(printf '%s' "$station_raw" | jq '.longitude')

		fi

		nearby_stations "$lat" "$lon"
		;;

	    * )
		## arg is station
		ident="$1"

		station_data_retrieval
		shift
		;;

	esac

    done
}


station_data_retrieval ()
{
    station_raw=$(curl -sSL --request GET --url "$avwx_domain/station/$ident" --header "$avwx_api_key")

    metar_raw=$(curl -sSL --request GET --url "$avwx_domain/metar/$ident" --header "$avwx_api_key")

    case $show_taf in

	1 )
	    taf_raw=$(curl -sSL --request GET --url "$avwx_domain/taf/$ident" --header "$avwx_api_key")
	    ;;

    esac

    # distance and direction from $latlon
    case $near in

	1 )
	    station_lat=$(printf '%s' "$station_raw" | jq '.latitude')
	    station_lon=$(printf '%s' "$station_raw" | jq '.longitude')

	    distance_bearing $lat $lon $station_lat $station_lon
	    ;;

    esac

    ## avwx enterprise key
    # pirep_raw=$(curl --include --header "Content-Type: text/plain" --header "$avwx_api_ent_key" "$avwx_domain"/pirep/"$ident")
    # airsigmet_raw=$(curl --include --header "Content-Type: text/plain" --header "$avwx_api_ent_key" "$avwx_domain"/airsigmet/"$ident")
    # notam_raw=$(curl --include --header "Content-Type: text/plain" --header "$avwx_api_ent_key" "$avwx_domain"/notam/"$ident")
    # nbm_raw=$(curl --include --header "Content-Type: text/plain" --header "$avwx_api_ent_key" "$avwx_domain"/nbm/"$ident")
    # gfsmav_raw=$(curl --include --header "Content-Type: text/plain" --header "$avwx_api_ent_key" "$avwx_domain"/gfs/mav/"$ident")
}


nearby_stations ()
{
    near_raw=$(curl -sSL --request GET --url "$avwx_domain/station/near/${lat},${lon}" --header "$avwx_api_key")
    station_list=$(printf '%s' "$near_raw" | jq '.[].station.icao' | tr -d '"' | sed '/null/d')

    while IFS= read -r ident; do

	station_data_retrieval
	data_presentation

    done <<< "$station_list"

    exit 0
}


data_presentation ()
{
    ## station data
    station_pretty_id=$(printf '%s' "$station_raw" | jq '.name + ", " + .city + " " + .country + " " + (.latitude|tostring) + " " + (.longitude|tostring) + " " + (.elevation_m|tostring) + "m"' | tr -d '"')

    printf '      %s ' "$station_pretty_id"

    case $near in

	1 )
	    station_dist=$(printf '%s' "$dist_bear" | cut -d ' ' -f 1)
	    station_bear=$(printf '%s' "$dist_bear" | cut -d ' ' -f 2)

	    ## no negative bearings
	    if [[ "$(printf '%s' "$station_bear" | head -c 1)" == '-' ]]; then

		station_bear=$(echo "360 + $station_bear" | bc)

	    fi

	    ## rounding numbers
	    station_dist=$(printf '%.*f\n' 1 "$station_dist")
	    station_bear=$(printf '%.*f\n' 0 "$station_bear")

	    printf '%skm %s°\n' "$station_dist" "$station_bear"
	    ;;

	* )
	    echo
	    ;;

    esac

    ## metar data
    metar=$(printf '%s' "$metar_raw" | jq '.raw' | tr -d '"')
    printf 'metar %s\n' "$metar"

    ## taf data
    case $show_taf in

	1 )
	    taf=$(printf '%s' "$taf_raw" | jq '.raw' | tr -d '"')
	    printf '  taf %s\n' "$taf"
	    ;;

    esac

    echo
}


haversine ()
{
    if test "$#" -ne 4; then
	echo >&2 "E: syntax: $0 lat1 lon1 lat2 lon2"
	exit 1
    fi

    set -e

    # make GNU bc use POSIX mode and shut up
    BC_ENV_ARGS=-qs
    export BC_ENV_ARGS

    # assignment of constants, variables and functions
    # p: multiply with to convert from degrees to radians (π/180)
    # r: earth radius in metres
    # d: distance
    # h: haversine intermediate
    # i,j: (lat,lon) point 1
    # x,y: (lat,lon) point 2
    # k: delta lat
    # l: delta lon
    # m: sin(k/2) (square root of hav(k))
    # n: sin(l/2) (  partial haversine  )
    # n(x): arcsin(x)
    # r(x,n): round x to n decimal digits
    # v(x): sign (Vorzeichen)
    # w(x): min(1, sqrt(x)) (Wurzel)

    bc -l <<-EOF
    scale=64
    define n(x) {
	if (x == -1) return (-2 * a(1))
	if (x == 1) return (2 * a(1))
	return (a(x / sqrt(1 - x*x)))
	}
    define v(x) {
	if (x < 0) return (-1)
	if (x > 0) return (1)
	return (0)
	}
    define r(x, n) {
	auto o
	o = scale
	if (scale < (n + 1)) scale = (n + 1)
	x += v(x) * 0.5 * A^-n
	scale = n
	x /= 1
	scale = o
	return (x)
	}
    define w(x) {
	if (x >= 1) return (1)
	return (sqrt(x))
	}
/* WGS84 reference ellipsoid: semimajor axis (metres), flattening */
i = 6378137.000
x = 1/298.257223563
/* other axis */
j = i * (1 - x)
/* mean radius resulting */
r = (2 * i + j) / 3
/* coordinates */
p = (4 * a(1) / 180)
i = (p * $1)
j = (p * $2)
x = (p * $3)
y = (p * $4)
/* calculation */
k = (x - i)
l = (y - j)
m = s(k / 2)
n = s(l / 2)
h = ((m * m) + (c(i) * c(x) * n * n))
d = 2 * r * n(w(h))
r(d, 3)
EOF

    # output is in metres, rounded to millimetres, error < ¼% in WGS84
    # https://evolvis.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=useful-scripts/mirkarte.git;a=blob;f=geo.sh;hb=HEAD
}


distance_bearing ()
{
    dist_bear=$(\
		awk -v lat1="$1" -v lat2="$3" -v lon1="$2" -v lon2="$4" '
    BEGIN {
    #some basic info

    pi = 3.14159
    R  = 6371

    lat1r = lat1 * pi / 180
    lat2r = lat2 * pi / 180
    lon1r = lon1 * pi / 180
    lon2r = lon2 * pi / 180

    dLat = lat2r - lat1r
    dLon = lon2r - lon1r

    #Distance calculations
    a   = sin(dLat/2) * sin(dLat/2) + cos(lat1r) * cos(lat2r) * sin(dLon/2) * sin(dLon/2)
    c1  = sqrt(a)
    c2  = sqrt(1 - a)
    cat = atan2(c1,c2)
    c   = 2 * cat
    d   = R * c

    #Bearing calculation
    x = cos(lat1r) * sin(lat2r) - sin(lat1r) * cos(lat2r) * cos(dLon)
    y = sin(dLon) * cos(lat2r)

    brng = atan2(y,x)
    brn  = brng * 180 / pi
    #print brng * 180 / pi

    #Mid point calculation

    Bx = cos(lat2r) * cos(dLon)
    By = cos(lat2r) * sin(dLon)
    atc1 = sin(lat1r) + sin(lat2r)
    atc2 = sqrt( (cos(lat1r) + Bx )^2 + By^2 )

    latmidr = atan2(atc1,atc2)
    latmid  = latmidr * 180 / pi

    atc3 = By
    atc4 = cos(lat1r) + Bx

    lonmidr = lon1r + atan2(atc3,atc4)
    lonmid  = lonmidr * 180 / pi

    print d, brn
    #print d, brn, latmid, lonmid
    }
    '
    )
}


main ()
{
    args_fetch $args
    station_data_retrieval
    data_presentation
}

main
