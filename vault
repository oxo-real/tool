#!/bin/bash

# usage: sudo sh vault open <target> <mountpoint>
# usage: sudo sh vault close <target> #TODO mountpoint #TODO mapperID
# usage: sudo sh vault create <target> <size>

developer="cytopyge"
script_name="vault"
initial_release_year=2019
source_dir="$HOME/_git/code/sources/functions"

# general function definitions

## define colors
source $source_dir/text_appearance

## reply functions
source $source_dir/reply_functions

## initial_screen
source $source_dir/splash_screen

## user authentication
source $source_dir/get_sudo


set -e


# options (open, close, create or info)
option=$1
# target (<filename>, <mountpoint>, <vlt_mapper> or all)
target=$2



source $HOME/_git/code/sources/functions/reply_functions
## define colors
source $source_dir/text_appearance


check_file_exists() {

	if [[ -f $target ]]; then

		printf "${RED}$target already exists!${NOC}\n"
		printf "overwrite? (y/N) "
		reply_single
		echo

		if printf "$reply" | grep -iq "^y"; then

			printf "${RED}about to overwrite $target${NOC}\n"
			printf "really sure? (y/N) "
			reply_single
			echo

			if printf "$reply" | grep -iq "^y"; then

				return

			else

				printf "abort overwriting $target\n"
				exit 11

			fi

		else

			printf "abort overwriting $target\n"
			exit 2

		fi

	fi

}


check_container_size() {

	if [ $size -lt 18 ]; then

		# to prevent error: 'Requested offset is beyond real size of device'
		printf "${RED}minimum vault size is 18 MB${NOC}\n" && exit 18

	fi

}


create_vlt_mapper_name() {

	# create pretty unique traceable /dev/mapper/vlt_ name

	random_hex="$(< /dev/random tr -d -c "[:xdigit:]" | head -c 6)"

	mapping_name="vlt_$random_hex"
	vlt_mapper="/dev/mapper/vlt_$random_hex"

}


create_vault() {

	# temporary mountpoint
	#mountpoint="$HOME/_temp/$random_hex"
	#mkdir -p "$mountpoint"
	#echo

	printf "writing random data to $target\n"

	dd \
		if=/dev/random \
		of=$target \
		bs=1M \
		count=$size \
		iflag=fullblock \
		status=progress

	echo
	printf "setting up crypto on $target\n"

	## cryptsetup with luks2
	cryptsetup luksFormat --type luks2 --verify-passphrase $target
	#cryptsetup -y luksFormat $target
	echo

	## other option:
	## cryptsetup with plain dm-crypt
	#cryptsetup \
	#	-y \
	#	--type plain \
	#	--cipher=aes-xts-plain64 \
	#	--hash=sha512 \
	#	--key-size=512 \
	#	--offset=0 \
	##	--key-file=/dev/sdX \
	#	--keyfile-offset=0 \
	#	$target enc

	## validate target
	printf "validating $target:\n"
	file $target

}


open_luks() {

	echo
	printf "opening $target to $mapping_name\n"
	sudo cryptsetup open --type luks2 $target $mapping_name

}


make_fs () {

	echo
	printf "writing ext4 filesystem to $vlt_mapper\n"
	sudo mkfs.ext4 -L VAULT -j $vlt_mapper

}


permissions() {

	#printf "write permission to $mountpoint\n"
	sudo chown -R $USER:wheel $mountpoint

}


close_luks() {

	if [[ $option == "create" ]]; then

		#[TODO] can be one algo? (remove if)
		sudo cryptsetup close $vlt_mapper
		printf "cryptsetup closed $vlt_mapper\n"
		clear_cache
		printf "${GREEN}$target created succesfully${NOC}\n"

	else

		sudo cryptsetup close $vlt_mapper
		printf "cryptsetup closed $vlt_mapper\n"
		clear_cache

	fi

}


clean_up() {

	# extra if, to be sure rm only happens
	# on temporarily mountpoint while creating a new vault

	if [[ $option == "create" ]]; then

		rmdir "$mountpoint"

	fi

}


check_mp_dir() {

	#mountpoint=$3

	## existence & emptyness (for mounting)

	## mountpoint entry
	if [[ -z $mountpoint ]]; then

		printf "${RED}missing mountpoint entry\nvault open <vault_file> <mountpoint>${NOC}\n"
		exit 3

	## directory existence
	elif [[ -d $mountpoint ]]; then

		## directory in mountinfo (/proc/self/mountinfo)?
		## or in other words: is it a mountpoint already?
		if [[ "$(mountpoint -q $mountpoint)" == "0" ]]; then

			printf "${RED}$mountpoint is already a mountpoint${NOC}\n" && exit 3

		fi

	elif [[ ! -d $mountpoint ]]; then

			## directory does not exist
			printf "${RED}$mountpoint does not exist!${NOC}\n" && exit 3

	fi

}


generate_pw() {

	echo
	printf "starting pwgn...\npress 'n' to abort "

	reply_single_hidden_timed
	echo

	if printf "$reply" | grep -iq "^n"; then

		# exit from this loop and continue
		return

	else

		echo
		sh ~/_git/code/tools/pwgn

	fi

}


mounting() {

	sudo mount $vlt_mapper $mountpoint
	echo
	printf "mounted $vlt_mapper to $mountpoint\n"

	show_info

}


get_vault_data() {

	# single target (vault close 'target')

	#[TODO] two mountpoints: .../s and .../s2

	## scenario1: container
	## target is a luks encrypted container file
	## vault close 'container'

	filetype=$(file $target)

	if [[ -n $(printf "$filetype" | grep -i 'luks encrypted') ]]; then

		target_type="luks_container"

		luks_container=$target

		luks_uuid=$(printf "$filetype" | awk '{print $11}')

		loopback_device=$(losetup -j $target | awk -F ':' '{print $1}')

		loop_uuid=$(lsblk -parf | grep $loopback_device | awk '{print $4}')

		vlt_map_and_mp=$(lsblk -p $(losetup -j $target | awk -F : '{print $1}') |\
			tail -n 1 | sed 's/[^\/]*//')

		vlt_mapper=$(echo "$vlt_map_and_mp" | awk '{print $1}')

		mountpoint=$(echo "$vlt_map_and_mp" | awk '{print $7}')

	fi


	## scenario2: mountpoint
	## target is a valid mountpoint
	## vault close 'mountpoint

	if [[ ! $(mountpoint $target | grep not) ]]; then

		### $2 user entry ($target) is not (!) not (grep not) a mountpoint
		### $2 is therefore assumed to be a mountpoint

		target_type="mountpoint"

		mountpoint=$target

		### check if mountpoint has a vlt_mapper
		vlt_mapper=$(lsblk -rp | grep $mountpoint | awk '{print $1}')

		luks_uuid=$(lsblk -parf | grep $vlt_mapper | awk '{print $5}')

		loopback_device=$(lsblk -parf | grep -B 1 $luks_uuid | head -n 1 | awk '{print $1}')

		loop_uuid=$(lsblk -parf | grep $loopback_device | awk '{print $4}')

		luks_container=$(losetup $loopback_device | cut -d "(" -f2 | cut -d ")" -f1)

	fi


	## scenario3: vlt_mapper
	## assuming target is a valid vlt_mapper
	## vault close 'vlt_mapper'

	if [[ -z $target_type ]]; then

		vlt_target=$(lsblk -parf | grep vlt_ | awk '{print $1}' | grep $target)

		if [[ -n $vlt_target ]]; then

			## $2 user entry ($target) is a loopback device (vlt_mapper)

			target_type="vlt_mapper"

			vlt_mapper=$target

			mountpoint=$(mount | grep $vlt_mapper | cut -d " " -f 3)

			luks_uuid=$(lsblk -parf | grep $vlt_mapper | awk '{print $5}')

			loopback_device=$(lsblk -parf | grep -B 1 $luks_uuid | head -n 1 | awk '{print $1}')

			loop_uuid=$(lsblk -parf | grep $loopback_device | awk '{print $4}')

			luks_container=$(losetup $loopback_device | cut -d "(" -f2 | cut -d ")" -f1)

		else

			printf "${RED}no loopback device detected for $target${NOC}\n"
			echo

			if [[ $option == "open" ]]; then

				printf "probably an invalid target entry\nplease try again\n"
				exit

			fi

		fi

	fi

}


show_info() {

		echo

		mountpoint_show="$mountpoint"
		if [[ -z $mountpoint ]]; then mountpoint_show="n/a"; fi
		printf "%21s %s\n" "mountpoint:" $mountpoint_show

		vlt_mapper_show="$vlt_mapper"
		if [[ -z $vlt_mapper ]]; then vlt_mapper_show="n/a"; fi
		printf "%21s %s\n" "vlt_mapper:" $vlt_mapper_show

		echo

		luks_container_show="$luks_container"
		if [[ -z $luks_container ]]; then luks_container_show="n/a"; fi
		printf "%21s %s\n" "crypto container:" $luks_container_show

		luks_uuid_show="$luks_uuid"
		if [[ -z $luks_uuid ]]; then luks_uuid_show="n/a"; fi
		printf "%21s %s\n" "luks_uuid:" $luks_uuid_show

		echo

		loopback_device_show="$loopback_device"
		if [[ -z $loopback_device ]]; then loopback_device_show="n/a"; fi
		printf "%21s %s\n" "loopback device:" $loopback_device_show

		loop_uuid_show="$loop_uuid"
		if [[ -z $loop_uuid ]]; then loop_uuid_show="n/a"; fi
		printf "%21s %s\n" "loop_uuid:" $loop_uuid_show

}


close_target() {

	# all (vault close 'all')

	if [[ $target == "all" ]]; then

		close_all
		exit

	fi

	get_vault_data
	show_info

	unmount
	close_luks

}


unmount() {

	if [[ -n $mountpoint ]]; then

		echo
		printf "${RED}unmount & close? (Y/n)${NOC} "

		reply_single
		echo

		if printf "$reply" | grep -iq "^n"; then

			exit

		else

			sudo umount $mountpoint
			printf "unmounted $vlt_mapper from mountpoint $mountpoint\n"

		fi

		#[TODO] ivm create?
		#close_luks

	fi

}


clear_cache() {

	sudo sysctl --write vm/drop_caches=3
	exit 0

}


get_all_vlt_mappers() {

	vlt_mappers=$(lsblk -rp | grep vlt_ | sort -k 7 | awk '{print $1}')

	#[TODO] remove ops
	echo
	printf "TEST vlt_mappers:\n$vlt_mappers\n"
	echo


	if [[ -z "$vlt_mappers" ]]; then

		printf "${RED}no mapped vaults${NOC}\n"
		exit

	fi

}


vault_info() {

	# show all mapper paths with their mountpoints

	info=$(lsblk -rp | grep vlt_ | sort -k 7)

	if [[ -z "$info" ]]; then

		printf "${RED}no mapped vaults${NOC}\n"

	else

		printf "$info\n"

	fi

}


close_all() {

	unset target

	vault_info

	get_all_vlt_mappers

	#printf "sure to all unmount and close? (Y/n) "
	#echo
	#TODO yesno
	#TODO option: quick close all

	#for vlt_mapper in "${vlt_mappers[@]}"
	##for vlt_mapper in /dev/mapper/vlt_*
	##for vlt_mapper in $vlt_mappers
	#@#@printf "$vlt_mappers" | while read -r vlt_mapper; do

	while IFS='' read -r vlt_mapper; do

		#[TODO] remove ops
		printf "processing: $vlt_mapper\n"
		echo

		## get mountpoint of the current vlt_mapper
		mountpoint=$(mount | grep $vlt_mapper | cut -d " " -f 3)

		#[TODO] remove ops
		printf "mp: $mountpoint\n"
		echo

		sudo umount $mountpoint
		printf "unmounted $vlt_mapper from mountpoint $mountpoint\n"

		close_luks

	#@#@done
	done <<< "$vlt_mappers"

	echo
	printf "${GREEN}all vaults closed succesfully${NOC}\n"

}


# vault info

if [[ $option == "info" ]]; then

	vault_info

fi


# create vault

if [[ $option == "create" ]]; then

	size=$3
	check_file_exists
	check_container_size
	create_vlt_mapper_name
	create_vault
	open_luks
	make_fs
	close_luks
	clean_up

fi


# opening vaults

## open a specific vault
if [[ $option == "open" ]]; then

	mountpoint=$3
	check_mp_dir
	generate_pw
	create_vlt_mapper_name
	open_luks
	mounting
	permissions
	get_vault_data
	show_info

fi


# closing vaults

## close a vault
if [[ $option == "close" ]]; then

	close_target

fi
