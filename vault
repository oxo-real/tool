#!/bin/bash

# usage: sudo sh vault open <target> <mountpoint>
# usage: sudo sh vault close <target> #TODO mountpoint #TODO mapperID
# usage: sudo sh vault create <target> <size>

set -e

# options (open, close, create)
option=$1
# target (<filename>, <mountpoint>, all)
target=$2


source $HOME/_git/code/sources/functions/reply_functions

check_file_exists() {

	if [[ -f $target ]]; then

		printf "$target already exists!\n"
		printf "overwrite? (y/N) "
		reply_single
		echo

		if printf "$reply" | grep -iq "^y"; then

			printf "about to overwrite $target\n"
			printf "sure? (y/N) "
			reply_single
			echo

			if printf "$reply" | grep -iq "^y"; then

				return

			else

				printf "abort overwriting $target\n"
				exit 11

			fi

		else

			printf "abort overwriting $target\n"
			exit 2

		fi

	fi

}


check_mp_dir() {

	## existence & emptyness (for mounting)
	if [[ -d $mountpoint ]]; then
		if [ "$(ls -A $mountpoint)" ]; then
			printf "$mountpoint is already a mountpoint\n" && exit 3
		fi
	else
		printf "$mountpoint does not exist!\n" && exit 3
	fi

}


create_mapper_name() {

	# create traceable /dev/mapper name
	random_hex="$(< /dev/random tr -d -c "[:xdigit:]" | head -c 6)"
	mapping_name="vlt_$random_hex"

}


create() {

	echo
	printf "writing random data to $target\n"
	dd \
		if=/dev/random \
		of=$target \
		bs=1M \
		count=$size \
		iflag=fullblock \
		status=progress

	echo
	printf "setting up crypto on $target\n"

	## luks2
	cryptsetup -y luksFormat $target
	## plain dm-crypt
	cryptsetup \
		-y \
		--type plain \
		--cipher=aes-xts-plain64 \
		--hash=sha512 \
		--key-size=512 \
		--offset=0 \
	#	--key-file=/dev/sdX \
		--keyfile-offset=0 \
		$target enc
	echo
	printf "validating $target:\n"
	file $target

}


open_luks() {

	echo
	printf "opening $target to $mapping_name\n"
	sudo cryptsetup open $target $mapping_name

}


make_fs () {

	echo
	printf "writing ext4 filesystem to /dev/mapper/$mapping_name\n"
	sudo mkfs.ext4 -L VAULT -j /dev/mapper/$mapping_name

}


mounting() {

	sudo mount /dev/mapper/$mapping_name $mountpoint
	echo
	printf "mounted /dev/mapper/$mapping_name to $mountpoint\n"

}


permissions() {

	#printf "write permission to $mountpoint\n"
	sudo chown -R $USER:wheel $mountpoint

}


check_close_target() {


	# all (vault close 'all')

	if [[ $target == "all" ]]; then

		close_all
		exit

	fi


	# single target (vault close 'target')

	filetype=$(file $target)

	if [[ -n $(printf "$filetype" | grep -i 'luks encrypted') ]]; then
		## $2 user entry ($target) is a luks encrypted file

		uuid=$(printf "$filetype" | awk '{print $11}')
		printf "luks encrypted file has uuid: $uuid\n"

		map_and_mp=$(lsblk -p $(losetup -j $target | awk -F : '{print $1}') | tail -n 1)
		vlt_mapper=$(echo "$map_and_mp" | awk '{print $1}' | cut -c 3-)
		printf "$vlt_mapper "

		mountpoint=$(echo "$map_and_mp" | awk '{print $7}')

		if [[ -n $mountpoint ]]; then

			printf "mounted to $mountpoint\n"
			unmount

		else

			printf "is not mounted\n"
			close_luks

		fi

	else

		# $target is no luks encrypted container
		a=1

	fi


	# mountpoint (vault close 'mountpoint')

	if [[ ! $(mountpoint $target | grep not) ]]; then
		## $2 user entry ($target) is not (!) not (grep) a mountpoint

		mountpoint=$target

		# check if mountpoint has a vlt_mapper
		vlt_mapper=$(lsblk -rp | grep $mountpoint | awk '{print $1}')
		#[TODO] lsblk add r option for other instances?

		if [[ -z $(printf $vlt_mapper | grep '/dev/mapper/vlt_') ]]; then

			printf "$target is not mapped to a vlt loopback device\n"

			exit

		fi


		if [[ -n $mountpoint ]]; then

			printf "$vlt_mapper is mounted to $mountpoint\n"
			unmount

		else

			#printf "is not mounted\n"
			close_luks

		fi

	else

		printf "no mountpoint detected for $target\n"

	fi


	# vlt_mapper (vault close vlt_mapper)

	## because of the code above; $2 user entry ($target) is
	## no vault file and no mountpoint,
	## but still /can/ be a loopback device (vlt_mapper)
	lsblk_p_grep_vf=$(lsblk -p | grep $target)

	if [[ -n $lsblk_p_grep_vf ]]; then
		## $2 user entry ($target) /can/ be a loopback device (vlt_mapper)

		vlt_mapper=$(printf "$lsblk_p_grep_vf" | awk '{print $1}' | cut -c 3- | grep $target)
		## two times grep $target;
		## if $target is (also) not loopback device (vlt_mapper)
		## then $vlt_mapper will become an empty string

		if [[ -n $vlt_mapper ]]; then
			## $2 user entry ($target) is a loopback device (vlt_mapper)

			mountpoint=$(printf "$lsblk_p_grep_vf" | cut -c 3- | \
				grep $vlt_mapper | \
				awk -F 'crypt ' '{print $2}')

			if [[ -n $mountpoint ]]; then

				printf "$vlt_mapper is mounted to $mountpoint\n"
				unmount

			else

				printf "is not mounted\n"
				close_luks

			fi
		fi


	else

		printf "no loopback device detected for $target\n"
		echo
		printf "invalid entry, please try again\n"
		exit

	fi

}


unmount() {

	echo
	printf "unmount & close? (Y/n) "

	reply_single
	echo

	if printf "$reply" | grep -iq "^n"; then

		exit

	else

		sudo umount $mountpoint
		printf "unmounted $vlt_mapper from mountpoint $mountpoint\n"

	fi

	#[TODO] ivm create?
	#close_luks

}


close_luks() {

	if [[ $option == "create" ]]; then

		#[TODO] can be one algo? (remove if)
		sudo cryptsetup close $mapping_name
		printf "cryptsetup closed $mapping_name\n"
		clear_cache
		printf "$target created succesfully\n"

	else

		sudo cryptsetup close $vlt_mapper
		printf "cryptsetup closed $vlt_mapper\n"
		clear_cache

	fi

}


clear_cache() {

	sudo sysctl --write vm/drop_caches=3
	exit 0

}


get_all_vlt_mappers() {

	vlt_mappers=$(lsblk -rp | grep vlt_ | sort -k 7 | awk '{print $1}')

	#[TODO] remove ops
	echo
	printf "TEST vlt_mappers:\n$vlt_mappers\n"
	echo


	if [[ -z "$vlt_mappers" ]]; then

		printf "no mapped vaults\n"
		exit

	fi

}


vault_info() {

	# show all mapper paths with their mountpoints

	info=$(lsblk -rp | grep vlt_ | sort -k 7)

	if [[ -z "$info" ]]; then

		printf "no mapped vaults\n"

	else

		printf "$info\n"

	fi

}


close_all() {

	unset target

	vault_info

	get_all_vlt_mappers

	#printf "sure to all unmount and close? (Y/n) "
	#echo
	#TODO yesno
	#TODO option: quick close all

	#for vlt_mapper in "${vlt_mappers[@]}"
	##for vlt_mapper in /dev/mapper/vlt_*
	##for vlt_mapper in $vlt_mappers
	#@#@printf "$vlt_mappers" | while read -r vlt_mapper; do
	while IFS='' read -r vlt_mapper; do

		#[TODO] remove ops
		printf "processing: $vlt_mapper\n"
		echo

		## get mountpoint of the current vlt_mapper
		mountpoint=$(mount | grep $vlt_mapper | cut -d " " -f 3)

		#[TODO] remove ops
		printf "mp: $mountpoint\n"
		echo

		sudo umount $mountpoint
		printf "unmounted $vlt_mapper from mountpoint $mountpoint\n"

		close_luks

	#@#@done
	done <<< "$vlt_mappers"

	echo
	printf "all vaults closed succesfully\n"


#	for vlt_mapper in "${vlt_mappers[@]}"; do
#
#		# unmount
#
#		## get mountpoints of vlt_mapper
#		mountpoint=$(mount | grep $vlt_mapper)
######
#		## check if vlt_mapper has a mountpoint
#		if [mountpoint -q $mountpoint]; then
#			## unmout with confirmation
#			printf "$mountpoint\n"
#			unmount
#
#			# close
#			close_luks
#		else
#			printf "$mountpoint is not a mountpoint\n"
#			printf "exiting\n"
#		fi
#
#	done

}



generate_pw() {

	echo
	printf "starting pwgn...\npress 'n' to abort "

	reply_single_hidden_timed
	echo

	if printf "$reply" | grep -iq "^n"; then

		# exit from this loop and continue
		return

	else

		sh ~/_git/code/tools/pwgn

	fi

}


# vault info

if [[ $option == "info" ]]; then

	vault_info

fi


# creating vaults

if [[ $option == "create" ]]; then

	size=$3
	[[ $size -lt 18 ]] && \
	# to prevent error: 'Requested offset is beyond real size of device'
	printf "minimum vault size is 18 MB\n" && exit 18
	# temporary mountpoint
	mountpoint="$HOME/_temp/$random_hex"
	mkdir -p "$mountpoint"

	check_file_exists
	create_mapper_name
	create
	open_luks
	make_fs
	permissions
	close_luks

	rmdir "$mountpoint"

fi


# opening vaults

## open a specific vault
if [[ $option == "open" ]]; then

	mountpoint=$3

	check_mp_dir
	generate_pw
	create_mapper_name
	open_luks
	permissions
	mounting

fi


# closing vaults

## close a vault
if [[ $option == "close" ]]; then

	check_close_target

fi
