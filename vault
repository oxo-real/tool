#!/bin/zsh
#
##
###
###                   _ _
### __   ____ _ _   _| | |_
### \ \ / / _` | | | | | __|
###  \ V / (_| | |_| | | |_
###   \_/ \__,_|\__,_|_|\__|
###
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### vault
### secure file containers
###
### (c) 2020 - 2021 cytopyge
###
##
#


# usage:
# vault create	<target> <size>
# vault open	<target> <mountpoint>
# vault close	<target> / all [-y, --no-confirm]
# vault info	[target]
#
# in which 'target' represents a location as:
# vault_file	(create, open)
# vlt_mapper	(close, info)
# mountpoint	(close, info)


## initialize hardcoded variables
developer="cytopyge"
script_name="vault"
initial_release_year=2019
source_dir="$HOME/_git/code/sources/functions"


# general function definitions

## define colors
source $source_dir/text_appearance

## reply functions
source $source_dir/reply_functions

## initial_screen
source $source_dir/splash_screen

## user authentication
source $source_dir/get_sudo


# actions (open, close, create or info)
action=$1
# target (<vault_file>, <mountpoint>, <vlt_mapper> or 'all')
target=$2


# dependencies

## define replies
source $HOME/_git/code/sources/functions/reply_functions
## define colors
source $source_dir/text_appearance


check_target_validity() {

	if [[ -z $target && $action == "info" ]]; then

		return

	elif [[ $target == "all" && $action == "close" ]]; then

		return

	elif [[ ! -f $target ]] && [[ ! -d $target ]]; then

			echo
			printf "${RED}$target invalid (permissions)${NOC}\n"
			exit 22

	fi

}


check_target_status() {

	if [[ $action == "create" ]]; then

		if [[ -f $target ]]; then

			printf "${RED}$target already exists!${NOC}\n"
			printf "overwrite? (y/N) "
			reply_single
			echo

			if printf "$reply" | grep -iq "^y"; then

				printf "${RED}about to overwrite $target${NOC}\n"
				printf "really sure? (y/N) "
				reply_single
				echo

				if printf "$reply" | grep -iq "^y"; then

					return

				else

					printf "target creation aborted\n"
					printf "$target already exists\n"
					exit 11

				fi

			else

				printf "target creation aborted\n"
				printf "$target already exists\n"
				exit 2

			fi

		fi

	fi

	#if [[ $action == "info" ]]; then
	#fi

	#if [[ $action == "close" ]]; then
	#fi

	#if [[ $action == "open" ]]; then
	#fi

}


check_container_size() {

	if [ $size -lt 18 ]; then

		# to prevent error: 'requested offset is beyond real size of device'
		printf "${RED}minimum vault size is 18 MB${NOC}\n" && exit 18

	fi

}


create_vlt_mapper_name() {

	# create pretty unique and traceable /dev/mapper/vlt_* name

	random_hex="$(< /dev/random tr -d -c "[:xdigit:]" | head -c 6)"

	mapping_name="vlt_$random_hex"
	vlt_mapper="/dev/mapper/vlt_$random_hex"

}


create_vault() {

	printf "writing random data to $target\n"

	dd \
		if=/dev/random \
		of=$target \
		bs=1M \
		count=$size \
		iflag=fullblock \
		status=progress

	echo
	printf "setting up crypto on $target\n"

	## cryptsetup with luks2
	cryptsetup luksFormat --type luks2 --verify-passphrase $target
	echo

	## cryptsetup with plain dm-crypt
	#cryptsetup \
	#	-y \
	#	--type plain \
	#	--cipher=aes-xts-plain64 \
	#	--hash=sha512 \
	#	--key-size=512 \
	#	--offset=0 \
	##	--key-file=/dev/sdX \
	#	--keyfile-offset=0 \
	#	$target enc

	## validate target
	printf "validating $target:\n"
	file $target

}


open_luks() {

	echo
	printf "decrypting $target\n"

	sudo cryptsetup open --type luks2 $target $mapping_name

	echo
	printf "mapping $target to $vlt_mapper\n"

}


make_fs () {

	echo
	printf "writing ext4 filesystem to $vlt_mapper\n"

	sudo mkfs.ext4 -L VAULT -j $vlt_mapper


}


permissions() {

	sudo chown -R $USER:wheel $mountpoint


}


close_luks() {


	sudo cryptsetup close $vlt_mapper

	printf "cryptsetup closed $vlt_mapper\n"

	clear_cache

}


clean_up() {

	# extra if, to be sure rm only happens
	# on temporarily mountpoint while creating a new vault

	if [[ $action == "create" ]]; then

		rmdir "$mountpoint"

	fi

}


check_mp_dir() {

	# existence & emptyness (for mounting)

	## no mountpoint entry
	if [[ -z $mountpoint ]]; then

		printf "${RED}empty mountpoint entry${NOC}\n"
		printf "vault open <vault_file> <mountpoint>\n"
		exit 3

	## mountpoint directory does not exist
	elif [[ ! -d $mountpoint ]]; then

			printf "${RED}$mountpoint does not exist!${NOC}\n" && exit 3

	## directory does exist
	elif [[ -d $mountpoint ]]; then

		## and is a mountpoint already
		if mount | awk '{print $3}' | grep -x $mountpoint > /dev/null; then

			printf "${RED}$mountpoint is already a mountpoint${NOC}\n" && exit 3

		fi

	else

		## mountpoint is clear!
		c=1

	fi

}


generate_pw() {

#	echo
	## save cursor
	tput sc

	printf "starting pwgn...\npress 'n' to abort "

	reply_single_hidden_timed

	## move cursor up one line
	tput cuu1
	## clear end of screen
	tput ed
	tput cuu1
	tput ed

	if printf "$reply" | grep -iq "^n"; then

		# exit from this loop and continue
		return

	else

		sh ~/_git/code/tools/pwgn

	fi

}


mounting() {


	sudo mount $vlt_mapper $mountpoint

}


get_vault_data() {

	# single target (vault close 'target')
	## target is a luks container, mountpoint or vlt_mapper

	## scenario1: container
	## target_type is a luks encrypted container file

	if [[ -z $target ]]; then

		return

	fi

	luks_status=1					# initialize luks_status
	if [[ -f $target ]]; then

		cryptsetup isLuks $target
		luks_status=$?				# set luks_status

	fi


	if [ $luks_status -eq 0 ]; then

		target_type="luks_container"

		luks_container=$target

		loopback_device=$(losetup -j $target | awk -F ':' '{print $1}')

			if [[ -z $loopback_device ]]; then

				## luks_container is not mapped
				luks_uuid=$(cryptsetup luksUUID $target)

				loopback_device="n/a"
				loop_ctime="n/a"
				loop_uuid="n/a"

				vlt_mapper="n/a"
				mountpoint="n/a"
				return


			else

				mountpoint=$(lsblk -parf --noheadings $loopback_device | \
					tail -n 1 | awk '{print $8}')

			fi

	fi


	## scenario2: mountpoint
	## target_type is a valid mountpoint

	mountpoint_status=1				# initialize mountpoint status
	if [[ -d $target ]]; then

		mountpoint -q $target
		mountpoint_status=$?		# set mountpoint status

	fi


	if [ $mountpoint_status -eq 0 ]; then

		target_type="mountpoint"

		mountpoint=$target

	fi


	## scenario3: vlt_mapper
	## target_type is a valid vlt_mapper

	if [[ -n $loop_active ]]; then

		# we are in a while loop from close_all
		target_type=""

	fi

	if [[ -z $target_type ]]; then

		vlt_target=$(lsblk -parf | grep vlt_ | awk '{print $1}' | grep $target)

		if [[ -n $vlt_target ]]; then
			## $2 user entry ($target) is a loopback device (vlt_mapper)

			target_type="vlt_mapper"

			vlt_mapper=$target

			mountpoint=$(mount | grep $vlt_mapper | cut -d " " -f 3)

		fi

	fi


	## scenario4: vlt w/o mp
	## vlt_mapper has no mountpoint

	if [[ -z $mountpoint ]]; then

		mountpoint="n/a"
		## assuming we have a vlt_mapper
		vlt_mapper=$(lsblk -parf --noheadings | grep vlt_ | grep -v % | awk '{print $1}')

	else

		## grep -w to prevent two hits if i.e. ../s and ../s2 exists
		vlt_mapper=$(lsblk -rp | grep -w $mountpoint | awk '{print $1}')

	fi



	if [[ -n $vlt_mapper ]]; then

		loop_uuid=$(lsblk -parf | grep $vlt_mapper | awk '{print $5}')

		loopback_device=$(lsblk -parf | grep -B 1 $loop_uuid | head -n 1 | \
			awk '{print $1}')

		luks_uuid=$(lsblk -parf | grep $loopback_device | awk '{print $4}')

		loop_ctime=$(ls -ila --time ctime \
			--time-style=+%Y%m%d_%H%M%S $loopback_device | awk '{print $8}')

		luks_container=$(losetup $loopback_device | cut -d "(" -f2 | cut -d ")" -f1)

	else

		## empty vlt_mapper
		vlt_mapper="n/a"

	fi

}


show_spec_info() {

	if [[ -z $target_type ]]; then

		## get_vault_data could not assign a target_type
		echo
		printf "no specific info available\n"
		printf "${RED}no valid target_type $target${NOC}\n"

		exit 77

	else

		echo
		printf "%22s${GREEN} %s${NOC}\n" "specific info for:" "$target_type $target"

		echo
		printf "%22s %s\n" "crypto container:" $luks_container
		printf "%22s %s\n" "luks_uuid:" $luks_uuid

		echo
		printf "%22s %s\n" "loopback device:" $loopback_device
		printf "%22s %s\n" "up since:" $loop_ctime
		printf "%22s %s\n" "loop_uuid:" $loop_uuid

		echo
		if [ $vlt_mapper != "n/a" ]; then

			printf "%22s %s\n" "vlt_mapper:" $vlt_mapper

		else

			printf "%22s${RED} %s${NOC}\n" "vlt_mapper:" $vlt_mapper

		fi

		if [ $mountpoint != "n/a" ]; then

			printf "%22s %s\n" "mountpoint:" $mountpoint

		else

			printf "%22s${RED} %s${NOC}\n" "mountpoint:" $mountpoint

		fi

	fi

}


check_target_exists() {

	# for close
	b=1

}


check_no_confirm() {

	if [[ -z $no_confirm ]]; then

		# no_confirm has no value; a confirmation dialogue comes up

		echo
		printf "unmount & close? (Y/n) "

		read reply_read_single

		if printf "$reply" | grep -iq "^n"; then

			echo
			confirmation="negative"
			printf "${RED}$action $target aborted by user${NOC}\n"

			if [[ -z $loop_active ]]; then

				# we are in a while loop from close_all
				exit

			fi

		else

			confirmation="positive"
			echo
			return

		fi

	fi

}


close_target() {

	# all (vault close 'all')

	if [[ $target == "all" ]]; then

		close_all
		exit

	else

	# close a single target

		get_vault_data
		show_spec_info

		check_no_confirm

		unmount
		close_luks

	fi

}


unmount() {

	if [[ -n $mountpoint && $mountpoint != "n/a" ]]; then

			sudo umount $mountpoint

			printf "$vlt_mapper unmounted from $mountpoint\n"

	fi

}


clear_cache() {


	sudo sysctl --write vm/drop_caches=3
	printf "${GREEN}vault closed succesfully${NOC}\n"

}


get_all_vlt_mappers() {

	vlt_mappers=$(lsblk -rp | grep vlt_ | sort -k 7 | awk '{print $1}')

	if [[ -z "$vlt_mappers" ]]; then

		vault_list
		exit

	fi

}


vault_list() {

	# show list of all mapper paths with their mountpoints

	info=$(lsblk -lp | grep vlt_ | sort -k 7)
	info_headers=$(lsblk -lp | head -n 1)

	if [[ -z "$info" ]]; then

		printf "${RED}no mapped vaults${NOC}\n"

	else

		printf "${GREEN}mapped vaults:${NOC}\n"
		printf "$info_headers\n"
		printf "$info\n"

	fi

}


vault_spec_info() {

	if [[ -n $target ]]; then

		# show info about specific target

		get_vault_data
		show_spec_info

	fi

}


close_all() {

	get_all_vlt_mappers
	vault_list

	vlt_mapper_loop_list=$vlt_mappers

	while IFS= read -r vlt_mapper <&9; do
		# IFS = internal field separator
		# <&9 .. 9<<<; see
		# notes/linux/shell/command/read/filedescriptor

		loop_active=1
		target=$vlt_mapper
		get_vault_data
		show_spec_info

		check_no_confirm

		if [[ $confirmation == "positive" ]]; then

			unmount
			close_luks

		fi

		if [[ -n $no_confirm ]]; then

			unmount
			close_luks

		fi

	done 9<<< "$vlt_mapper_loop_list"

	loop_active="" && unset loop_active

	echo
	vault_list

}


check_no_confirm_flag() {

	if [[ $action == 'close' ]]; then

		if [[ -n $no_confirm ]]; then

			case $no_confirm in

				-y)

					no_confirm=1
					# no_confirm has a value; no confirmation dialogue
					;;

				--no-confirm)

					no_confirm=1
					# no_confirm has a value; no confirmation dialogue
					;;

				*)

					printf "${RED}no valid option:${NOC} '$no_confirm'\n"
					no_confirm=""
					# no_confirm has no value; a confirmation dialogue comes up
					printf "exiting\n"
					exit 72
					;;

			esac

		fi

	fi

}


# vault info

if [[ $action == "info" ]]; then

	check_target_validity
	check_target_status

	vault_list
	vault_spec_info

fi


# create vault

if [[ $action == "create" ]]; then

	size=$3

	get_sudo

	check_target_validity
	check_target_status

	check_container_size
	create_vlt_mapper_name
	create_vault
	open_luks
	make_fs
	close_luks
	clean_up

fi


# open vault

if [[ $action == "open" ]]; then

	mountpoint=$3

	get_sudo

	check_target_validity
	check_target_status

	check_mp_dir
	generate_pw
	create_vlt_mapper_name
	open_luks
	mounting
	permissions

	target=$mountpoint

	get_vault_data
	show_spec_info

fi


# closing vaults

## close a vault
if [[ $action == "close" ]]; then

	no_confirm=$3

	get_sudo

	check_target_validity
	check_target_status
	check_no_confirm_flag

	close_target

fi


# no valid action

if [[ \
	$action != "info" && \
	$action != "create" && \
	$action != "open" && \
	$action != "close" \
	]]; then

	printf "${RED}no valid action${NOC}\n"
	exit 40

fi
