#!/usr/bin/env bash
#
##
###                              _
###  _ __ ___   ___  _   _ _ __ | |_ _ __
### | '_ ` _ \ / _ \| | | | '_ \| __| '__|
### | | | | | | (_) | |_| | | | | |_| |
### |_| |_| |_|\___/ \__,_|_| |_|\__|_|
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### mountr
### (un)mount blockdevice to mountpoint with fzf
###
### (c) 2020 - 2022  |  cytopyge
###
##
#


# dependencies: cytopyges' source functions, vault & fzf


# initial general definitions

## initialize hardcoded variables
script_name="mountr"
initial_release_year="2020"
source_dir="$XDG_DATA_HOME/c/git/code/source/function"


# functions

text_appearance() {
	source $source_dir/text_appearance
}


get_sudo() {
	# inverted text to indicate fzf script
	printf "\e[7m $script_name \e[27m\n"

	source $source_dir/get_sudo
	get_sudo
}


# fzf_inject
fzf_inject() {
	fzf_sel=$(printf "$fzf_input" | fzf --prompt="$prompt ")
}


validity_check() {
	## for mounting
	## check mountpoint dir existing
	if [[ ! -d $mp_mount ]]; then
		printf "${MAGENTA}directory does not exist${NOC}\n"
		exit 44
		#[TODO]printf "create $mp_mount? (y/N)\n"
	fi

	## check mountpoint already mounted
	if [[ -z $( mountpoint $mp_mount | grep not ) ]]; then
		printf "${MAGENTA}$mp_mount is already a mountpoint${NOC}\n"
		exit 44
	fi

	## check mountpoint dir empty
	if [[ -n $(ls -A $mp_mount) ]]; then
		printf "${MAGENTA}directory not empty${NOC}\n"
		exit 44
		#[TODO] create?
	fi

	#printf "${YELLOW}validity check complete${NOC}\n"
}


# specific function definitions

#########
# MOUNT #
#########


# get mountable source (block) devices

get_source_devs() {
    source_devs_avail=$(\

	lsblk -nrpo "name,type,size,label,mountpoint" | \
	## exclude non-volatile storage media on
	## peripheral component interconnect express bus
	grep -v nvme | \
	## only disks or partitions
	grep -e disk -e part | \
	## not already mounted
	awk 'length($5)==0' \

	)

    if [[ -z $source_devs_avail ]]; then

	printf "${MAGENTA}no mountable source devices detected${NOC}\n"
	printf "exiting\n"
	exit

    fi
}


sel_source_dev() {
    ## prepare variables
    fzf_input="$source_devs_avail"
    prompt="mount source_device"

    ## call fzf inject
    fzf_inject
    source_dev=$(echo $fzf_sel | awk '{print $1}')
}


get_mps_mount() {
    mps_avail=$(printf "/boot\n$HOME/dock/1\n$HOME/dock/2\n$HOME/dock/3\n$HOME/dock/4\nother")
}


sel_mp_mount() {
    ## prepare variables
    fzf_input="$mps_avail"
    prompt="select mountpoint for $source_dev "

    ## call fzf inject
    fzf_inject
    mp_mount=$(printf "$fzf_sel" | awk '{print $1}')
}


mount() {
    sudo mount -o gid=$(id -g $USER),uid=$(id -u $USER) $source_dev $mp_mount
    #sudo mount -o uid=$(whoami),gid=$(id -gn) $source_dev $mp_mount
    #sudo mount $source_dev $mp_mount
}


remount_options() {
    ## prepare variables
    fzf_input=$(printf "ro\nrw")
    prompt="REmount options:"

    ## fzf inject; gives $fzf_sel back
    fzf_inject
    ## extract option from $fzf_sel
    rorw=$fzf_sel
}


remount() {
    sudo mount -o remount,$rorw  $mp_umount
}


mount_info() {
    printf "${BLUE}$source_dev mounted to $mp_mount${NOC}\n"
}

#################
#  U M O U N T  #
#################


# get mountpoints that can be unmounted

get_mps_umount() {
    ## for umount
    mps_umount=$(findmnt --list -o TARGET,SIZE,SOURCE | grep '/dev/sd')
}


sel_mp_umount() {
    ## prepare variables
    fzf_input="$mps_umount"
    prompt="UMOUNT"

    ## fzf inject; gives $fzf_sel back
    fzf_inject
    ## extract mountpoint from $fzf_sel
    mp_umount=$(echo $fzf_sel | awk '{print $1}')
    source_dev=$(echo $fzf_sel | awk '{print $3}')
}


umount() {
    sudo umount $mp_umount
}


umount_info() {
    printf "${BLUE}$source_dev unmounted from $mp_umount${NOC}\n"
    exit 0
}


# action: mount or unmount

action() {

    text_appearance
    get_sudo

    ## prepare variables
    fzf_input="mount\nREmount\nUMOUNT"
    prompt=""

    ## call fzf inject
    fzf_inject
    action=$fzf_sel

    case $action in

    mount)
	get_source_devs
    	sel_source_dev
    	get_mps_mount
    	sel_mp_mount
    	validity_check
    	mount
    	mount_info
    	exit 0
    	;;

    UMOUNT)
    	get_mps_umount
    	sel_mp_umount
    	umount
    	umount_info
    	exit 0
    	;;

    REmount)
    	#get_source_devs
    	#sel_source_dev
	get_mps_umount
        sel_mp_umount
	remount_options
        remount
	#mount_info
	exit 0
	;;

    esac

}

action
