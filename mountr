#!/usr/bin/env bash
#
##
###                              _
###  _ __ ___   ___  _   _ _ __ | |_ _ __
### | '_ ` _ \ / _ \| | | | '_ \| __| '__|
### | | | | | | (_) | |_| | | | | |_| |
### |_| |_| |_|\___/ \__,_|_| |_|\__|_|
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### mountr
### (un)mount blockdevice to mountpoint with fzf
###
### (c) 2020 - 2022  |  cytopyge
###
##
#


# dependencies: cytopyges' source functions, vault & fzf


# initial general definitions

## initialize hardcoded variables
script_name="mountr"
initial_release_year="2020"
source_dir="$XDG_DATA_HOME/c/git/code/source/function"


text_appearance() {
	source $source_dir/text_appearance
}


get_sudo() {
	source $source_dir/get_sudo
	get_sudo
}


get_mps_mount() {
    mps_avail=$(printf "/boot\n$HOME/dock/1\n$HOME/dock/2\n$HOME/dock/3\n$HOME/dock/4\n$HOME/dock/transfer\nother")
    # TODO make sourced array
}


get_mps_umount() {
    ## for umount_func
    mps_umount=$(findmnt --list -o TARGET,LABEL,SOURCE,SIZE | \
	grep -e '/dev/sd' -e '/dev/mapper/vlt_' | sort)
}


get_source_devs() {
    source_devs_avail=$(\

	lsblk -nrpo "name,size,type,label,mountpoint" | \
	## exclude non-volatile storage media on
	## peripheral component interconnect express bus
	grep -v nvme | \
	## only disks or partitions
	grep -e disk -e part | \
	## not already mounted
	awk 'length($5)==0' \

	)

    if [[ -z $source_devs_avail ]]; then

	printf "${MAGENTA}no mountable source devices detected${NOC}\n"
	printf "exiting\n"
	exit 30

    fi
}


mount_to_select_param() {
    local fzf_input="$mps_avail"
    local fzf_prompt="select mountpoint for: $line_select"
    local fzf_options='--height=20%'

    fzf_choose
    mount_to=$fzf_select
}


devs_and_mps_param() {
    local fzf_input="$source_devs_avail\n$mps_umount"
    local fzf_prompt='(u)mount'
    local fzf_options='--height=20%'

    fzf_choose
    devs_and_mps=$fzf_select
}


fzf_choose() {
    fzf_select=$(printf "$fzf_input" | fzf -m --prompt="$fzf_prompt " $fzf_options)
}


mount_info() {
    local label=$(printf "$line_select" | awk '{print $4}')
    printf "$line_select_ff $label mounted to ${BLUE}$mount_to${NOC}\n"
}


umount_info() {
    local label=$(printf "$line_select" | awk '{print $2}')
    printf "${BLUE}$line_select_ff${NOC} $label umounted\n"
}


mountpoint_is_vlt() {
    mountpoint_is_vlt=$(printf "$line_select" | grep vlt_)
}


validity_check() {
    case $action in

        mount)
            case $mount_to in

                other)
		    read -r -p 'mount to? ' mount_to
          	    validity_check
          	    ;;

            esac


	    ## check source_dev
	    #[[ ! -b $source_dev ]] && \
	    #    printf "${MAGENTA}$source_dev${NOC} no block device\n" && \
	    #    exit 44

	    ## check mountpoint dir existing
	    [[ ! -d $mount_to ]] && \
	        printf "${MAGENTA}$mount_to${NOC} does not exist\n" && \
	        exit 44

	    ## check mountpoint already mounted
	    [[ -z $( mountpoint $mount_to | grep not ) ]] && \
	        printf "${MAGENTA}$mount_to${NOC} is already a mountpoint\n" && \
		    exit 44

	    ## check mountpoint dir empty
	    [[ -n $(ls -A $mount_to) ]] && \
	        printf "${MAGENTA}$mp_mount${NOC} no empty directory\n" && \
	        exit 44
            ;;

        umount)
	    mountpoint_is_vlt

    esac
}


process_devs_and_mps() {
    while IFS= read -r line_select; do

	# check if mountpoint
	# ff is first field
	line_select_ff=$(printf "$line_select" | awk '{print $1}')

	mountpoint -q $line_select_ff >/dev/null 2>&1

	case $? in

	    0)
		action='umount'

		mountpoint=$line_select_ff

		validity_check

		case $mountpoint_is_vlt in

		    '')
			sudo umount $mountpoint
			umount_info
			;;

		    *)
			vault close $mountpoint
			;;

		esac
		;;

	    *)
		action='mount'

		device=$line_select_ff

		## get location to mount to
		mount_to_select_param

		validity_check

		sudo mount $device $mount_to
		mount_info
		;;

	esac

    done <<< "$devs_and_mps"

}


main() {
    text_appearance
    get_sudo

    get_source_devs
    get_mps_umount
    get_mps_mount
    devs_and_mps_param
    process_devs_and_mps
}

main
