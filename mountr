#!/usr/bin/env bash
#
##
###                              _
###  _ __ ___   ___  _   _ _ __ | |_ _ __
### | '_ ` _ \ / _ \| | | | '_ \| __| '__|
### | | | | | | (_) | |_| | | | | |_| |
### |_| |_| |_|\___/ \__,_|_| |_|\__|_|
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### mountr
### (un)mount blockdevice to mountpoint with fzf
###
### (c) 2020 - 2022  |  cytopyge
###
##
#


# dependencies: cytopyges' source functions, vault & fzf


# initial general definitions

## initialize hardcoded variables
script_name="mountr"
initial_release_year="2020"
source_dir="$XDG_DATA_HOME/c/git/code/source/function"

crypto_source="$XDG_DATA_HOME/c/keys/pass/vlt_pass"
#pass_mount="$HOME/dock/vlt/pass"
password_store_lnk="$HOME/.password-store"

text_appearance() {
	source $source_dir/text_appearance
}


get_sudo() {
	source $source_dir/get_sudo
	get_sudo
}


get_mps_mount() {
    mps_avail+="$(printf "/boot\n$HOME/dock/1\n$HOME/dock/2\n$HOME/dock/3\n$HOME/dock/4\n$HOME/dock/transfer\nother")"
    # TODO make sourced array
}


get_mps_umount() {
    ## for umount_func
    mps_umount=$(findmnt --list -o TARGET,LABEL,SOURCE,SIZE | \
	grep -e '/dev/sd' -e '/dev/mapper/vlt_' | sort)
}


get_source_devs() {
    source_devs_avail=$(\

	\lsblk -nrp -o "name,size,type,label,mountpoint" | \
	## \lsblk prevents an alias causing error:
	## lsblk: mutually exclusive arguments: --pairs --tree --list --raw
	## exclude non-volatile storage media on
	## peripheral component interconnect express bus
	grep -v nvme | \
	## only disks or partitions
	grep -e disk -e part | \
	## size not 0B
	grep -v 0B | \
	## not already mounted
	awk 'length($5)==0' \

	)

	## TODO improve grep -v 0B


	# add password-store to source_devs_avail

	## if symlink to password-store exists
	if [[ -L $password_store_lnk ]]; then

	    ## and password-store is not already mounted
	    if [[ ! -d $(readlink $password_store_lnk) ]]; then

		## then add password-store to source_devs_avail
		source_devs_avail+=$(printf "\n$crypto_source")

	    fi

	fi

    if [[ -z $source_devs_avail ]]; then

	printf "${MAGENTA}no mountable source devices detected${NOC}\n"
	printf "exiting\n"
	exit 30

    fi
}


mount_to_select_param() {
    local fzf_input="$mps_avail"
    local fzf_prompt="select mountpoint for: $line"
    local fzf_options='--height=20%'

    fzf_choose
    mount_to=$fzf_select
}


devs_and_mps_param() {
    local fzf_input="$source_devs_avail\n$mps_umount"
    local fzf_prompt='(u)mount'
    local fzf_options='--height=20%'

    fzf_choose
    devs_and_mps=$fzf_select
}


fzf_choose() {
    fzf_select=$(printf "$fzf_input" | fzf -m --prompt="$fzf_prompt " $fzf_options)
}


mount_info() {
    local label=$(printf "$line" | awk '{print $4}')
    printf "$line_select_ff $label mounted to ${BLUE}$mount_to${NOC}\n"
}


umount_info() {
    local label=$(printf "$line" | awk '{print $2}')
    printf "${BLUE}$line_ff${NOC} $label umounted\n"
}


mapper_is_vlt() {
    mapper_is_vlt=$(printf "$line" | grep vlt_)
}


dev_is_luks() {
    sudo cryptsetup isLuks $device >/dev/null 2>&1
}


dev_is_mountpoint()
{
	mountpoint -q $line_ff >/dev/null 2>&1
}


validity_check() {
    case $action in

        mount)
	    if [[ -z $device ]]; then

		printf "no device selected\n"
		exit 11

	    fi

	    case $mount_to in

                other)
		    read -r -p 'mount to? ' <&1 mount_to
		    validity_check
          	    ;;

            esac

	    ## check mountpoint dir existing
	    [[ ! -d $mount_to ]] && \
	        printf "${MAGENTA}$mount_to${NOC} does not exist\n" && \
	        exit 44

	    ## check mountpoint already mounted
	    [[ -z $( mountpoint $mount_to | grep not ) ]] && \
	        printf "${MAGENTA}$mount_to${NOC} is already a mountpoint\n" && \
		    exit 44

	    ## check mountpoint dir empty
	    [[ -n $(ls -A $mount_to) ]] && \
	        printf "${MAGENTA}$mp_mount${NOC} no empty directory\n" && \
	        exit 44

	    dev_is_luks
	    ;;

        umount)
	    mapper_is_vlt
	    ;;

    esac
}


process_devs_and_mps() {
    while IFS= read -r -u 4 line; do

	# check if mountpoint
	# ff is first field
	line_ff=$(printf "$line" | awk '{print $1}')

	dev_is_vlt_pass
	dev_is_mountpoint

	case $? in

	    0)
		action='umount'

		mountpoint=$line_ff

		validity_check

		case $mapper_is_vlt in

		    '')
			sudo umount $mountpoint
			umount_info
			;;

		    *)
			vault close $mountpoint
			;;

		esac
		;;

	    *)
		action='mount'

		device=$line_ff

		## get location to mount to
		mount_to_select_param

		validity_check

		# (dev_is_luks)
    	    	case $? in

    	    	    0)
    	    	        vault open $device $mount_to
    	    	        ;;

		    *)
			sudo mount $device $mount_to
			mount_info
			;;
    	    	esac
		;;

	esac

    done 4<<< "$devs_and_mps"

}


dev_is_vlt_pass() {
    if [[ $(printf "$line_ff" | grep "$crypto_source") ]]; then

	pass_mount=$(readlink $password_store_lnk)
	[[ -d $pass_mount ]] || mkdir -p $pass_mount

	vault open $crypto_source $pass_mount

	exit 0

    fi

}


main() {
    text_appearance
    get_sudo

    get_source_devs
    get_mps_umount
    get_mps_mount
    devs_and_mps_param
    process_devs_and_mps
}

main
