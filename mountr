#!/usr/bin/env bash
#
##
###                              _
###  _ __ ___   ___  _   _ _ __ | |_ _ __
### | '_ ` _ \ / _ \| | | | '_ \| __| '__|
### | | | | | | (_) | |_| | | | | |_| |
### |_| |_| |_|\___/ \__,_|_| |_|\__|_|
###  _    _
### (_)><(_)
###
### mountr
### mount blockdevices ans mountpoints with fzf
###
### copyright (c) 2020 - 2022  |  oxo
###
##
#


# dependencies: source functions, vault & fzf


# mountr is a bash script to more easily:
# 1. mount source devices (source_devs_avail)
#    to commonly used mountpoints (common_mps)
# and
# 2. unmount mounted devices (mps_umount)
# by simply selecting device and/or mountpoint

# initial general definitions

## initialize hardcoded variables
script_name="mountr"
initial_release_year="2020"
source_dir="$XDG_DATA_HOME/c/git/code/source/function"

crypto_source="$XDG_DATA_HOME/c/keys/pass/vlt_pass"
#pass_mount="$HOME/dock/vlt/pass"
password_store_lnk="$HOME/.password-store"


text_appearance() {

    source $source_dir/text_appearance
}


get_sudo() {

    source $source_dir/get_sudo
    get_sudo
}


get_mps_mount() {

    # common mountpoints
    common_mps=(\
	 /boot \
	 $HOME/dock/1 \
	 $HOME/dock/2 \
	 $HOME/dock/3 \
	 $HOME/dock/4 \
	 $HOME/dock/transfer \
	 $HOME/dock/vlt/pass \
	 other\
	 )
#    common_mps+=(\
#	 /boot \
#	 $HOME/dock/1 \
#	 $HOME/dock/2 \
#	 $HOME/dock/3 \
#	 $HOME/dock/4 \
#	 $HOME/dock/transfer \
#	 $HOME/dock/vlt/pass \
#	 other\
#	 )

    # building mps_avail
    # mps_avail: common_mps available for mounting to
    mps_avail=()

    for mp in "${common_mps[@]}"; do

	# check if mp is already a mountpoint
	is_mp=$(mountpoint -q $mp; echo $?)

	case $is_mp in

	    0)
		# mp is not an available mountpoint
		continue
		;;

	    *)
		# mp is an available mountpoint
		mps_avail+=("$mp")
		;;

	esac

    done

    # mapped vlt's mounted
    # (not dock/vll/pass, which is already a common_mps)
    # little bit of a mess SDMB make this better
    number_vlt_not_vlt_pass=$(mount | grep '/dev/mapper/vlt_' | grep -v 'dock/vlt/pass' | wc -l)

    # if number of elements in mps_avail is the same
    # as the number of elements in common_mps,
    # plus number of vlt not vlt pass, then
    # none of the common_mps is mounted and
    # no vlt is mounted, therefore
    # there are no actionable mountpoints
    number_mounted=`echo - | awk "{print ${#common_mps[@]} - ${#mps_avail[@]}} + $number_vlt_not_vlt_pass"`

    if [[ $number_mounted -eq 0 ]]; then

	printf "${BLUE}no actionable mountpoints${NOC}\n"
	sleep 1

    fi

    if [[ -z ${source_devs_avail[@]} ]] && \
	   [[ $number_mounted -eq 0 ]]; then

   	exit 0

    fi
}


get_mps_umount() {

    ## umountable mountpoints
    mps_umount=$(findmnt --list -o SOURCE,SIZE,LABEL,TARGET | \
	grep -e '/dev/sd' -e '/dev/mmcblk' -e '/dev/mapper/vlt_' | \
	sort)

    ## add eol to source_devs_avail
}


remove_from_list () {

    # remove designated lines from source_devs_avail_list
    # to prevent sed error: 'extra characters after command'
    # start the sed sting with '\' and use alternative delimiters ':'
    source_devs_avail_list=$(echo "$source_devs_avail_list" | \
	grep -v -w "$1")
}


get_source_devs() {

    source_devs_avail_list=$(\
	\lsblk -nrp -o "name,type,size,label,mountpoint" | \
	## \lsblk prevents an alias causing error:
	## lsblk: mutually exclusive arguments: --pairs --tree --list --raw
	## exclude non-volatile storage media on
	## peripheral component interconnect express bus
	grep -v nvme | \
	## only disks and partitions
	grep -e disk -e part | \
	## size not 0B
	grep -v 0B)


    # correct for mounted devices in the list

    while IFS= read -r line; do

	field5=$(echo "$line" | cut -d ' ' -f 5)
	current_device=$(echo "$line" | cut -d ' ' -f 1)

	mountpoint $field5 &> /dev/null

	if [[ $? == 0 ]]; then

	    # field5 is a mountpoint
	    # device is mounted
	    # remove current line from source_devs_avail_list
	    remove_from_list $current_device

	fi

    done <<< "$source_devs_avail_list"


    # devices that have partitions must not show device path itself

    while IFS= read -r line; do

	## check if device type is disk
	## get device type from field2
	field2=$(echo "$line" | cut -d ' ' -f 2)

	case $field2 in

	    disk)
		## device type is 'disk'
		## number of lines that contain device path
		current_device=$(echo "$line" | cut -d ' ' -f 1)
		number_of_lines_contain_device=$(echo "$source_devs_avail_list" | grep "$current_device" | wc -l)

		if [[ $number_of_lines_contain_device -gt 1 ]]; then

		    ## there exists i.e. a /dev/sda and a /dev/sda1
		    ## current device (line) is /dev/sda (disk)
		    ## so that can be removed from the list
		    remove_from_list $current_device

		fi

		# case all partitions are mounted
		# then also remove current device (unmountable disk)
		if [[ $number_of_lines_contain_device -eq 1 ]];then

		  if [[ -n $(mount | grep "$current_device") ]]; then

		      remove_from_list $current_device

		  fi

		fi
		;;

	esac

    done <<< "$source_devs_avail_list"


    # save current ifs, change to newline, create array, reset ifs

    ifs_0=$IFS
    IFS=$'\n'
    source_devs_avail=("$source_devs_avail_list")
    IFS=$ifs_0


    # remove mounted vlt-mappers from source_devs_avail

    ## get mounted vlt_mappers
    vlt_mappers=()
    while IFS= read -r line; do

        vlt_mappers+=("$line")

    done <<< $(mount | grep vlt_ | cut -d ' ' -f 1)

    ## create mapper_source associative array (vlt_mapper=source_dev)
    declare -A mapper_source

    for vlt_mapper in ${vlt_mappers[@]}; do

	## get mapper data for current vlt_mapper from vault status
	vscm=$(vault status $vlt_mapper)
	source_dev=$(printf "$vscm" | grep 'crypto source' | awk '{print $3}')

	## add vlt_mapper source_dev to mapper_source associative array
	## key: vlt_mapper
	## value: source_dev
	mapper_source["$vlt_mapper"]="$source_dev"

    done


    ## loop through mapper_source keys (vlt_mappers)
    ## and remove sources from source_devs_avail
    ## these sources are already mounted
    for mapper in "${!mapper_source[@]}"; do

	## get the mapper_source device that is linked to mapper
	## and remove it from source_devs_avail
        target_source_dev="${mapper_source[$mapper]}"

	for (( i=0; i<=${#source_devs_avail[*]}; i++ )); do

	    sda_name="$(printf "%s\n" "${source_devs_avail[$i]}" | cut -d ' ' -f 1)"

	    if [[ "$sda_name" == "$target_source_dev" ]]; then

		unset 'source_devs_avail[i]'

		# remove the gap
		tmp_array=()
		for i in "${!source_devs_avail[@]}"; do

		    tmp_array+=( "${source_devs_avail[i]}" )

		done

		source_devs_avail=("${new_array[@]}")
		unset tmp_array

	    fi

	done

    done


    while IFS= read -r -u 4 line; do

	get_device_data
	convert_data_no_label

	dev_has_mountpoint

	# remove device from array
	case $? in

	    0)
		element_del=$line

		for line in "${source_devs_avail}"; do

		    # create new array without element_del
		    [[ "$line" != "$element_del" ]] && \
			tmp_array2+=($line)

		    # reset source_devs_avail
		    source_devs_avail=()
		    source_devs_avail=$tmp_array2
		    unset tmp_array2

		done
		;;

	esac

    done 4<<< "$source_devs_avail"

    # TODO if all is empty then exit
    # check queriing array source_devs_avail
    if [[ -z ${source_devs_avail[@]} ]]; then

	printf "${BLUE}no actionable source devices${NOC}\n"
	sleep 1

    fi
}


print_source_devs_avail()
{
    #DEV
    printf "DEV source_devs_avail:\n"
    print_entire_array() {
       declare -n __p="$1"
    	for k in "${!__p[@]}"; do
    	    printf "%s=%s\n" "$k" "${__p[$k]}"
       done
       }
    print_entire_array source_devs_avail
}


refresh_mps_avail() {

    unset common_mps
    unset mps_avail
    get_mps_mount
}


mount_to_select_param() {

    # choose mountpoint
    local fzf_input=$(printf '%s\n' "${mps_avail[@]}")
    local fzf_prompt="mountpoint: $line"
    local fzf_options='--height=20%'

    fzf_choose
    mount_to=$fzf_select
}


devs_and_mps_param() {

    # choose devices (mount) and or mountpoints (umount)

    local fzf_input="$(printf "%s\n%s" "${source_devs_avail[@]}" "$mps_umount")"

    # for aesthetic reasons; remove empty line in fzf_input
    # TODO find a better way to do this
    if [[ -z "${source_devs_avail[@]}" ]]; then

	local fzf_input="$(printf "%s%s" "${source_devs_avail[@]}" "$mps_umount")"

    fi

    local fzf_prompt='(u)mount'
    local fzf_options='--height=20%'

    fzf_choose
    devs_and_mps=$fzf_select
}


fzf_choose() {

    fzf_select=$(printf "$fzf_input" | fzf -m --header="${BOLD}source device			      mountpoint${NORMAL}" --prompt="$fzf_prompt " $fzf_options)

    # no choice: print status of available source devices and umountable mountpoints
    case $fzf_select in

	'')

	    printf "${BOLD}source device\t\t\t\tmountpoint${NORMAL}\n"

	    # for aesthetic reasons; avoid empty line
	    # TODO find a better way to do this
	    if [[ -n "${source_devs_avail[@]}" ]]; then

		printf "%s\n" "${source_devs_avail[@]}"

	    fi

	    printf "$mps_umount"

	    exit 0
	    ;;

    esac
}


mount_info() {

    printf "$source_dev $dev_type $size $label mounted to ${BLUE}$mount_to${NOC}\n"
}


umount_info() {

    printf "$source_dev $dev_type $size $label umounted from ${BLUE}$mountpoint${NOC}\n"
}


mapper_is_vlt() {

    mapper_is_vlt=$(printf "$line" | grep vlt_)
}


dev_is_luks() {

    sudo cryptsetup isLuks $device >/dev/null 2>&1
}


get_device_data() {

    source_dev=$(printf "$line" | cut -d ' ' -f 1)
    dev_type=$(\lsblk -nrp -o "name,type" | grep -w "$source_dev" | cut -d ' ' -f 2)
    size=$(printf "$line" | cut -d ' ' -f 3)
    label=$(printf "$line" | cut -d ' ' -f 4)

    # CAUTION!
    ## when coming from findmnt:
    ## if dev has no label: label contains mountpoint

    mountpoint=$(printf "$line" | awk '{print $NF}')
}


convert_data_no_label() {

    # CAUTION!
    ## when coming from findmnt:
    ## if dev has no label: label contains mountpoint
    ## correct messed up fields here

    ## correct label
    if [[ "$label" == "$mountpoint" ]]; then

	label='noLBL'

    fi

    # ## correct size
    # if [[ "$size" == "$dev_type" ]]; then

    # 	size=$(printf "$line" | awk '{print $3}')

    # fi

    # ## correct mountpoint
    # if [[ "$mountpoint" == "$size" ]]; then

    # 	# device has no label and is not mounted
    # 	mountpoint=''

    # fi
}


dev_has_mountpoint() {

    mountpoint -q $mountpoint &> /dev/null
}


validity_check() {

    case $action in

        mount)
	    if [[ -z $device ]]; then

		printf "no device selected\n"
		exit 11

	    fi

	    case $mount_to in

                other)
		    read -r -p "mount $device to " <&1 mount_to
		    validity_check
          	    ;;

            esac

	    ## check mountpoint dir existing
	    [[ ! -d $mount_to ]] && \
	        printf "${MAGENTA}$mount_to${NOC} does not exist\n" && \
	        exit 44

	    ## check mountpoint already mounted
	    [[ -z $( mountpoint $mount_to | grep not ) ]] && \
	        printf "${MAGENTA}$mount_to${NOC} is already a mountpoint\n" && \
		    exit 44

	    ## check mountpoint dir empty
	    [[ -n $(ls -A $mount_to) ]] && \
	        printf "${MAGENTA}$mp_mount${NOC} no empty directory\n" && \
	        exit 44

	    dev_is_luks
	    ;;

        umount)
	    mapper_is_vlt
	    ;;

    esac
}


process_devs_and_mps() {

    # processing fzf selection
    while IFS= read -r -u 4 line; do

	dev_is_vlt_pass
	get_device_data
	convert_data_no_label

	dev_has_mountpoint

	case $? in

	    0)
		action='umount'

		validity_check

		case $mapper_is_vlt in

		    '')
			sudo umount $mountpoint
			umount_info
			;;

		    *)
			vault close $mountpoint
			;;

		esac
		;;

	    *)
		action='mount'

		device=$(printf "$line" | awk '{print $1}')

		## get location to mount to
		mount_to_select_param

		validity_check

		# (dev_is_luks)
    	    	case $? in

    	    	    0)
    	    	        vault open $device $mount_to
    	    	        ;;

		    *)
			sudo mount $device $mount_to
			mount_info
			;;
    	    	esac

	        refresh_mps_avail

		;;

	esac

    done 4<<< "$devs_and_mps"
}


dev_is_vlt_pass() {

    if [[ $(printf "$line" | grep "$crypto_source") ]]; then

	pass_mount=$(readlink $password_store_lnk)
	[[ -d $pass_mount ]] || mkdir -p $pass_mount

	vault open $crypto_source $pass_mount

	exit 0

    fi
}


main() {

    text_appearance
    get_sudo

    get_source_devs
    #print_source_devs_avail
    get_mps_umount
    get_mps_mount
    devs_and_mps_param
    process_devs_and_mps
}

main
