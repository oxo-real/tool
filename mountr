#!/usr/bin/env bash
#
##
###                              _
###  _ __ ___   ___  _   _ _ __ | |_ _ __
### | '_ ` _ \ / _ \| | | | '_ \| __| '__|
### | | | | | | (_) | |_| | | | | |_| |
### |_| |_| |_|\___/ \__,_|_| |_|\__|_|
###  _    _
### (_)><(_)
###
### mountr
### mount blockdevices ans mountpoints with fzf
###
### copyright (c) 2020 - 2022  |  oxo
###
##
#


# dependencies: source functions, vault & fzf


# initial general definitions

## initialize hardcoded variables
script_name="mountr"
initial_release_year="2020"
source_dir="$XDG_DATA_HOME/c/git/code/source/function"

crypto_source="$XDG_DATA_HOME/c/keys/pass/vlt_pass"
#pass_mount="$HOME/dock/vlt/pass"
password_store_lnk="$HOME/.password-store"

text_appearance() {

    source $source_dir/text_appearance
}


get_sudo() {

    source $source_dir/get_sudo
    get_sudo
}


get_mps_mount() {

    # common mountpoints
    common_mps+=(\
	/boot \
	$HOME/dock/1 \
	$HOME/dock/2 \
	$HOME/dock/3 \
	$HOME/dock/4 \
	$HOME/dock/transfer \
	other\
    )

    # building mps_avail
    for mp in "${common_mps[@]}"; do

	# check if mp is already a mountpoint
	is_mp=$(mountpoint -q $mp; echo $?)

	case $is_mp in

	    0)
		# mp is not an available mountpoint
		continue
		;;

	    *)
		# mp is an available mountpoint
		mps_avail+=( $mp )
		;;

	esac

    done
}


get_mps_umount() {

    ## umountable mountpoints
    mps_umount=$(findmnt --list -o TARGET,SIZE,LABEL,SOURCE | \
	grep -e '/dev/sd' -e '/dev/mapper/vlt_' | sort)
}


get_source_devs() {
    source_devs_avail=$(\
	\lsblk -nrp -o "name,type,size,label,mountpoint" | \
	## \lsblk prevents an alias causing error:
	## lsblk: mutually exclusive arguments: --pairs --tree --list --raw
	## exclude non-volatile storage media on
	## peripheral component interconnect express bus
	grep -v nvme | \
	## only disks or partitions
	grep -e disk -e part | \
	## size not 0B
	grep -v 0B | \
	## not already mounted
	awk 'length($5)==0'\
	)

	## #sda+=($source_devs_avail1)

	## #printf "DEV\n $source_devs_avail1"; exit 255
	## #printf "DEV\n ${sda[@]}"; exit 255


	# add password-store to source_devs_avail

	## if symlink to password-store exists
	if [[ -L $password_store_lnk ]]; then

	    ## and password-store is not already mounted
	    if [[ ! -d $(readlink $password_store_lnk) ]]; then

		## then add password-store to source_devs_avail
		source_devs_avail+=(printf "$crypto_source")

	    ## and password-store is already mounted
	    elif [[ -d $(readlink $password_store_lnk) ]]; then

		## then add password-store to mps_avail
		password_store_mp=$(printf "$(readlink $password_store_lnk)")
		mps_avail+=($password_store_mp)

	    fi

	fi

    if [[ -z $source_devs_avail ]] && [[ -z $mps_avail ]]; then

	printf "${MAGENTA}no mountable source devices detected${NOC}\n"
	printf "exiting\n"
	exit 30

    fi
}


mount_to_select_param() {
    # choose mountpoint
    local fzf_input=$(printf '%s\n' "${mps_avail[@]}")
    local fzf_prompt="mountpoint: $line"
    local fzf_options='--height=20%'

    fzf_choose
    mount_to=$fzf_select
}


devs_and_mps_param() {
    # choose devices (mount) and or mountpoints (umount)
    local fzf_input="$source_devs_avail\n$mps_umount"
    local fzf_prompt='(u)mount'
    local fzf_options='--height=20%'

    fzf_choose
    devs_and_mps=$fzf_select
}


fzf_choose() {

    fzf_select=$(printf "$fzf_input" | fzf -m --header="${BOLD}source device						mountpoint${NORMAL}" --prompt="$fzf_prompt " $fzf_options)
    #fzf_select=$(printf "$fzf_input" | fzf -m --prompt="$fzf_prompt " $fzf_options)

    # no choice: print available source devices and umountable mountpoints
    case $fzf_select in

	'')
	    printf "${BOLD}source device\t\t\t\t\t\tmountpoint${NORMAL}\n$source_devs_avail\n$mps_umount\n"
	    exit 0
	    ;;

    esac
}


mount_info() {

    printf "$line mounted to ${BLUE}$mount_to${NOC}\n"
}


umount_info() {

    local size=$(printf "$line" | awk '{print $2}')
    local label=$(printf "$line" | awk '{print $3}')
    local source_dev=$(printf "$line" | awk '{print $4}')
    local type=$(\lsblk -nrp -o "name,type" | grep $source_dev | awk '{print $2}')

    printf "$source_dev $type $size $label  umounted from ${BLUE}$mountpoint${NOC}\n"
}


mapper_is_vlt() {
    mapper_is_vlt=$(printf "$line" | grep vlt_)
}


dev_is_luks() {
    sudo cryptsetup isLuks $device >/dev/null 2>&1
}


dev_is_mountpoint()
{
    mountpoint -q $line_ff >/dev/null 2>&1
}


validity_check() {
    case $action in

        mount)
	    if [[ -z $device ]]; then

		printf "no device selected\n"
		exit 11

	    fi

	    case $mount_to in

                other)
		    read -r -p "mount $device to? " <&1 mount_to
		    validity_check
          	    ;;

            esac

	    ## check mountpoint dir existing
	    [[ ! -d $mount_to ]] && \
	        printf "${MAGENTA}$mount_to${NOC} does not exist\n" && \
	        exit 44

	    ## check mountpoint already mounted
	    [[ -z $( mountpoint $mount_to | grep not ) ]] && \
	        printf "${MAGENTA}$mount_to${NOC} is already a mountpoint\n" && \
		    exit 44

	    ## check mountpoint dir empty
	    [[ -n $(ls -A $mount_to) ]] && \
	        printf "${MAGENTA}$mp_mount${NOC} no empty directory\n" && \
	        exit 44

	    dev_is_luks
	    ;;

        umount)
	    mapper_is_vlt
	    ;;

    esac
}


process_devs_and_mps() {
    while IFS= read -r -u 4 line; do

	# check if mountpoint
	# ff is first field
	line_ff=$(printf "$line" | awk '{print $1}')

	dev_is_vlt_pass
	dev_is_mountpoint

	case $? in

	    0)
		action='umount'

		mountpoint=$line_ff

		validity_check

		case $mapper_is_vlt in

		    '')
			sudo umount $mountpoint
			umount_info
			;;

		    *)
			vault close $mountpoint
			;;

		esac
		;;

	    *)
		action='mount'

		device=$line_ff

		## get location to mount to
		mount_to_select_param

		validity_check

		# (dev_is_luks)
    	    	case $? in

    	    	    0)
    	    	        vault open $device $mount_to
    	    	        ;;

		    *)
			sudo mount $device $mount_to
			mount_info
			;;
    	    	esac
		;;

	esac

    done 4<<< "$devs_and_mps"

}


dev_is_vlt_pass() {
    if [[ $(printf "$line_ff" | grep "$crypto_source") ]]; then

	pass_mount=$(readlink $password_store_lnk)
	[[ -d $pass_mount ]] || mkdir -p $pass_mount

	vault open $crypto_source $pass_mount

	exit 0

    fi

}


main() {
    text_appearance
    get_sudo

    get_source_devs
    get_mps_umount
    get_mps_mount
    devs_and_mps_param
    process_devs_and_mps
}

main
